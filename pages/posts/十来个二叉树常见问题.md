---
layout: post
title: 十来个二叉树常见问题
date: 2025-08-31 13:37:48
categories: 算法
tags:
  - 算法
  - 二叉树
  - 编程
  - C++
cover: 'https://pic.akorin.icu/20250827175108039.webp'
codeHeightLimit: 500
toc: true
time_warning: false
end: false
---

一些经典的关于二叉树的算法问题。

# 我脑子不转了，有什么头猪吗。

<!-- more -->

## 树区间元素搜索问题

比如在某一棵BST树中，输出区间为 `10~50` 之间的所有数。

区间内的节点就输出，如果在区间外就不用遍历了。

其实不用中序遍历也行，但是中序遍历输出就是有序的值。
```C++
void findValues(Node* node, int i, int j) {
    if (!node)
        return;
    // 中序遍历
    if (node->data_ > i)
        findValues(node->left_, i, j);   // L
    // V
    if (node->data_ <= j && node->data_ >= i) {
        cout << node->data_ << " ";
    }
    if (node->data_ < j)
        findValues(node->right_, i, j);   // R
}
void findValues(int i, int j) {
    findValues(root_, i, j);
    cout << endl;
}
```

## 判断一颗二叉树是否是BST树

利用 **中序遍历升序** 的特点，只要发现当前节点的值小于前一个节点的值，那就判断肯定不是BST树。

:::warning
不要用局部的 左孩子 < 根节点 < 右孩子 来判断是否是BST树，应该看全局。
:::

```C++
// 需要只用引用指针，否则更改指针也只是更改拷贝的指针，带不回上一层
static bool isBST(Node* node, Node* &pre) {
    if (!node)
        return true;
    if (!isBST(node->left_, pre))
        return false;
    // V
    Camp camp_;
    // 第一次回程时pre指针依然是nullptr，此时跳过
    if (pre && camp_(node->data_, pre->data_)) {
        return false;
    }
    // 如果满足条件，更新当前正在遍历的父节点
    pre = node;
    // 进入右子树遍历
    return isBST(node->right_, pre);
}
```