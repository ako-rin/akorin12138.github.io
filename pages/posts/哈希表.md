---
title: 哈希表
date: '2025-08-23 10:11:08 +0800'
updated: '2025-08-23 00:53:14 +0800'
categories: 笔记
tags:
  - 笔记
  - 编程
  - C++
codeHeightLimit: 750
cover: 'https://pic.akorin.icu/20250823154413875.webp'
end: true
time_warning: false
---

# 哈
<!-- more -->

## 哈希表

- 哈希表（Hash Table）：一种基于 键（key）→值（value）映射 的数据结构。
- 核心思想：通过哈希函数（Hash Function）把 key 转换成数组下标，从而快速访问数据。
- 时间复杂度：
  - 查找、插入、删除：理想情况下接近 O(1)。
  - 最坏情况下（大量冲突）：O(n)。

## 哈希函数

也叫 **散列函数** 或者 **映射函数** ，照某种规律将关键字k映射到某个值的函数，一般是**除留余数法**：用素数来取余（经过数学证明得出，用素数取余可以降低哈希碰撞/冲突的可能性）。

常见的哈希函数有：
- **直接函数法**： `H(key) = f(key) = a · key + b`
- **数字分析法**：分析数字找出数字规律，利用这些数据来构造冲突纪律低的散列地址。
- **平方取中法**：取关键字平方后的中间几位作为散列地址。
- **折叠法**：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。
- **随机数法**：选择一随机函数，取关键字作为随机函数的种子，生成随机值作为散列地址，通常用于关键字长度不同的场合。
- **除留余数法**：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。

## 哈希冲突

- **线性探测法**：当出现冲突向后找位置，还有加强版：平方探测法，即向前或者向后以平方数来查找。
- **链地址法** ：也叫做**拉链法**，在同一个位置用链表将数据连接起来。

:::tip 装载因子
**装载因子（loadfactor） = 已占用桶（表）的个数 / 桶的总个数**

- 装载因子不能太大也不能太小。
- 装载因子太大则输入哈希表时，发生哈希碰撞的概率就很大。
- 装载因子太小则浪费空间。
- 一般设定的默认值是**0.75**
- 若装载因子超过设定的值时，一般就要为哈希表进行扩展操作。
:::

## 哈希函数（Hash Function）
  - 插入：任意大小的 key，经过哈希函数后放入对应哈希表中的位置，装载因子超过0.75需要先**扩容**。
  - 输出：数组索引（0 ~ table_size-1），也是经过哈希函数取得对应位置。
  - 删除：同理，但是删除后的位置**需要放置特殊符**，避免破坏其它的位置的查找。
  - 扩容：一般哈希表输入数据用的都是除留余数法，扩容后要给每个原来的数除上新的素数才行，因此该操作至少得O(n)。

均摊下来哈希表的各种操作的时间复杂度为O(1)。

### 线性探测哈希表

1. 每个桶存放数据和桶的状态。
2. 用数组来存放每个桶。
3. 出现哈希冲突主要使用**线性探测法来解决**。

```C++
// 定义哈希表状态
enum HState {
    IDLE,    // 空闲
    USING,   // 正在使用
    DELTE    // 已删除
};

// 定义哈希表的存储结构
struct Bucket {
    Bucket(int data = 0) : data_(data), state_(IDLE) {}
    int data_;
    HState state_;
};

// 定义哈希表功能函数
class HashTable {
public:
    HashTable(int size = 3) : prime_(0), factor_(0.75), size_(0) {
        for (; prime_ < 10; ++prime_) {
            if (primeNums_[prime_] >= size)
                break;
        }
        // 越界处理
        if (prime_ == PRIMESIZE)
            prime_--;
        capacity_ = primeNums_[prime_];
        table_ = new Bucket[capacity_];
    }
    ~HashTable() {
        delete[] table_;
        table_ = nullptr;
    }

public:
    // 插入元素
    bool insert(int data) {
        // 判断是否需要扩展
        double fac = size_ * 1.0 / capacity_;
        if (fac > factor_)
            expand();
        int i = data % capacity_;
        do {
            if (table_[i].state_ != USING) {
                table_[i].data_ = data;
                table_[i].state_ = USING;
                ++size_;
                return true;
            }
            // 更新 i
            i = (i + 1) % capacity_;
        } while (i != data % capacity_);
        return false;
    }
    // 删除元素
    bool del(int data) {
        int i = find(data);
        if (i > 0) {
            --size_;
            table_[i].state_ = DELTE;
            return true;
        } else {
            return false;
         }
    }
    // 查找
    int find(int data) {
        int i = data % capacity_;
        do {
            if (table_[i].state_ == IDLE) {
                cout << "No data!" << endl;
                return -1;
            } else if (table_[i].state_ == USING &&
                       table_[i].data_ == data) {
                return i;
            } else {
                i = (i + 1) % capacity_;
                continue;
            }
        } while (i != data % capacity_);
        cout << "No data!" << endl;
        return -1;
    }

private:
    void expand() {
        if (prime_ == PRIMESIZE - 1) {
            throw "There is no space to expand!";
        }
        ++prime_;
        int oldCapacity = capacity_;
        // 更新容量
        capacity_ = primeNums_[prime_];
        Bucket* p = new Bucket[capacity_];
        for (int i = 0; i < oldCapacity; ++i) {
            // 若该值有效
            if (table_[i].state_ == USING) {
                int j = table_[i].data_ % capacity_;
                do {
                    if (p[j].state_ != USING) {
                        p[j].state_ = USING;
                        p[j].data_ = table_[i].data_;
                        break;
                    }
                    j = (j + 1) % capacity_;
                } while (j != table_[i].data_ % capacity_);
            }
        }
        delete [] table_;
        table_ = p;
        p = nullptr;
    }

private:
    Bucket* table_;   // 表指针
    int size_;        // 哈希表有效数据
    int capacity_;    // 哈希表容量
    double factor_;

    static const int PRIMESIZE = 10;
    static int primeNums_[PRIMESIZE];   // 素数表
    int prime_;                         // 当前使用的素数下标
};
```

### 线性探测哈希表的缺陷：
- 发生哈希冲突时，靠近O(n)的时间复杂度。
- 多线程的情况下，只能给全局的表用互斥锁保证哈希表的原子操作，来保证线程安全。

但是！在线性探测哈希表可以使用**分段的锁**，既保证了线程安全，又有了一定的并发量，提高了效率。

:::tip 分段锁（Segmented Lock）
**分段锁**：
- 将整个数据结构（如哈希表）划分为多个段（segment），每个段配备一个独立的锁（如 std::mutex）。
- 每次操作（插入、查找、删除）时，只锁住对应段的锁，而不是整个表。
- 不同线程只要操作的数据落在不同的段上，就可以并发执行，大大提升并发性能。
:::

### 链式哈希表

1. 桶是以链表的形式来存储数据和数据状态。
2. 用数组来存放每个桶，每个桶存放的是 **链表头节点**。
3. 出现哈希冲突不需要线性探测法。
4. 但是当桶的链表比较长时，链表搜索花费的时间就大，时间复杂度趋近于O(n)。

如果是用向量 `vector` 和stl的 `list` 以及泛型算法 `::find`  来组合成链式哈希表就简单多了（笑）。

```C++
// 定义链表节点
struct Node {
    Node(int data = 0) : next_(nullptr), data_(data) {}
    Node* next_;
    int data_;
};

// 定义哈希表功能函数
class HashTable {
public:
    HashTable(int size = 3) : prime_(0), factor_(0.75), size_(0) {
        for (; prime_ < 10; ++prime_) {
            if (primeNums_[prime_] >= size)
                break;
        }
        // 越界处理
        if (prime_ == PRIMESIZE)
            prime_--;
        capacity_ = primeNums_[prime_];
        table_ = new Node*[capacity_];
        // 此时数组里还都是野指针，只给指针分配了空间，没有分配头节点
        for (int i = 0; i < capacity_; ++i) {
            table_[i] = new Node;
        }
    }
    ~HashTable() {
        for (int i = 0; i < capacity_; ++i) {
            Node* p = table_[i];
            while (p) {
                Node* q = p;
                p = p->next_;
                delete q;
            }
        }
        delete[] table_;
        table_ = nullptr;
    }

public:
    // 插入元素，默认不重复
    double insert(int data) {
        // 判断是否需要扩展
        double fac = size_ * 1.0 / capacity_;
        if (fac > factor_)
            expand();
        int i = data % capacity_;
        // 如果是空桶，则增加占用个数
        if (!table_[i]->next_)
            ++size_;
        // 头插法
        Node* p = new Node(data);
        p->next_ = table_[i]->next_;
        table_[i]->next_ = p;
        return fac;
    }
    // 删除元素
    bool del(int data) {
        int i = data % capacity_;
        Node* p = table_[i];
        Node* q = p->next_;
        while (q && q->data_ != data) {
            p = q;
            q = p->next_;
        }
        if (q) {
            p->next_ = q->next_;
            delete q;
            // 如果刚才删的是最后一个节点，此时变为空桶，size-1
            if (p == table_[i] && !p->next_)
                --size_;
            return true;
        } else {
            return false;
        }
    }
    // 查找，返回要删除节点的上一个节点
    Node* find(int data) {
        int i = data % capacity_;
        Node* p = table_[i];
        Node* q = p->next_;
        while (q) {
            if (q->data_ == data) {
                return p;
            }
            p = p->next_;
            q = p->next_;
        }
        return nullptr;
    }

private:
    void expand() {
        if (prime_ == PRIMESIZE - 1) {
            throw "There is no space to expand!";
        }
        // 清空占用桶的数量
        size_ = 0;
        ++ prime_;
        int oldCapacity = capacity_;
        // 更新容量
        capacity_ = primeNums_[prime_];
        Node** p = new Node*[capacity_];
        // p中还都是野指针
        for (int i = 0; i < capacity_; ++i) {
            p[i] = new Node;
        }
        for (int i = 0; i < oldCapacity; ++i) {
            Node* q = table_[i]->next_;
            // 此时如果是空桶那就占用个数+1
            if (!q)
                ++size_;
            while (q) {
                int j = q->data_ % capacity_;   // 新位置
                Node* k = q;
                q = q->next_;
                // 头插更新
                k->next_ = p[j]->next_;
                p[j]->next_ = k;
            }
            delete table_[i];
        }
        delete[] table_;
        table_ = p;
        p = nullptr;
    }

private:
    Node** table_;   // 表指针(表中存储的都是指针，因此是双指针)
    int size_;       // 哈希表占用桶的个数
    int capacity_;   // 哈希表容量
    double factor_;

    static const int PRIMESIZE = 10;
    static int primeNums_[PRIMESIZE];   // 素数表
    int prime_;                         // 当前使用的素数下标
};

int HashTable::primeNums_[PRIMESIZE] = {
    3, 7, 23, 47, 97, 251, 443, 911, 1471, 42773};

```

#### 优化
- 优化一：当链表长度大于8/10...，把桶里的链表转化成 **红黑树** （无论是什么操作都是O(logn)）
- 优化二：为每个桶添加一个 **分段锁** ，来控制当前的桶的链表不能并发操作，但是不同桶的链表可以并发操作。


## 扩展-堆内存管理器

在向量 `vector` 中使用 `swap` 交换两个成员变量时就涉及到堆内存管理器 `allocator`了。
- 若两个向量是同一个内存管理器 `allocator` 分配的，则 `swap` 方法效率非常高，因为第二个向量的指针直接指向第一个向量开辟的堆内存。
- 若两个向量的对内存管理器不同（一个是stl自带的，使用 `malloc` `free`管理内存，另一个也许是自行定制的）， **两个容器管理外部堆内存的方式不一样** ，则就不是直接交换成员变量了，而是低效率地遍历所有变量再交换。

> 关于堆内存管理器：
<!--@include: ./gccSimpleLearn.md{1098,1180}-->