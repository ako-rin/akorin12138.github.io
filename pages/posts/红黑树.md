---
layout: post
title: 红黑树
date: 2025-09-03 15:40:41
categories: 算法
tags:
  - 算法
  - 二叉树
  - 红黑树
  - 编程
  - C++
cover: 'https://pic.akorin.icu/20250904212252303.webp'
codeHeightLimit: 500
toc: true
time_warning: true
end: true
updated: '2025-09-05 21:03:10'
---

# 红黑树

红黑树不是一颗平衡树，节点到左右子树的高度差， **长的不超过短的2倍。** 比AVL旋转的次数要少很多。

红黑树通过给节点增加**颜色属性（红/黑）**并遵循一组规则，保证树的高度始终接近 O(log n)，从而在最坏情况下也能高效完成查找、插入和删除操作。

如果主要使用查询操作，那就还是AVL树的效率更高一点。但是如果插入、删除、查询都很频繁，这个时候使用红黑树就比较好了。

> 由于红黑树要频繁访问祖父节点和舅舅节点，主流都采用非递归的形式。

<!-- more -->

## 红黑树的规则

红黑树必须满足以下 5 条性质：

1. 每个节点要么是红色，要么是黑色；
2. 根节点 **必须** 是黑色；
3. 所有叶子节点的孩子都是NULL，NULL是黑色；
4. 如果一个节点是红色的，那么它的子节点必须是黑色的（不能有两个连续的红色节点）；
5. 对于任意节点，从该节点到所有叶子节点的路径上，黑色节点数相同（黑高一致）。

这些规则保证了树不会出现太长的链状结构，从而接近平衡。  
根据规则4、5，当插入节点（红节点）与虽规则4冲突时，其必有一个

在这5条规则下，假如有两条路径，一条全是黑节点，另一条是红节点和黑节点相间。此时，最长的一条是最短的一条的两倍。

基于这5条规则也可得出：

1.  **红黑树上，节点的左右子树高度差最多不能超过同一路径上的黑色节点数的一倍，也就是说最长路径不会超过最短路径的两倍。**
2.  要出现只有一棵子树的情况，只有 **一黑一红时** 才会出现。如果 **一黑一红** 的子树添加黑节点，则不满足规则5，如果添加红节点，则不满足规则4。
3.  红节点 **要么没有孩子要么必定有两个黑孩子** ，不会出现只有一个黑孩子的情况。
4.  **黑节点必定有一个兄弟。**

### 红黑树的定义

:::code-group

```C++ [节点定义]
struct Node {
    Node(T data = T(), Node* parent = nullptr, Node* left = nullptr,
          Node* right = nullptr, Color color = Black) :
        data_(data),
        left_(left),
        right_(right),
        parent_(parent),
        color_(color) {}
    T data_;
    Node* left_;
    Node* right_;
    Node* parent_;
    Color color_;
};
```

```C++ [类定义和颜色定义]

enum Color { Black, Red };

template<typename T>
class RBTree {
private:
    struct Node;

public:
    RBTree() : root_(nullptr) {}
    ...
}

```

:::

### 辅助接口

```C++

// 获取节点颜色
Color getColor(Node* node) {
    return node ? node->color_ : Black;
}
// 设置节点颜色
void setColor(Node* node, Color color) {
    node->color_ = color;
}
// 返回节点的左孩子
Node* getLeft(Node* node) {
    return node->left_;
}
// 返回节点的右孩子
Node* getRight(Node* node) {
    return node->right_;
}
// 返回节点的父亲
Node* getParent(Node* node) {
    return node->parent_;
}
```

## 红黑树的旋转

1. 和AVL树的旋转操作类似，但是红黑树的节点增添了一个父节点指针， **因此旋转过程中需要更新父节点地址。**
2. 由于是非递归代码，需要记录好要旋转节点的父节点和孩子。
3. 若父节点为 `nullptr` ，说明是根节点在旋转，因此需要更新 `root_` 根节点指针。
4. 判断当前节点 `node` 是父节点的哪个孩子，更新父节点的孩子为 `child_` 。
5. 开始旋转，更新 `child_` 孩子（若存在）的父节点为 `node`，并挂在 `node` 上。
6. 将 `node` 挂在 `child_` 上并更新其父节点指针为 `child_` 。

:::code-group

```C++ [左旋转]
// 左旋转
void leftRotate(Node* node) {
    if (!node)
        return;
    Node* child = node->right_;
    if (!child)
        return;
    Node* parent = node->parent_;
    if (!parent) {
        // 头节点在旋转
        root_ = child;
    } else if (parent->left_ == node) {
        parent->left_ = child;
    } else {
        parent->right_ = child;
    }
    child->parent_ = parent;

    node->right_ = child->left_;
    if (node->right_) {
        // 避免是nullptr
        node->right_->parent_ = node;
    }
    child->left_ = node;
    node->parent_ = child;
}
```

```C++ [右旋转]
// 右旋转
void rightRotate(Node* node) {
    if (!node)
        return;
    Node* child = node->left_;
    if (!child)
        return;
    Node* parent = node->parent_;
    if (!parent) {
        // 头节点在旋转
        root_ = child;
    } else if (parent->left_ == node) {
        parent->left_ = child;
    } else {
        parent->right_ = child;
    }
    child->parent_ = parent;

    node->left_ = child->right_;
    if (node->left_) {
        // 避免是nullptr
        node->left_->parent_ = node;
    }
    child->right_ = node;
    node->parent_ = child;
}
```

:::

## 红黑树的插入

1. 常规 BST 插入定位
   - 若树为空：创建节点并染成黑色（根必须黑）。插入结束。
   - 否则：创建新节点，初始颜色设为红色（这是关键：用红色先不影响黑高）。
2. 如果新节点的父亲是黑色：不违反任何性质（允许黑-红，允许黑-黑），插入完成。
3. 如果父亲是红色：出现“红红冲突”（违反性质 4），需要修复。设：
   - `p` = parent（红）
   - `g` = grandparent（必为黑，否则上一轮已修）
   - `u` = uncle（g 的另一个孩子，可能为空，空视为黑）
4. 分三大类（经典 while 循环中的三个 Case，左右对称）：
   - **Case 1**（叔叔 u 是红）
     - 将父亲 p 和叔叔 u 染黑
     - 将祖父 g 染红
     - 将“当前节点”上移为 g，继续循环（因为 g 变红后可能与其父再形成红红）
   - **Case 2**（叔叔 u 是黑，且当前节点是“内侧”——形成“折线”）:变色后，需要维持原来黑色节点个数不变。
     - 先对父亲做一次旋转（把折线转成直线）
     - 交换当前节点与父亲角色（当前节点重新指向父亲，进入 Case 3）
   - **Case 3**（叔叔 u 是黑，且当前节点是“外侧”——形成“直线”）：变色后，需要维持原来黑色节点个数不变。
     - 将父亲 p 染黑，祖父 g 染红
     - 对祖父 g 做一次旋转（把祖父下沉）
     - 该冲突解决，跳出循环
5. 结束后强制把根染成黑色（可能因上移步骤使根被染红）。
6. 插入完成。

:::code-group

```C++ [插入函数]
// 插入
void insert(const T& val) {
    if (!root_) {
        // 性质三：根节点必须为黑色
        root_ = new Node(val);   // 默认black
        return;
    }
    // 树不为空
    Node* parent = nullptr;
    Node* cur = root_;
    while (cur) {
        if (val < cur->data_) {
            parent = cur;
            cur = cur->left_;
        } else if (val > cur->data_) {
            parent = cur;
            cur = cur->right_;
        } else {
            // 不插重复值
            return;
        }
    }
    // 此时cur == nullptr
    Node* node = new Node(val, parent, nullptr, nullptr, Red);
    if (val < parent->data_) {
        parent->left_ = node;
    } else {
        parent->right_ = node;
    }

    if (parent->color_ == Red) {
        // 当父节点也是红节点，此时需要进行调整
        fixAfterInsert(node);
    }
    // 父节点是黑节点就不管了
}
```

```C++ [调整函数]
// 红黑树插入调整操作
void fixAfterInsert(Node* node) {
    while (node != root_ && node->parent_->color_ == Red) {
        // 获取三个需要操作节点的指针
        Node* parent = node->parent_;
        Node* ancestor = parent->parent_;
        if (ancestor->left_ == parent) {
            // node在左子树，uncle在右子树
            Node* uncle = ancestor->right_;
            // 情况1，如果叔叔不存在那么也归属到情况2/3中
            if (getColor(uncle) == Red) {
                parent->color_ = Black;
                ancestor->color_ = Red;
                uncle->color_ = Black;
                node = ancestor;
            } else {
                // 情况2/3，先处理情况3，情况3转换成情况2
                if (node == parent->right_) {
                    node = parent;
                    // 使node指针始终指向parent的孩子节点
                    // 否则旋转后指针会移动，parent和node指针会互换位置
                    leftRotate(node);
                    parent = node->parent_;
                }
                // 情况2/3处理后，祖先自然是黑节点，不用再调整祖先
                // 改色需要在情况3旋转之后，否则可能会染错颜色
                parent->color_ = Black;
                ancestor->color_ = Red;
                rightRotate(ancestor);
                break;
            }
        } else {
            Node* uncle = ancestor->left_;
            if (getColor(uncle) == Red) {
                parent->color_ = Black;
                ancestor->color_ = Red;
                uncle->color_ = Black;
                node = ancestor;
            } else {
                // 情况2/3，先处理情况3，情况3转换成情况2
                if (node == parent->left_) {
                    node = parent;
                    // 使node指针始终指向parent的孩子节点
                    // 否则旋转后指针会移动，parent和node指针会互换位置
                    rightRotate(node);
                    parent = node->parent_;
                }
                // 情况2/3处理后，祖先自然是黑节点，不用再调整祖先
                // 改色需要在情况3旋转之后，否则可能会染错颜色
                parent->color_ = Black;
                ancestor->color_ = Red;
                leftRotate(ancestor);
                break;
            }
        }
    }
    // 强制根节点设置为黑，直接设置为黑就行
    root_->color_ = Black;
}
```

:::

## 红黑树的删除

1. BST 常规查找要删除的键 `val`。
2. 若目标节点有两个非空孩子：
   - 找中序后继（或前驱），交换数据（只换值不换指针），然后把删除目标转化成“最多只有一个非空孩子”的节点。
3. 若目标节点有一个非空孩子或没有：
   - 将其孩子接到它的父节点上，然后删除该目标节点。
4. 判断删除的是黑色节点还是红色节点。如果是 **红色** ，则是正常的BST删除，如果是 **黑色** ，则要判断补上来的孩子是什么颜色。
5. 如果补上来的 **孩子是红色** ，那就 **不用往兄弟节点借黑节点** 了，直接把红孩子染成黑色即可。  
   如果 **孩子是黑色** ，那就要进入到删除修复中， **看能不能从兄弟节点借黑节点过来，或者将其它分支的黑节点个数都减一。**

### 删除修复（四大类情形）

设当前“需要补黑的位置”为 `cur`，它的父亲为 `p`，兄弟为 `s`（sibling），兄弟的靠外孩子为 `s_far`（相对父亲的外侧），靠内孩子为 `s_near`。

> 约定：空指针颜色视为黑色。

| 情形   | 条件                                   | 操作                                                                                          | 结果 / 下一步                                                                             |
| ------ | -------------------------------------- | --------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| Case 1 | 兄弟为黑，靠外孩子红                   | 兄弟颜色设为父颜色；父染黑；靠外孩子染黑；围绕父做一次旋转。                                  | 双黑问题解决（跳出循环）。                                                                |
| Case 2 | 兄弟为黑，靠外孩子黑，靠内孩子红       | 兄弟与靠内孩子交换颜色；围绕兄弟做一次旋转（朝“靠外”方向相反的旋转）；更新兄弟指针。          | 转化为 Case 1。                                                                           |
| Case 3 | 兄弟为黑 且 兄弟两个孩子都黑（或为空） | 兄弟染红，这样另一颗子树就会少一个黑节点；当前双黑“上移”到父亲：`cur = p`，`p = cur.parent`。 | 可能继续向上，往祖先回溯（双黑冒泡）。 **直至所有分支的黑色节点个数都减一或红祖先染黑。** |
| Case 4 | 兄弟 `s` 为红                          | 交换父兄颜色；围绕父做一次旋转（让兄弟变成新的父）。                                          | 转化为兄弟为黑的情形，继续循环。                                                          |

最后：如果循环结束时 `cur` 在根但仍为“虚拟双黑”，直接把它视为普通黑（根强制为黑）。

:::tip 双黑节点
双黑节点可以看作一个标识，表示该节点的子树比其它子树 **少一个黑节点** ，此时要让兄弟子树也少一个黑节点，这样才能局部地让子树满足规则5。然后要回溯到其父节点，让父节点变成 **“双黑节点”** ，再让父节点（如果父节点还是黑节点）的兄弟子树少一个黑节点，这样就能让更大的子树满足规则5。
:::

> 对于 case2 （LR/RL型）先交换兄弟和兄弟孩子的颜色，再旋转兄弟，变成 case1 的形态。
> ![](https://pic.akorin.icu/20250905175306490.webp)

在 case1 中：

1. **红孩子染黑**
   - 避免旋转后出现连续红节点（违反红黑树性质 4）。
   - 同时，它也在旋转后为路径补上一个黑色，保证黑高平衡。
   - 其实相当于 **继承了兄弟的颜色** ，保证该子树黑高平衡。
2. **兄弟染成父亲的颜色**
   - 这是为了 **继承父节点原本的颜色信息** ，避免上层祖先的黑高被破坏。
   - 一旦旋转，兄弟会上升取代父节点位置，如果它 **不继承父亲的颜色，就会让祖先那一侧的黑高丢失。**
3. **父亲染黑** - 父亲下沉（旋转后变成子节点），补充黑节点。- 这等价于把「丢失的黑色」往下补给，让子树的黑高一致。
   ![](https://pic.akorin.icu/20250905175334343.webp)

在 case4 中， **红兄弟的孩子必为黑节点** ，因此：

1. **兄父颜色交换**
   - 旋转后保持黑高不变，避免出现 “红红” 情况。
2. **父节点右旋**
   - 将兄弟的孩子变成原来父亲的孩子，转换成双黑节点（被删除节点）的兄弟为黑的情况接着处理。

:::code-group

```C++ [删除函数]
// 自写红黑树删除
void del(const T& val) {
    // 一般BST删除
    Node* cur = root_;
    while (cur) {
        if (val < cur->data_) {
            cur = cur->left_;
        } else if (val > cur->data_) {
            cur = cur->right_;
        } else {
            // 找到
            break;
        }
    }
    if (!cur) {
        // 没找到或者树为空
        cout << "No data or No tree" << endl;
        return;
    }
    // 情况三
    if (cur->left_ && cur->right_) {
        // 前驱
        Node* pre = cur->left_;
        while (pre->right_) {
            pre = pre->right_;
        }
        cur->data_ = pre->data_;
        cur = pre;   // 统一使用cur指针
    }
    // 先处理再删除
    Color deleteNodeColor = cur->color_;
    if (deleteNodeColor == Black) {
        fixBeforeRemove(cur);
    }
    // 情况1/2
    Node* parent = cur->parent_;
    Node* child = cur->left_ ? cur->left_ : cur->right_;
    if (child) {
        child->parent_ = parent;
    }
    if (!parent) {
        // 删除的是根节点，且只有一个子树（一黑一红）
        root_ = child;
    } else if (cur == parent->left_) {
        parent->left_ = child;
    } else {
        parent->right_ = child;
    }
    // 孩子接上父节点了，删除目标节点
    delete cur;
    // 强制染黑根节点
    if (root_) {
        root_->color_ = Black;
    }
}
```

```C++ [调整函数]
// 红黑树删除前调整，node不可能为空
void fixBeforeRemove(Node* node) {
    // 定义一个辅助判断黑色函数
    auto isBlack = [](Node* n) -> bool {
        Color c = n ? n->color_ : Black;
        return c == Black;
    };
    if (node == root_) {
        return;
    }
    Node* parent = node->parent_;
    if (node == parent->left_) {
        Node* bro = parent->right_;
        // 兄弟在右
        // 情况4：兄弟为红。情况4处理完成后变成黑兄弟的情况。
        // 黑节点必定存在兄弟，不用判定兄弟是否为空
        if (bro->color_ == Red) {
            // 交换兄父颜色
            parent->color_ = Red;
            bro->color_ = Black;
            leftRotate(parent);
            // 更新兄弟指针，旋转后parent指针没有动，bro指针变成祖父节点
            bro = parent->right_;
        }
        // 情况3：黑兄弟且两个黑孩子。
        // 黑兄弟有可能有两个黑孩子或没有孩子（两个nullptr）
        if (isBlack(bro->left_) && isBlack(bro->right_)) {
            // 兄弟染红
            bro->color_ = Red;
            if (parent->color_ == Red) {
                parent->color_ = Black;
                // 调整完毕
            } else {
                // 回溯父节点
                fixBeforeRemove(parent);
            }
        } else {
            // 情况1/2
            if (bro->right_->color_ != Red) {
                // 情况2：黑兄弟有一个靠内红孩子，靠外是黑孩子
                // 交换兄孩颜色
                bro->color_ = Red;
                bro->left_->color_ = Black;
                rightRotate(bro);
                bro = parent->right_;   // 更新兄弟指针
            }
            // 情况1：黑兄弟有一个靠外红孩子
            bro->right_->color_ = bro->color_;
            bro->color_ = parent->color_;
            parent->color_ = Black;
            leftRotate(parent);
            // 调整完毕
        }
    } else {
        Node* bro = parent->left_;
        // 兄弟在左
        // 情况4：兄弟为红。情况4处理完成后变成黑兄弟的情况。
        // 黑节点必定存在兄弟，不用判定兄弟是否为空
        if (bro->color_ == Red) {
            // 交换兄父颜色
            parent->color_ = Red;
            bro->color_ = Black;
            rightRotate(parent);
            // 更新兄弟指针，旋转后parent指针没有动，bro指针变成祖父节点
            bro = parent->left_;
        }
        // 情况3：黑兄弟且两个黑孩子。
        // 黑兄弟有可能有两个黑孩子或没有孩子（两个nullptr）
        if (isBlack(bro->left_) && isBlack(bro->right_)) {
            // 兄弟染红
            bro->color_ = Red;
            if (parent->color_ == Red) {
                parent->color_ = Black;
                // 调整完毕
            } else {
                // 回溯父节点
                fixBeforeRemove(parent);
            }
        } else {
            // 情况1/2
            if (bro->left_->color_ != Red) {
                // 情况2：黑兄弟有一个靠内红孩子，靠外是黑孩子
                // 交换兄孩颜色
                bro->color_ = Red;
                bro->right_->color_ = Black;
                leftRotate(bro);
                bro = parent->left_;   // 更新兄弟指针
            }
            // 情况1：黑兄弟有一个靠外红孩子
            bro->left_->color_ = bro->color_;
            bro->color_ = parent->color_;
            parent->color_ = Black;
            rightRotate(parent);
            // 调整完毕
        }
    }
}
```
:::
