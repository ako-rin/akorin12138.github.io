---
layout: post
title: 二叉树
date: 2025-08-27 17:01:08
categories: 算法
tags:
  - 算法
  - 二叉树
  - 编程
  - C++
cover: 'https://pic.akorin.icu/20250827175108039.webp'
codeHeightLimit: 500
toc: true
time_warning: false
end: false
updated: '2025-08-27 23:53:38'
---

# 二叉树
二叉树（Binary Tree）是一种 树形数据结构，它的每个节点最多有 两个子节点，通常称为：
- 左子节点（Left Child）
- 右子节点（Right Child）
所以，二叉树的每个节点最多分叉 2 个，而不是任意多个。

<!-- more -->

## 各种节点

- **根节点**：二叉树最顶端的节点，没有父节点。
- **父节点**：有子节点的节点，直接连接其子节点。
- **子节点**：由父节点直接指向的节点。
- **兄弟节点**：拥有同一个父节点的节点。
- **叶子节点**：没有任何子节点的节点。
- **内部节点**：既不是根节点也不是叶子节点的节点。
- **左子节点**：父节点的左边分支上的节点。
- **右子节点**：父节点的右边分支上的节点。
- **祖先节点**：从根节点到该节点路径上的所有节点。
- **后代节点**：以某节点为根的子树中的所有节点。

## 搜索二叉树

对于二叉树上的每一个节点，如果满足：

**左孩子的值 < 父节点的值 < 右孩子的值**

则成为 **搜索二叉树(BST, Binary Search Tree)**

第 $L$ 层的孩子节点 $n$ 个数公式如下：

$$
n = 2^{(L-1)}
$$

### 插入节点

1. 从根节点开始，比较插入值 `val` 与当前节点值 `cur->val`
2. 如果 `val < cur->val`，进入左子树；如果 `val > cur->val`，进入右子树
3. 递归或循环找到空位置，插入新节点
4. 保持 BST 性质不变

### 删除节点

1. **节点没有孩子（叶子）**
   - 直接删除节点即可
2. **节点只有一个孩子**
   - 用孩子顶替节点位置
   - 如果删除的是根节点，更新 root 指针
3. **节点有两个孩子**
   - 找右子树最小节点（或左子树最大节点）
   - 用该节点值覆盖要删除节点
   - 删除右子树最小节点（或左子树最大节点），其孩子数 ≤ 1

### 寻找节点

1. 从根节点开始，设当前节点为 `cur`
2. 比较目标值 `key` 与 `cur->val`
   - 如果 `key == cur->val` → 找到节点，返回
   - 如果 `key < cur->val` → 进入左子树继续查找
   - 如果 `key > cur->val` → 进入右子树继续查找
3. 若节点为空 (`nullptr`) → 查找失败，节点不存在

