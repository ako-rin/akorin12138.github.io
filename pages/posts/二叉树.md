---
layout: post
title: 二叉树
date: 2025-08-27 17:01:08
categories: 算法
tags:
  - 算法
  - 二叉树
  - 编程
  - C++
cover: 'https://pic.akorin.icu/20250827175108039.webp'
codeHeightLimit: 500
toc: true
time_warning: false
end: false
updated: '2025-08-28 00:14:53'
---

# 二叉树
二叉树（Binary Tree）是一种 树形数据结构，它的每个节点最多有 两个子节点，通常称为：
- 左子节点（Left Child）
- 右子节点（Right Child）
所以，二叉树的每个节点最多分叉 2 个，而不是任意多个。

<!-- more -->

## 各种节点

- **根节点**：二叉树最顶端的节点，没有父节点。
- **父节点**：有子节点的节点，直接连接其子节点。
- **子节点**：由父节点直接指向的节点。
- **兄弟节点**：拥有同一个父节点的节点。
- **叶子节点**：没有任何子节点的节点。
- **内部节点**：既不是根节点也不是叶子节点的节点。
- **左子节点**：父节点的左边分支上的节点。
- **右子节点**：父节点的右边分支上的节点。
- **祖先节点**：从根节点到该节点路径上的所有节点。
- **后代节点**：以某节点为根的子树中的所有节点。

## 搜索二叉树

对于二叉树上的每一个节点，如果满足：

**左孩子的值 < 父节点的值 < 右孩子的值**

则成为 **搜索二叉树(BST, Binary Search Tree)**

第 $L$ 层的孩子节点 $n$ 个数公式如下：

$$
n = 2^{(L-1)}
$$

### 插入节点

1. 从根节点开始，比较插入值 `val` 与当前节点值 `cur->val`
2. 如果 `val < cur->val`，进入左子树；如果 `val > cur->val`，进入右子树
3. 递归或循环找到空位置，插入新节点
4. 保持 BST 性质不变

### 删除节点

1. **节点没有孩子（叶子）**
   - 直接删除节点即可
2. **节点只有一个孩子**
   - 用孩子顶替节点位置
   - 如果删除的是根节点，更新 root 指针
3. **节点有两个孩子**
   - 找右子树最小节点（也叫做 **后继节点** ）（或左子树最大节点（也叫做 **前驱节点** ））
   - 用该节点值覆盖要删除节点
   - 删除右子树最小节点（或左子树最大节点），其孩子数 ≤ 1

### 寻找节点

1. 从根节点开始，设当前节点为 `cur`
2. 比较目标值 `key` 与 `cur->val`
   - 如果 `key == cur->val` → 找到节点，返回
   - 如果 `key < cur->val` → 进入左子树继续查找
   - 如果 `key > cur->val` → 进入右子树继续查找
3. 若节点为空 (`nullptr`) → 查找失败，节点不存在

```C++ [非递归实现增删查]
template<typename T, typename Camp = less<T>>
class BSTree {
public:
    BSTree(Camp camp = Camp()) : root_(nullptr),camp_(camp) {}

public:
    // 避免不必要的拷贝
    bool insert(const T& val) {
        if (root_ == nullptr) {
            root_ = new Node(val);
            return true;
        }
        Node* parent = nullptr;
        Node* cur = root_;

        while (cur) {
            parent = cur;
            if (camp_(val, cur->data_)) {
                cur = cur->left_;
            } else if (camp_(cur->data_, val)) {
                cur = cur->right_;
            } else {
                // 不计入重复数
                return false;
            }
        }
        cur = new Node(val);
        if (camp_(val, parent->data_)) {
            parent->left_ = cur;
        } else {
            parent->right_ = cur;
        }
        return true;
    }
    bool del(const T& val) {
        if (!root_) {
            return false;
        }
        Node* cur = root_;
        Node* parent = nullptr;

        // 移动cur
        while (cur) {
            parent = cur;
            if (camp_(val, cur->data_)) {
                cur = cur->left_;
            } else if (camp_(cur->data_, val)) {
                cur = cur->right_;
            } else {
                // 找到了/没找到
                break;
            }
        }
        // 没找到
        if (!cur)
            return false;

        // 先处理情况3：
        // root有两个孩子节点
        // 处理完成后自动变成处理情况1/2
        if (cur->left_ && cur->right_) {
            Node* p = cur;
            parent = cur;
            cur = cur->left_;
            while (cur->right_) {
                // 在这里找前驱，也可以找后继
                parent = cur;
                cur = cur->right_;
            }
            // 此时出来后 cur 即为最大的左子树值
            // cur 也是前驱节点
            p->data_ = cur->data_;
        }

        // 此时处理情况1/2
        // 要判断处理此时前驱节点的孩子
        // 此时有可能是删的只有一个孩子的头节点
        Node* child = cur->left_ ? cur->left_ : cur->right_;
        if (!parent) {
            // 删只有一个孩子的头节点
            root_ = child;
        } else if (parent->left_ == cur) {
            parent->left_ = child;
        } else {
            parent->right_ = child;
        }
        delete cur;
        return true;
    }
    bool find(const T& val) {
        Node* cur = root_;
        while (cur) {
            if (camp_(val, cur->data_)) {
                cur = cur->left_;
            } else if (camp_(cur->data_, val)) {
                cur = cur->right_;
            } else {
                // 不计入重复数
                return true;
            }
        }
        return false;
    }

private:
    struct Node {
        Node(T data = T()) :
            data_(data), left_(nullptr), right_(nullptr) {}
        T data_;
        Node* left_;
        Node* right_;
    };

private:
    Camp camp_;
    Node* root_;
};
```

### 递归的前中后层序遍历

- V：根节点
- L：左孩子节点
- R：右孩子节点

**不管是什么遍历都是L出现在R之前。**

访问头节点的次序决定了不同的访问方式，因此就有：

- VLR：前序遍历
- LVR：中序遍历
- LRV：后序遍历

访问根节点的孩子后，当前的孩子节点又作为根节点来访问孩子。

对于BST树，由于排列方式都是 左孩子<根节点<右孩子。因此 **BST树中序遍历后就是一个从小到大升序的数列。**

:::code-group
```C++ [前序遍历]
void preOrder() {
    preOrder_(root_);
}
void preOrder_(Node* p) {
    if (!p)
        return;
    cout << p->data_ << " ";
    preOrder_(p->left_);
    preOrder_(p->right_);
}
```
```C++ [中序遍历]
void inOrder() {
    inOrder_(root_);
}
void inOrder_(Node* p) {
    if (!p)
        return;
    inOrder_(p->left_);
    cout << p->data_ << " ";
    inOrder_(p->right_);
}
```
```C++ [后序遍历]
void postOrder() {
    postOrder_(root_);
}
void postOrder_(Node* p) {
    if (!p)
        return;
    postOrder_(p->left_);
    postOrder_(p->right_);
    cout << p->data_ << " ";
}
```
```C++ [层序遍历]
// 获取当前树的层数
int getLevel() {
    return getLevel_(root_);
}
// 获取树总节点个数
int getNum() {
    return getNum_(root_);
}
void levelOrder() {
    int level = getLevel();
    for (int i = 0; i < level; ++i) {
        levelOrder_(root_, i);
    }
}

int getLevel_(Node* p) {
    if (!p)
        return 0;
    int left = getLevel_(p->left_);
    int right = getLevel_(p->right_);
    return left > right ? left + 1 : right + 1;
}
int getNum_(Node* p) {
    if (!p)
        return 0;
    int left = getNum_(p->left_);
    int right = getNum_(p->right_);
    return left + right + 1;
}
void levelOrder_(Node* p, int l) {
    if (!p)
        return;
    // 当记录层l归0说明到达该层
    if (!l) {
        cout << p->data_ << " ";
        return;
    }
    levelOrder_(p->left_,l - 1);
    levelOrder_(p->right_,l - 1);
}
```
:::
