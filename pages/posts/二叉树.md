---
layout: post
title: 二叉树
date: 2025-08-27 17:01:08
categories: 算法
tags:
  - 算法
  - 二叉树
  - 编程
  - C++
cover: 'https://pic.akorin.icu/20250831134230877.webp'
codeHeightLimit: 500
toc: true
time_warning: true
end: true
updated: '2025-08-30 18:26:33'
---

# 二叉树
二叉树（Binary Tree）是一种 树形数据结构，它的每个节点最多有 两个子节点，通常称为：
- 左子节点（Left Child）
- 右子节点（Right Child）
所以，二叉树的每个节点最多分叉 2 个，而不是任意多个。

<!-- more -->

## 各种节点

- **根节点**：二叉树最顶端的节点，没有父节点。
- **父节点**：有子节点的节点，直接连接其子节点。
- **子节点**：由父节点直接指向的节点。
- **兄弟节点**：拥有同一个父节点的节点。
- **叶子节点**：没有任何子节点的节点。
- **内部节点**：既不是根节点也不是叶子节点的节点。
- **左孩子节点**：父节点的左边分支上的节点。
- **右孩子节点**：父节点的右边分支上的节点。
- **祖先节点**：从根节点到该节点路径上的所有节点。
- **后代节点**：以某节点为根的子树中的所有节点。

## 搜索二叉树

对于二叉树上的每一个节点，如果满足：

**左孩子的值 < 父节点的值 < 右孩子的值**

则称为 **搜索二叉树(BST, Binary Search Tree)**

推广到大范围：

**左孩子的所有值都小于父节点，右孩子的所有值都大于父节点**

第 $L$ 层的孩子节点 $n$ 个数公式如下：

$$
n = 2^{(L-1)}
$$

### 插入节点

1. 从根节点开始，比较插入值 `val` 与当前节点值 `cur->val`
2. 如果 `val < cur->val`，进入左子树；如果 `val > cur->val`，进入右子树
3. 递归或循环找到空位置，插入新节点
4. 保持 BST 性质不变

### 删除节点

1. **节点没有孩子（叶子）**
   - 直接删除节点即可
2. **节点只有一个孩子**
   - 用孩子顶替节点位置
   - 如果删除的是根节点，更新 root 指针
3. **节点有两个孩子**
   - 找右子树最小节点（也叫做 **后继节点** ）（或左子树最大节点（也叫做 **前驱节点** ））
   - 用该节点值覆盖要删除节点
   - 删除右子树最小节点（或左子树最大节点），其孩子数 ≤ 1

### 寻找节点

1. 从根节点开始，设当前节点为 `cur`
2. 比较目标值 `key` 与 `cur->val`
   - 如果 `key == cur->val` → 找到节点，返回
   - 如果 `key < cur->val` → 进入左子树继续查找
   - 如果 `key > cur->val` → 进入右子树继续查找
3. 若节点为空 (`nullptr`) → 查找失败，节点不存在

```C++ [非递归实现增删查]
template<typename T, typename Comp = less<T>>
class BSTree {
public:
    BSTree(Comp camp = Comp()) : root_(nullptr),comp_(camp) {}

public:
    // 避免不必要的拷贝
    bool insert(const T& val) {
        if (root_ == nullptr) {
            root_ = new Node(val);
            return true;
        }
        Node* parent = nullptr;
        Node* cur = root_;

        while (cur) {
            parent = cur;
            if (comp_(val, cur->data_)) {
                cur = cur->left_;
            } else if (comp_(cur->data_, val)) {
                cur = cur->right_;
            } else {
                // 不计入重复数
                return false;
            }
        }
        cur = new Node(val);
        if (comp_(val, parent->data_)) {
            parent->left_ = cur;
        } else {
            parent->right_ = cur;
        }
        return true;
    }
    bool del(const T& val) {
        if (!root_) {
            return false;
        }
        Node* cur = root_;
        Node* parent = nullptr;

        // 移动cur
        while (cur) {
            if (comp_(val, cur->data_)) {
                parent = cur;
                cur = cur->left_;
            } else if (comp_(cur->data_, val)) {
                parent = cur;
                cur = cur->right_;
            } else {
                // 找到了/没找到
                break;
            }
        }
        // 没找到
        if (!cur)
            return false;

        // 先处理情况3：
        // root有两个孩子节点
        // 处理完成后自动变成处理情况1/2
        if (cur->left_ && cur->right_) {
            Node* p = cur;
            parent = cur;
            cur = cur->left_;
            while (cur->right_) {
                // 在这里找前驱，也可以找后继
                parent = cur;
                cur = cur->right_;
            }
            // 此时出来后 cur 即为最大的左子树值
            // cur 也是前驱节点
            p->data_ = cur->data_;
        }

        // 此时处理情况1/2
        // 要判断处理此时前驱节点的孩子
        // 此时有可能是删的只有一个孩子的头节点
        Node* child = cur->left_ ? cur->left_ : cur->right_;
        if (!parent) {
            // 删只有一个孩子的头节点
            root_ = child;
        } else if (parent->left_ == cur) {
            parent->left_ = child;
        } else {
            parent->right_ = child;
        }
        delete cur;
        return true;
    }
    bool find(const T& val) {
        Node* cur = root_;
        while (cur) {
            if (comp_(val, cur->data_)) {
                cur = cur->left_;
            } else if (comp_(cur->data_, val)) {
                cur = cur->right_;
            } else {
                // 不计入重复数
                return true;
            }
        }
        return false;
    }

private:
    struct Node {
        Node(T data = T()) :
            data_(data), left_(nullptr), right_(nullptr) {}
        T data_;
        Node* left_;
        Node* right_;
    };

private:
    Comp comp_;
    Node* root_;
};
```

### 递归的前中后层序遍历

- V：根节点
- L：左孩子节点
- R：右孩子节点

**不管是什么遍历都是L出现在R之前。**

访问头节点的次序决定了不同的访问方式，因此就有：

- VLR：前序遍历
- LVR：中序遍历
- LRV：后序遍历

访问根节点的孩子后，当前的孩子节点又作为根节点来访问孩子。

对于BST树，由于排列方式都是 左孩子<根节点<右孩子。因此 **BST树中序遍历后就是一个从小到大升序的数列。**

:::code-group
```C++ [前序遍历]
void preOrder() {
    preOrder_(root_);
}
void preOrder_(Node* p) {
    if (!p)
        return;
    cout << p->data_ << " ";
    preOrder_(p->left_);
    preOrder_(p->right_);
}
```
```C++ [中序遍历]
void inOrder() {
    inOrder_(root_);
}
void inOrder_(Node* p) {
    if (!p)
        return;
    inOrder_(p->left_);
    cout << p->data_ << " ";
    inOrder_(p->right_);
}
```
```C++ [后序遍历]
void postOrder() {
    postOrder_(root_);
}
void postOrder_(Node* p) {
    if (!p)
        return;
    postOrder_(p->left_);
    postOrder_(p->right_);
    cout << p->data_ << " ";
}
```
```C++ [层序遍历]
// 获取当前树的层数
int getLevel() {
    return getLevel_(root_);
}
// 获取树总节点个数
int getNum() {
    return getNum_(root_);
}
void levelOrder() {
    int level = getLevel();
    for (int i = 0; i < level; ++i) {
        levelOrder_(root_, i);
    }
}

int getLevel_(Node* p) {
    if (!p)
        return 0;
    int left = getLevel_(p->left_);
    int right = getLevel_(p->right_);
    return left > right ? left + 1 : right + 1;
}
int getNum_(Node* p) {
    if (!p)
        return 0;
    int left = getNum_(p->left_);
    int right = getNum_(p->right_);
    return left + right + 1;
}
void levelOrder_(Node* p, int l) {
    if (!p)
        return;
    // 当记录层l归0说明到达该层
    if (!l) {
        cout << p->data_ << " ";
        return;
    }
    levelOrder_(p->left_,l - 1);
    levelOrder_(p->right_,l - 1);
}
```
:::

### 递归插入

1. 像查询一样，要插入的值与头节点做比较，小的往左大的往右走。
2. 进入下一层，直至为 `nullptr`。
3. 到达 `nullptr` 层时说明找到了要插入的位置，那就要让上一层连接到该层。
4. 返回该层的节点。

```C++
void insert(const T& val) {
    // 插入第一个元素的时候没有对root进行更新
    root_ = insert_(root_,val);
}

Node* insert_(Node* p, const T &val) {
    // 出口:找到了要插入的位置
    if (!p) {
        return new Node(val);
    }
    // 避免重复插入
    if (p->data_ == val) {
        return p;
    } else if (comp_(val, p->data_)) {
        p->left_ = insert_(p->left_, val);
        return p;
    } else {
        p->right_ = insert_(p->right_, val);
        return p;
    }
}
```

### 递归搜索

1. 搜索就只需要找到值即可。
2. 没有新插入的值，不用让上一层连接到该层，找到就返回节点即可。

```C++
Node* find(const T& val) {
    return find_(root_, val);
}

Node* find_(Node* p, const T& val) {
    if (!p) {
        return nullptr;
    }
    if (p->data_ == val) {
        return p;
    } else if (comp_(val, p->data_)) {
        return  find_(p->left_, val);
    } else {
        return  find_(p->right_, val);
    }
}
```

### 递归删除

1. 由于要删除节点，孩子要变化，因此需要将变化的孩子连接到上一层。
2. 找到要删除的节点就要判断是否是情况三（有两个孩子）。
3. 如果是情况3就需要找到前驱/后继节点并删除，删除前驱/后继就直接转移到了删除情况1/2。
4. 因为每一层都会连接对应的孩子，因此如果是情况1/2，删除前驱/后继节点后，返回其孩子的节点。

```C++
void remove(const T& val) {
    root_ = remove_(root_, val);
}

Node* remove_(Node* p, const T& val) {
    if (!p) {
        return nullptr;
    }
    if (p->data_ == val) {
        // 删除操作，返回删除过后新的孩子
        // 情况3
        if (p->left_ && p->right_) {
            Node* pre = p->left_;
            while (pre->right_) {
                pre = pre->right_;
            }
            // 找到前驱，前驱至多有一个孩子
            p->data_ = pre->data_;
            // 删除前驱节点，到达情况1/2那一层
            p->left_ = remove_(p->left_, pre->data_);
            return p;
        }
        // 情况1/2（只有一个孩子或无孩子）
        Node* q = p->left_ ? p->left_ : p->right_;
        delete p;
        return q;
    } else if (comp_(val, p->data_)) {
        p->left_ = remove_(p->left_, val);
    } else {
        p->right_ = remove_(p->right_, val);
    }
    return p;
}
```

### 非递归的前中后层序遍历

遍历不是说只用递归就万事大吉了，非递归形式也是很有必要的。递归有个缺点就是占用栈空间太大了，而栈的容量小，容易爆栈。在工程上一般还是非递归的代码较多。

非递归下，需要借助其它的数据结构来存储。比如说 **栈** 。

根据栈的先入后出原则， **先要遍历的后入栈**。

**编程的固定模式：**
1. 深度遍历：使用 **栈** 结构。
2. 广度遍历：使用 **队列** 结构。

#### 前序遍历VLR

由于右孩子最后才访问，需要把右孩子先保存着，后面再访问。

1. 先把右孩子压进栈。
2. 再压左孩子，左孩子再出栈（如果有）。
3. 此时把左孩子作为根节点，重复1 2步骤。

```C++
void npreOrder() {
    cout << "非递归前序遍历" << endl;
    if (!root_)
        return;
    stack<Node*> s;
    s.push(root_);
    while (!s.empty()) {
        Node* top = s.top();
        s.pop();
        // 处理v
        cout << top->data_ << " ";
        if (top->right_)
            s.push(top->right_); // R
        if (top->left_)
            s.push(top->left_); // L
    }
    cout << endl;
}
```

#### 中序遍历LVR

这里要先访问左孩子，则需要先存入所有的左孩子。

1. 要先保存所有的左孩子直至 `nullptr` 。
2. 然后弹栈1个节点。此时出栈的节点就是父节点，即V。
3. 用一个指针 `cur` 指向该父节点的右孩子，在下一次循环中判断是否存在，若存在返回到步骤1。
4. 当栈空且指针为 `nullptr` 时结束。

```C++
void ninOrder() {
    if (!root_)
        return;
    cout << "非递归中序遍历" << endl;
    stack<Node*> s;
    Node* cur = root_;
    while (!s.empty() || cur) {
        // 先存入所有左孩子
        while (cur) {
            s.push(cur);
            cur = cur->left_;
        }
        Node* top = s.top();
        s.pop();
        cout << top->data_ << " ";
        cur = top->right_;
    }
    cout << endl;
}
```

#### 后序遍历LRV

- 后序遍历有两种思路，一个是先反向得 **VRL**，然后再反向输出就得到后续遍历，此时需要 **两个栈** 来存储。
    1. 准备两个栈 `s1` 和 `s2`。
    2. 按照前序遍历那样，左孩子先入栈 `s1` 再压右孩子。
    3. 右孩子出栈时不要打印，压入到另一个栈 `s2` 。接着处理右孩子的左右孩子。
    4. 遍历完毕后， `s2` 存入的顺序就是 **VRL** ，此时 `s2` 再全部弹出，其输出的顺序就是 **LRV** 了，满足后序遍历的条件。


- 还有一种就是延续中序遍历得思想，进入右孩子时先进行一个判断，先判断这个右孩子是否已经进去过了，如果进去过了说明已经轮到该父节点弹栈了。
    1. 先把所有左孩子压入栈，和中序遍历一样。
    2. 此时弹出一个节点，该节点就是父节点。
    3. 判断是否有右孩子，若有就将当前指针 `cur` 指向其右孩子，然后重复步骤1。
    4. 若没有说明到头了该弹出父节点并输出， 更新 `pre` 指针到当前弹出的节点，返回到步骤3。
    5. 在循环中若上一次弹出的节点就是当前父节点的右孩子，说明右孩子已遍历过，返回到步骤4。

    :::info 要如何判断是否进入过右孩子呢？

    用一个指针指向上一次弹过栈的节点，判断右孩子是否是上一次弹过的节点，如果是就说明进去过了。

    :::

:::code-group
```C++ [双栈反序遍历思想]
void n1postOrder() {
    if (!root_)
        return;
    stack<Node*> s1;
    stack<Node*> s2;
    s1.push(root_);
    while (!s1.empty()) {
        Node* top = s1.top();
        s1.pop();
        // 出栈就放入另一个栈
        s2.push(top);
        if (top->left_) {
            s1.push(top->left_);
        }
        if (top->right_) {
            s1.push(top->right_);
        }
    }
    while (!s2.empty()) {
        cout << s2.top()->data_ << " ";
        s2.pop();
    }
    cout << endl;
}
```
```C++ [延续中序遍历思想]
void npostOrder() {
    if (!root_)
        return;
    Node* cur = root_;
    Node* pre = nullptr;
    stack<Node*> s;
    while (cur || !s.empty()) {
        while (cur) {
            s.push(cur);
            cur = cur->left_;
        }
        // 左孩子装完，此时栈顶是父节点但是不弹栈
        Node* top = s.top();
        // 观察当前的父节点
        // 需要判断右孩子是否弹出过栈
        if (top->right_ && top->right_ != pre) {
            cur = top->right_;
        } else { // 此时为父节点弹栈输出
            cout << top->data_ << " ";
            s.pop();
            // 此时需返程了，记录弹出了的节点
            pre = top;
        }
    }
    cout << endl;
}
```
:::

#### 层序遍历

层序遍历也叫做广度遍历，每一层的孩子都遍历之后再访问下一层。此时可以使用 **队列** ，队列的先进先出原则正好符合需要。先入队的父节点出队，其孩子节点再入队，如此循环往复。

1. 所有这一层的父节点先入队。
2. 所有的父节点出队判断其孩子节点是否存在，若存在则所有父节点的所有孩子节点入队。
3. 重复步骤1，2。

```C++
void nlevelOrder() {
    if (!root_)
        return;
    queue<Node*> q;
    Node* cur = root_;
    q.push(cur);
    while (cur) {
        Node* front = q.front();
        q.pop();
        cout << front->data_ << " ";
        if (front->left_)
            q.push(front->left_);
        if (front->right_)
            q.push(front->right_);
    }
    cout << endl;
}
```
