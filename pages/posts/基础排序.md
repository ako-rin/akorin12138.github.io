---
title: 基础排序
date: 2025-08-18
updated: 2025-08-18
categories: 笔记
tags:
  - 笔记
  - 编程
  - C++
codeHeightLimit: 750
cover: 'https://pic.akorin.icu/20250818110658665.webp'
end: true
time_warning: true
---

一大堆排序，简要记录中心思想。

<!-- more -->

## 冒泡排序

两个指针一前一后进行比较，前者数较大就两者交换（顺序），每次移动都是两个指针一起移动，这样每一趟都会把当前的较大数移动到后面，移动完毕后再从头开始比较，但是不用管已经排好的数。

![](https://pic.akorin.icu/20250818111128548.webp)

- 平均复杂度O(n^2)，最好情况O(n)
- 空间复杂度O(1)
- 稳定算法

```C++
// O(n) ~ O(n^2)    平均O(n^2)
void BubbleSort(int arr[], int size) {
    // 最后一趟就一个数不用再处理了
    for (auto i = 0; i < size - 1; ++i) {
        // 如果一次交换都没有则该数列已排好不用再操作
        bool flag = false;
        // 每一趟都不用再处理排序好的数
        for (auto j = 0; j < size - 1 - i; ++j) {
            if (arr[j] > arr[j + 1]) {
                flag = true;
                arr[j] += arr[j + 1];
                arr[j + 1] = arr[j] - arr[j + 1];
                arr[j] -= arr[j + 1];
            }
        }
        if (!flag) {
            return;
        }
    }
}
```

> 稳定性：在原始的数据序列中，**相同元素** 经过排序后，它们的前后顺序并没有改变，就叫做稳定的，否则就是不稳定排序。

## 选择排序

也是双指针，第二个指针与第一个指针的数进行比较，较小的数放前面。与冒泡排序对比，**交换次数少很多**，效率稍微高一点。

选择排序是找到最小的数再交换位置，而不是后者比前者小就交换。如果是后者比前者小就交换，那样交换次数就会很大，最后消耗的时间甚至比冒泡还要长。


- 复杂度O(n^2)
- 空间复杂度O(1)
- 不稳定算法

```C++
void ChoiceSort(int arr[], int size) {
    for (auto i = 0; i < size - 1; ++i) {
        int min = arr[i];
        int k = i;
        for (auto j = i + 1; j < size; ++j) {
            if (min > arr[j]) {
                min = arr[j];
                k = j;
            }
        }
        // 避免无用的交换
        if (k != i) {
            int temp = arr[k];
            arr[k] = arr[i];
            arr[i] = temp;
        }
    }
}
```

## 插入排序

插入排序认为前面一段序列是有序的，将当前的数插入到前面的有序数列中。

**如果数据趋于有序，那么插入排序是所有排序算法中，效率最高的算法。** 在基础排序算法的效率中， 插入排序 > 冒泡排序&选择排序。

插入排序不仅仅 **没有交换**， 比较次数也少。

- 平均复杂度O(n^1.3)，O(n)~O(n^2)
- 空间复杂度O(1)
- 稳定算法

```C++
void InsertSort(int arr[], int size) {
    for (auto i = 1; i < size; ++i) {
        int val = arr[i];
        auto j = i - 1;
        for (; j >= 0; --j) {
            if (val >= arr[j])
                break;
            arr[j + 1] = arr[j];
        }
        arr[j + 1] = val;
    }
}
```

实际上这就是 **数组** 这类有序数据结构的插入算法，对比链表这种数据结构，其插入的效率较低。

## 希尔排序

希尔排序就是对插入排序的优化。希尔排序对数组进行分组插入排序，部分组有序后再分组插入排序，直到间隔为0。希尔排序先全局对数据进行趋于有序的优化。

- 复杂度O(n)~O(n^2)
- 空间复杂度O(1)
- 稳定算法

```C++
// 希尔排序 - 只需要记住插入排序就行了
void ShellSort(int arr[], int size) {
    for (int gap = size / 2; gap > 0; gap /= 2) {
        // 这里++i不是i+=gap是为了遍历分了之后的所有组
        for (auto i = gap; i < size; ++i) {
            int val = arr[i];
            auto j = i - gap;
            for (; j >= 0; j -= gap) {
                if (val >= arr[j])
                    break;
                arr[j + gap] = arr[j];
            }
            arr[j + gap] = val;
        }
    }
    
}
```

写希尔排序之前，先写好插入排序，再在这外层套一个间隔，内部排序改成对应间隔，不用死记硬背希尔排序。

## 四种基础排序性能对比：
使用一万个数据的数组，分别使用冒泡排序、选择排序、插入排序和希尔排序，并计算所用时间。
| 算法类型 | 时间 |
| -------- | ---- |
| 冒泡排序 |21.0031s|
| 选择排序 |2.71733s|
| 插入排序 |2.33287s|
| 希尔排序 |0.016249s|