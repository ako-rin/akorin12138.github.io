---
title: 高级排序
date: 2025-08-18
updated: 2025-08-18
categories: 笔记
tags:
  - 笔记
  - 编程
  - C++
codeHeightLimit: 750
cover: https://pic.akorin.icu/20250818181857138.webp'
end: false
time_warning: false
---

## 快速排序

选取一个基准数，小于基准数的元素都调整到基准数的左边，把大于基准数的元素都调整到基准数的右边，然后对基准数左边和右边的序列继续进行这样的操作，直到正逢序列变有序。
比较像二分思想。

处理数组的递归问题，需要引入头和尾。

- 复杂度 O(n)*O(logn) = O(nlogn)，最坏时间复杂度O(n^2)（在有序数组中使用快排）
- 空间复杂度O(logn)：主要取决于递归时的深度，最坏空间复杂度O(n)（在有序数组中使用快排）
- 不稳定算法

```C++
// 一次快排算法
int Paration(int arr[], int l, int r) {
    int val = arr[l];
    while (l < r) {
        // l < r防止直接退出导致没有遍历比较其它位置
        while (l < r && arr[r]> val) {
            --r;
        }
        if (l < r) {
            arr[l] = arr[r];
            ++l;
        }
        while (l < r && arr[l] < val) {
            ++l;
        }
        if (l < r) {
            arr[r] = arr[l];
            --r;
        }
    }
    arr[l] = val;
    return l;
}
void QuickSort(int arr[], int begin, int end) {
    if (begin >= end)
        return;
    // 在[begin,end]区间做一次快排分割处理，
    // 并获取排列好的正确位置
    int pos = Paration(arr, begin, end);
    QuickSort(arr, begin, pos - 1);
    QuickSort(arr, pos + 1, end);
}
```

### 快速排序优化

对于已经有序的数列来说，再采用快排其时间复杂度及空间复杂度都很大。

1. 随着快排的执行，数据越来越有序，再一定范围内可以用插入排序代替快速排序。
```C++
void QuickSort(int arr[], int begin, int end) {
    if (begin >= end)
        return;
    // 优化一：当[begin,end]序列的元素个数小到指定数量，采用插入排序
    if (begin - end <= 50) {    // [!code ++]
        InsertSort(arr, begin, end);    // [!code ++]
        return; // [!code ++]
    }   // [!code ++]
    // 在[begin,end]区间做一次快排分割处理，
    // 并获取排列好的正确位置
    int pos = Paration(arr, begin, end);
    QuickSort(arr, begin, pos - 1);
    QuickSort(arr, pos + 1, end);
}
```

2. 选择基准数时，采用 **“三数取中法”** ：
    - `mid = (L + R) / 2`
    - `L`
    - `R`

    这三个位置的序列中的数值在中间的数，作为基准数。
3. 随机数法，随机在数列中取基准数，但是不如三数取中法靠谱。

## 归并排序

归-递归，并-合并。递到只有一个元素时就到头了，需要额外的内存空间把两个小段有序的序列合并成一个大段有序的序列。
归并排序也采用”分治思想“。

- 复杂度 O(n)*O(logn) = O(nlogn)，每层合并数据n个，层高是logn。
- 空间复杂度O(logn)+O(n) = O(n)：每一层开辟的空间占大头，取O(n)
- 稳定算法（在排序过程中，两数相等时先放左边的数，否则就是不稳定算法）

```C++
    // 归并过程函数
void Merge(int arr[], int l, int m, int r) {
    int* p = new int[r - l + 1];
    int idx = 0;
    int i = l;   // 左孩子第一个元素位置
    int j = m + 1;   // 右孩子第一个元素位置
    while (i <= m && j <= r) {
        if (arr[i] <= arr[j]) {
            p[idx++] = arr[i++];
        } else {
            p[idx++] = arr[j++];
        }
    }
    while (i <= m) {
        p[idx++] = arr[i++];
    }
    while (j <= r) {
        p[idx++] = arr[j++];
    }
    // 再把合并好的大段有序结果拷贝进原始arr的[l,r]区间内
    for (i = l, j = 0; i <= r; ++i, ++j) {
        arr[i] = p[j];
    }
    delete[] p;
    p = nullptr;
}
void MergeSort(int arr[], int begin, int end) {
    if (begin >= end) {
        return;
    }
    // 先递后归
    int mid = (begin + end) / 2;
    MergeSort(arr, begin, mid);
    MergeSort(arr, mid + 1, end);
    // 归回来就开始排序
    Merge(arr, begin, mid, end);
    // 排完序结束回到上一层继续处理
}
```

## 堆排序

### 二叉堆

二叉堆就是一颗完全 **完全二叉树** ， 分为两种典型的堆： **大根堆** 和 **小根堆** 。

:::info
完全二叉树的最后一层的叶子节点都是靠左排列的。
:::

逻辑上是一颗完全二叉树，存储方式上用数组进行存储的。

:::tip 数组与二叉树的关系

i为数组的下标，逻辑上对应的二叉树位置为：
- 左孩子： `2 * i + 1`
- 右孩子： `2 * i + 2`
![](https://pic.akorin.icu/20250819150044468.webp)
:::

满足 `0 <= i <= (n - 1) / 2` ，n代表最后一个元素的下标。 
- 如果 `arr[i] <= arr[2 * i + 1] && arr[i] <= arr[2 * i + 2]` ，就是小根堆
- 如果 `arr[i] > = arr[2 * i + 1] && arr[i] >= arr[2 * i + 2]` ，就是小根堆