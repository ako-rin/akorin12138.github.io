---
title: 高级排序
date: 2025-08-18
updated: 2025-08-20
categories: 笔记
tags:
  - 笔记
  - 编程
  - C++
codeHeightLimit: 750
cover: 'https://pic.akorin.icu/20250819152244337.webp'
end: true
time_warning: false
---

简要记录一系列高级排序的中心思想。

<!-- more -->

## 快速排序

选取一个基准数，小于基准数的元素都调整到基准数的左边，把大于基准数的元素都调整到基准数的右边，然后对基准数左边和右边的序列继续进行这样的操作，直到正逢序列变有序。
比较像二分思想。

处理数组的递归问题，需要引入头和尾。

- 时间复杂度 O(n)*O(logn) = O(nlogn)，最坏时间复杂度O(n^2)（在有序数组中使用快排）
- 空间复杂度O(logn)：主要取决于递归时的深度，最坏空间复杂度O(n)（在有序数组中使用快排）
- 不稳定算法

```C++
// 一次快排算法
int Paration(int arr[], int l, int r) {
    int val = arr[l];
    while (l < r) {
        // l < r防止直接退出导致没有遍历比较其它位置
        while (l < r && arr[r]> val) {
            --r;
        }
        if (l < r) {
            arr[l] = arr[r];
            ++l;
        }
        while (l < r && arr[l] < val) {
            ++l;
        }
        if (l < r) {
            arr[r] = arr[l];
            --r;
        }
    }
    arr[l] = val;
    return l;
}
void QuickSort(int arr[], int begin, int end) {
    if (begin >= end)
        return;
    // 在[begin,end]区间做一次快排分割处理，
    // 并获取排列好的正确位置
    int pos = Paration(arr, begin, end);
    QuickSort(arr, begin, pos - 1);
    QuickSort(arr, pos + 1, end);
}
```

### 快速排序优化

对于已经有序的数列来说，再采用快排其时间复杂度及空间复杂度都很大。

1. 随着快排的执行，数据越来越有序，再一定范围内可以用插入排序代替快速排序。
```C++
void QuickSort(int arr[], int begin, int end) {
    if (begin >= end)
        return;
    // 优化一：当[begin,end]序列的元素个数小到指定数量，采用插入排序
    if (begin - end <= 50) {    // [!code ++]
        InsertSort(arr, begin, end);    // [!code ++]
        return; // [!code ++]
    }   // [!code ++]
    // 在[begin,end]区间做一次快排分割处理，
    // 并获取排列好的正确位置
    int pos = Paration(arr, begin, end);
    QuickSort(arr, begin, pos - 1);
    QuickSort(arr, pos + 1, end);
}
```

2. 选择基准数时，采用 **“三数取中法”** ：
    - `mid = (L + R) / 2`
    - `L`
    - `R`

    这三个位置的序列中的数值在中间的数，作为基准数。
3. 随机数法，随机在数列中取基准数，但是不如三数取中法靠谱。

## 归并排序

归-递归，并-合并。递到只有一个元素时就到头了，需要额外的内存空间把两个小段有序的序列合并成一个大段有序的序列。
归并排序也采用“分治思想”。

- 时间复杂度 O(n)*O(logn) = O(nlogn)，每层合并数据n个，层高是logn。
- 空间复杂度O(logn)+O(n) = O(n)：每一层开辟的空间占大头，取O(n)
- 稳定算法（在排序过程中，两数相等时先放左边的数，否则就是不稳定算法）

```C++
    // 归并过程函数
void Merge(int arr[], int l, int m, int r) {
    int* p = new int[r - l + 1];
    int idx = 0;
    int i = l;   // 左孩子第一个元素位置
    int j = m + 1;   // 右孩子第一个元素位置
    while (i <= m && j <= r) {
        if (arr[i] <= arr[j]) {
            p[idx++] = arr[i++];
        } else {
            p[idx++] = arr[j++];
        }
    }
    while (i <= m) {
        p[idx++] = arr[i++];
    }
    while (j <= r) {
        p[idx++] = arr[j++];
    }
    // 再把合并好的大段有序结果拷贝进原始arr的[l,r]区间内
    for (i = l, j = 0; i <= r; ++i, ++j) {
        arr[i] = p[j];
    }
    delete[] p;
    p = nullptr;
}
void MergeSort(int arr[], int begin, int end) {
    if (begin >= end) {
        return;
    }
    // 先递后归
    int mid = (begin + end) / 2;
    MergeSort(arr, begin, mid);
    MergeSort(arr, mid + 1, end);
    // 归回来就开始排序
    Merge(arr, begin, mid, end);
    // 排完序结束回到上一层继续处理
}
```

## 堆排序

### 二叉堆

二叉堆就是一颗 **完全二叉树** ， 分为两种典型的堆： **大根堆** 和 **小根堆** 。

:::info 完全二叉树的充分条件

完全二叉树的最后一层的叶子节点都是靠左排列的，且除了最后一层的节点都是满的，最后一层可以不是满的。

:::

逻辑上是一颗完全二叉树，存储方式上用数组进行存储的。

:::tip 数组与二叉树的关系

`i` 为数组的下标，逻辑上对应的二叉树位置为：
- 左孩子： `2 * i + 1`
- 右孩子： `2 * i + 2`
![](https://pic.akorin.icu/20250819150044468.webp)
:::

满足 `0 <= i <= (n - 1) / 2` ，`i` 代表数组的下标， `n` 代表最后一个元素的下标。
- 如果 `arr[i] <= arr[2 * i + 1] && arr[i] <= arr[2 * i + 2]` ，就是小根堆  
- 如果 `arr[i] > = arr[2 * i + 1] && arr[i] >= arr[2 * i + 2]` ，就是大根堆

换人话来说就是：根节点（**堆顶**）和两个孩子节点值的大小关系，根节点的值比两个孩子的值大就是 **大根堆**， 比两个孩子的值小就是 **小根堆**。

获取父节点的公式：
- `(i - 1) / 2`  

这里取 `i- 1 `是确保无论最后一个元素是左节点还是右节点都可以找到其父节点。

:::info 叶子节点

叶子节点：**既没有左孩子也没有右孩子**，在树的图形上就是“树枝的尽头”，没有子节点的节点。  

:::

由于堆的性质，叶子节点没有子节点，也就不需要进行比较。需要找到第一个非叶子节点来进行比较和操作。

:::tip 什么是第一个非叶子节点

1. 建堆时要**保证子树先变成堆**，再逐层往上合并。因此，堆都是 **从堆底往顶上看** ，那么第一个非叶子节点就是从堆底开始找。  
2. 第一个非叶子节点也就变成了 **第一个要处理的有孩子的父节点**。  
3. 要找到第一个非叶子节点，可以从最后的元素计算其父节点的位置：  
    - `(n - 1) / 2` 或
    - `size / 2` 其中 `size` 为队列元素个数

:::


### 入堆

入堆即将某个数加入到堆中。入堆步骤（以大根堆为例）：
1. 将要入堆的数据放入数组末尾，并计算对应树中的位置。
2. 计算它的父节点位置，并与父节点进行比较，若大于父节点则与父节点进行位置交换。
3. 重复上述1、2步骤直至无父节点（到达堆顶），或满足大根堆的要求（父节点大于孩子节点）。

上述过程叫做 **上浮** 。在实际应用中，为了效率，上浮过程中不是交换位置，而是只操作父节点往下赋值，直到入堆节点上浮到对应位置，在该位置再赋值要入堆的元素。
![](https://pic.akorin.icu/20250819175059577.webp)

### 出堆

出堆 **只能出堆顶元素** 。出堆步骤（以大根堆为例）：
1. 直接将最后一个元素放到堆顶，然后开始 **下沉** 操作。
2. 此时与其孩子节点做比较，并将较大的孩子与其交换。
3. 重复上述步骤2，直到没有孩子（超出第一个非叶子节点 `i > (n - 1) / 2` ）或者其孩子节点均小于它。

上述过程是 **下沉** ，将堆顶的元素往下放。与上浮相同，为了效率，下沉过程中只操作子节点往上赋值，直到堆顶元素下沉到对应位置再赋最后一个节点元素的值。
![](https://pic.akorin.icu/20250819192544736.webp)

### 入堆出堆的复杂度

- 时间复杂度 O(logn)：即为树的高度。
- 空间复杂度 O(1)；这两个操作都不用占用额外的空间。

### 基于大根堆和小根堆的优先级队列

优先级队列根据元素的 **优先级** 来决定谁先出来，而不单纯看谁先进入。而普通队列（FIFO）是先进先出。
- 小根堆-> 每次取出最小值（优先级最高的元素）。
- 大根堆-> 每次取出最大值（优先级最高的元素）。

用代码实现堆的排序时，可以先实现优先级队列（即实现堆的出堆、入堆、是否空等操作）。

```C++
// 默认构造大根堆
class PriorityQueue {
public:
    using Cmp = function<bool(int, int)>;
    PriorityQueue(int size = 10, Cmp f = greater<int>()) :
        que_(new int[size]), size_(0), cap_(size), cmp_(f) {}

    ~PriorityQueue() {
        delete[] que_;
        que_ = nullptr;
    }
    void push(int data) {
        if (size_ == cap_) {
            int* p = new int[2 * cap_];
            memcpy(p, que_, sizeof(int) * size_);
            delete[] que_;
            que_ = p;
            cap_ *= 2;
        }
        siftUp(data);
        ++size_;
    }
    int pop() {
        if (empty())
            throw "No data. Fuck u!";
        int data = que_[0];
        siftDown();
        --size_;
        return data;
    }
    int top() {
        return que_[0];
    }
    bool empty() {
        return !size_;
    }
    bool full() {
        return size_ == cap_;
    }
private:
    int* que_;
    int size_;   // 有效数据个数
    int cap_;    // 堆内存大小
    Cmp cmp_;    // 比较函数
    void siftUp(int data) {
        // 大根堆比较，直接插入进堆尾
        que_[size_] = data;
        // 堆尾和父节点比较
        int father = (size_ - 1) / 2;
        // 记录入堆节点位置
        int pos = size_;
        // 跳出条件：父节点大于子节点或到达堆顶
        while (cmp_(data, que_[father]) && father != pos) {
            que_[pos] = que_[father];
            pos = father;
            father = (pos - 1) / 2;
        }
        // 到达对应位置跳出
        que_[pos] = data;
    }
    void siftDown() {
        int val = que_[size_ - 1];
        int pos = 0;
        while (pos < size_ / 2) {
            int child = (2 * pos) + 1;
            if (child + 1 < size_ && cmp_(que_[child + 1], que_[child])) {
                child = child + 1;
            }
            if (cmp_(que_[child], val)) {
                que_[pos] = que_[child];
                pos = child;
            } else {
                break;
            }
        }
        que_[pos] = val;
    }
};

```

### 堆排序

完成了优先级序列就可以写堆排序了。
1. 从第一个非叶子节点到0号位元素进行下沉调整， **保证每一个子树都成堆** （满足大根堆小根堆性质）。
2. 此时已构建起正确的堆结构，只是一个 **优先级序列** 。逻辑上是 **完全二叉树** ，但是在 **物理结构** （数组）上还是乱序的，此时不断把堆顶固定到末尾即可。
3. 将堆顶元素与末尾元素交换并下沉调整，但把最后的元素（原来的堆顶）当作不存在。
4. 从第二趟开始，每次少一个元素。

```C++
// 堆的下沉调整
void siftDown(int arr[], int i, int size) {
    int val = arr[i];
    while (i < size / 2) {
        int child = i * 2 + 1;
        // 右孩子存在且右孩子更大
        if (child + 1 < size && arr[child] < arr[child + 1]) {
            child = child + 1;
        }
        // 孩子节点更大就下沉
        if (arr[child] > val) {
            // 把大的放上去
            arr[i] = arr[child];
            i = child;
        } else {
            break;
        }
    }
    arr[i] = val;
}
void HeapSort(int arr[], int size) {
    // 1. 从第一个非叶子节点到0号位元素进行下沉调整
    for (auto i = size / 2 - 1; i >= 0; --i) {
        siftDown(arr, i, size);
    }
    // 2. 将堆顶元素与末尾交换并下沉调整
    int n = size - 1;
    for (auto i = n; i > 0; --i) {
        int tmp = arr[i];
        arr[i] = arr[0];
        arr[0] = tmp;
        siftDown(arr, 0, i);
    }
}
```
- 时间复杂度 O(logn)*O(n) = O(nlogn)：n个元素与末尾元素交换并进行下沉调整。
- 空间复杂度 O(1)；不用占用额外的空间。
- 非稳定算法。

## 四种基础排序性能对比：
分别使用快速排序、归并排序、希尔排序和堆排序，并计算所用时间。
| 数据规模 | 快速排序 | 归并排序 | 堆排序   | 希尔排序 |
| -------- | -------- | -------- | -------- | -------- |
| 1000万   | 1.0819s  | 1.52038s | 2.8807s  | 3.23398s |
| 5000万   | 5.98468s | 8.27358s | 19.2599s | 20.08s   |
| 1亿      | 12.224s  | 17.1961s | 45.4734s | 46.0831s |

从上述可以发现快速排序是真的快，堆排效率较差有几个原因：
1. 快排或归排，遍历元素都是按照 **顺序遍历** 的，对CPU缓存是友好的（CPU缓存指令命中率高）；但是堆排序访问元素时，是按照 **父子关系访问** ，而不是顺序访问，在排序过程中，无论是上浮还是下沉，都对CPU缓存不友好。
2. 堆排序的过程中，进行元素下沉调整所做的无效比较过多。放到堆顶的元素本来就很小，下沉后的位置和它原来的位置相差不大，无用功比较多。

## 桶排序

> 在这里只是做一个小了解。

1. 找出最长的数字，确定处理的桶排序趟数（最长数字有几位）。
2. 从个位开始，将对应位数上的数字放到相同序号的桶中，完成后再按照桶的序号以此取出桶里面的数据。
3. 处理完所有的位数后，最终得到有序的数列。

![](https://pic.akorin.icu/20250820222643792.webp)