---
title: 高级排序
date: 2025-08-18
updated: 2025-08-18
categories: 笔记
tags:
  - 笔记
  - 编程
  - C++
codeHeightLimit: 750
cover: https://pic.akorin.icu/20250818181857138.webp'
end: false
time_warning: false
---

## 快速排序

选取一个基准数，小于基准数的元素都调整到基准数的左边，把大于基准数的元素都调整到基准数的右边，然后对基准数左边和右边的序列继续进行这样的操作，直到正逢序列变有序。
比较像二分思想。

处理数组的递归问题，需要引入头和尾。

- 复杂度 O(n)*O(logn) = O(nlogn)，最坏时间复杂度O(n^2)（在有序数组中使用快排）
- 空间复杂度O(logn)：主要取决于递归时的深度，最坏空间复杂度O(n)（在有序数组中使用快排）
- 不稳定算法

```C++
// 一次快排算法
int Paration(int arr[], int l, int r) {
    int val = arr[l];
    while (l < r) {
        // l < r防止直接退出导致没有遍历比较其它位置
        while (l < r && arr[r]> val) {
            --r;
        }
        if (l < r) {
            arr[l] = arr[r];
            ++l;
        }
        while (l < r && arr[l] < val) {
            ++l;
        }
        if (l < r) {
            arr[r] = arr[l];
            --r;
        }
    }
    arr[l] = val;
    return l;
}
void QuickSort(int arr[], int begin, int end) {
    if (begin >= end)
        return;
    // 在[begin,end]区间做一次快排分割处理，
    // 并获取排列好的正确位置
    int pos = Paration(arr, begin, end);
    QuickSort(arr, begin, pos - 1);
    QuickSort(arr, pos + 1, end);
}
```

### 快速排序优化

对于已经有序的数列来说，再采用快排其时间复杂度及空间复杂度都很大。

1. 随着快排的执行，数据越来越有序，再一定范围内可以用插入排序代替快速排序。
```C++
void QuickSort(int arr[], int begin, int end) {
    if (begin >= end)
        return;
    // 优化一：当[begin,end]序列的元素个数小到指定数量，采用插入排序
    if (begin - end <= 50) {    // [!code ++]
        InsertSort(arr, begin, end);    // [!code ++]
        return; // [!code ++]
    }   // [!code ++]
    // 在[begin,end]区间做一次快排分割处理，
    // 并获取排列好的正确位置
    int pos = Paration(arr, begin, end);
    QuickSort(arr, begin, pos - 1);
    QuickSort(arr, pos + 1, end);
}
```

2. 选择基准数时，采用 **“三数取中法”** ：
    - `mid = (L + R) / 2`
    - `L`
    - `R`

    这三个位置的序列中的数值在中间的数，作为基准数。
3. 随机数法，随机在数列中取基准数，但是不如三数取中法靠谱。
