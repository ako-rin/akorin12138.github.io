---
title: 高级排序
date: 2025-08-18
updated: 2025-08-19
categories: 笔记
tags:
  - 笔记
  - 编程
  - C++
codeHeightLimit: 750
cover: 'https://pic.akorin.icu/20250819152244337.webp'
end: false
time_warning: false
---

简要记录一系列高级排序的中心思想。

<!-- more -->

## 快速排序

选取一个基准数，小于基准数的元素都调整到基准数的左边，把大于基准数的元素都调整到基准数的右边，然后对基准数左边和右边的序列继续进行这样的操作，直到正逢序列变有序。
比较像二分思想。

处理数组的递归问题，需要引入头和尾。

- 复杂度 O(n)*O(logn) = O(nlogn)，最坏时间复杂度O(n^2)（在有序数组中使用快排）
- 空间复杂度O(logn)：主要取决于递归时的深度，最坏空间复杂度O(n)（在有序数组中使用快排）
- 不稳定算法

```C++
// 一次快排算法
int Paration(int arr[], int l, int r) {
    int val = arr[l];
    while (l < r) {
        // l < r防止直接退出导致没有遍历比较其它位置
        while (l < r && arr[r]> val) {
            --r;
        }
        if (l < r) {
            arr[l] = arr[r];
            ++l;
        }
        while (l < r && arr[l] < val) {
            ++l;
        }
        if (l < r) {
            arr[r] = arr[l];
            --r;
        }
    }
    arr[l] = val;
    return l;
}
void QuickSort(int arr[], int begin, int end) {
    if (begin >= end)
        return;
    // 在[begin,end]区间做一次快排分割处理，
    // 并获取排列好的正确位置
    int pos = Paration(arr, begin, end);
    QuickSort(arr, begin, pos - 1);
    QuickSort(arr, pos + 1, end);
}
```

### 快速排序优化

对于已经有序的数列来说，再采用快排其时间复杂度及空间复杂度都很大。

1. 随着快排的执行，数据越来越有序，再一定范围内可以用插入排序代替快速排序。
```C++
void QuickSort(int arr[], int begin, int end) {
    if (begin >= end)
        return;
    // 优化一：当[begin,end]序列的元素个数小到指定数量，采用插入排序
    if (begin - end <= 50) {    // [!code ++]
        InsertSort(arr, begin, end);    // [!code ++]
        return; // [!code ++]
    }   // [!code ++]
    // 在[begin,end]区间做一次快排分割处理，
    // 并获取排列好的正确位置
    int pos = Paration(arr, begin, end);
    QuickSort(arr, begin, pos - 1);
    QuickSort(arr, pos + 1, end);
}
```

2. 选择基准数时，采用 **“三数取中法”** ：
    - `mid = (L + R) / 2`
    - `L`
    - `R`

    这三个位置的序列中的数值在中间的数，作为基准数。
3. 随机数法，随机在数列中取基准数，但是不如三数取中法靠谱。

## 归并排序

归-递归，并-合并。递到只有一个元素时就到头了，需要额外的内存空间把两个小段有序的序列合并成一个大段有序的序列。
归并排序也采用“分治思想”。

- 复杂度 O(n)*O(logn) = O(nlogn)，每层合并数据n个，层高是logn。
- 空间复杂度O(logn)+O(n) = O(n)：每一层开辟的空间占大头，取O(n)
- 稳定算法（在排序过程中，两数相等时先放左边的数，否则就是不稳定算法）

```C++
    // 归并过程函数
void Merge(int arr[], int l, int m, int r) {
    int* p = new int[r - l + 1];
    int idx = 0;
    int i = l;   // 左孩子第一个元素位置
    int j = m + 1;   // 右孩子第一个元素位置
    while (i <= m && j <= r) {
        if (arr[i] <= arr[j]) {
            p[idx++] = arr[i++];
        } else {
            p[idx++] = arr[j++];
        }
    }
    while (i <= m) {
        p[idx++] = arr[i++];
    }
    while (j <= r) {
        p[idx++] = arr[j++];
    }
    // 再把合并好的大段有序结果拷贝进原始arr的[l,r]区间内
    for (i = l, j = 0; i <= r; ++i, ++j) {
        arr[i] = p[j];
    }
    delete[] p;
    p = nullptr;
}
void MergeSort(int arr[], int begin, int end) {
    if (begin >= end) {
        return;
    }
    // 先递后归
    int mid = (begin + end) / 2;
    MergeSort(arr, begin, mid);
    MergeSort(arr, mid + 1, end);
    // 归回来就开始排序
    Merge(arr, begin, mid, end);
    // 排完序结束回到上一层继续处理
}
```

## 堆排序

### 二叉堆

二叉堆就是一颗完全 **完全二叉树** ， 分为两种典型的堆： **大根堆** 和 **小根堆** 。

:::info 完全二叉树的充分条件

完全二叉树的最后一层的叶子节点都是靠左排列的，且除了最后一层的节点都是满的，最后一层可以不是满的。

:::

逻辑上是一颗完全二叉树，存储方式上用数组进行存储的。

:::tip 数组与二叉树的关系

`i` 为数组的下标，逻辑上对应的二叉树位置为：
- 左孩子： `2 * i + 1`
- 右孩子： `2 * i + 2`
![](https://pic.akorin.icu/20250819150044468.webp)
:::

满足 `0 <= i <= (n - 1) / 2` ，`i` 代表数组的下标， `n` 代表最后一个元素的下标。
- 如果 `arr[i] <= arr[2 * i + 1] && arr[i] <= arr[2 * i + 2]` ，就是小根堆  
- 如果 `arr[i] > = arr[2 * i + 1] && arr[i] >= arr[2 * i + 2]` ，就是大根堆

换人话来说就是：根节点（**堆顶**）和两个孩子节点值的大小关系，根节点的值比两个孩子的值大就是 **大根堆**， 比两个孩子的值小就是 **小根堆**。

:::tip 获取父节点位置
`(i - 1) / 2`
:::

因此要得到第一个非叶子节点（第一个有孩子的节点）的下标： `(n - 1) / 2`，其中 `n` 是最后一个元素的下标。  
从最后一个节点的下标推出它的父节点，最后一个节点也就是数组最后一个元素 `n`。  
这里取 `n- 1 `是确保无论最后一个元素是左节点还是右节点都可以找到其父节点。

### 入堆

入堆即将某个数加入到堆中。入堆步骤（以大根堆为例）：
1. 将要入堆的数据放入数组末尾，并计算对应树中的位置。
2. 计算它的父节点位置，并与父节点进行比较，若大于父节点则与父节点进行位置交换。
3. 重复上述1、2步骤直至无父节点（到达堆顶），或满足大根堆的要求（父节点大于孩子节点）。

上述过程叫做 **上浮** 。在实际应用中，为了效率，上浮过程中不是交换位置，而是只操作父节点往下赋值，直到入堆节点上浮到对应位置，在该位置再赋值要入堆的元素。
![](https://pic.akorin.icu/20250819175059577.webp)

