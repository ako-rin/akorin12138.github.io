---
title: 高级排序
date: 2025-08-18
updated: 2025-08-19
categories: 笔记
tags:
  - 笔记
  - 编程
  - C++
codeHeightLimit: 750
cover: 'https://pic.akorin.icu/20250819152244337.webp'
end: false
time_warning: false
---

简要记录一系列高级排序的中心思想。

<!-- more -->

## 快速排序

选取一个基准数，小于基准数的元素都调整到基准数的左边，把大于基准数的元素都调整到基准数的右边，然后对基准数左边和右边的序列继续进行这样的操作，直到正逢序列变有序。
比较像二分思想。

处理数组的递归问题，需要引入头和尾。

- 时间复杂度 O(n)*O(logn) = O(nlogn)，最坏时间复杂度O(n^2)（在有序数组中使用快排）
- 空间复杂度O(logn)：主要取决于递归时的深度，最坏空间复杂度O(n)（在有序数组中使用快排）
- 不稳定算法

```C++
// 一次快排算法
int Paration(int arr[], int l, int r) {
    int val = arr[l];
    while (l < r) {
        // l < r防止直接退出导致没有遍历比较其它位置
        while (l < r && arr[r]> val) {
            --r;
        }
        if (l < r) {
            arr[l] = arr[r];
            ++l;
        }
        while (l < r && arr[l] < val) {
            ++l;
        }
        if (l < r) {
            arr[r] = arr[l];
            --r;
        }
    }
    arr[l] = val;
    return l;
}
void QuickSort(int arr[], int begin, int end) {
    if (begin >= end)
        return;
    // 在[begin,end]区间做一次快排分割处理，
    // 并获取排列好的正确位置
    int pos = Paration(arr, begin, end);
    QuickSort(arr, begin, pos - 1);
    QuickSort(arr, pos + 1, end);
}
```

### 快速排序优化

对于已经有序的数列来说，再采用快排其时间复杂度及空间复杂度都很大。

1. 随着快排的执行，数据越来越有序，再一定范围内可以用插入排序代替快速排序。
```C++
void QuickSort(int arr[], int begin, int end) {
    if (begin >= end)
        return;
    // 优化一：当[begin,end]序列的元素个数小到指定数量，采用插入排序
    if (begin - end <= 50) {    // [!code ++]
        InsertSort(arr, begin, end);    // [!code ++]
        return; // [!code ++]
    }   // [!code ++]
    // 在[begin,end]区间做一次快排分割处理，
    // 并获取排列好的正确位置
    int pos = Paration(arr, begin, end);
    QuickSort(arr, begin, pos - 1);
    QuickSort(arr, pos + 1, end);
}
```

2. 选择基准数时，采用 **“三数取中法”** ：
    - `mid = (L + R) / 2`
    - `L`
    - `R`

    这三个位置的序列中的数值在中间的数，作为基准数。
3. 随机数法，随机在数列中取基准数，但是不如三数取中法靠谱。

## 归并排序

归-递归，并-合并。递到只有一个元素时就到头了，需要额外的内存空间把两个小段有序的序列合并成一个大段有序的序列。
归并排序也采用“分治思想”。

- 时间复杂度 O(n)*O(logn) = O(nlogn)，每层合并数据n个，层高是logn。
- 空间复杂度O(logn)+O(n) = O(n)：每一层开辟的空间占大头，取O(n)
- 稳定算法（在排序过程中，两数相等时先放左边的数，否则就是不稳定算法）

```C++
    // 归并过程函数
void Merge(int arr[], int l, int m, int r) {
    int* p = new int[r - l + 1];
    int idx = 0;
    int i = l;   // 左孩子第一个元素位置
    int j = m + 1;   // 右孩子第一个元素位置
    while (i <= m && j <= r) {
        if (arr[i] <= arr[j]) {
            p[idx++] = arr[i++];
        } else {
            p[idx++] = arr[j++];
        }
    }
    while (i <= m) {
        p[idx++] = arr[i++];
    }
    while (j <= r) {
        p[idx++] = arr[j++];
    }
    // 再把合并好的大段有序结果拷贝进原始arr的[l,r]区间内
    for (i = l, j = 0; i <= r; ++i, ++j) {
        arr[i] = p[j];
    }
    delete[] p;
    p = nullptr;
}
void MergeSort(int arr[], int begin, int end) {
    if (begin >= end) {
        return;
    }
    // 先递后归
    int mid = (begin + end) / 2;
    MergeSort(arr, begin, mid);
    MergeSort(arr, mid + 1, end);
    // 归回来就开始排序
    Merge(arr, begin, mid, end);
    // 排完序结束回到上一层继续处理
}
```

## 堆排序

### 二叉堆

二叉堆就是一颗完全 **完全二叉树** ， 分为两种典型的堆： **大根堆** 和 **小根堆** 。

:::info 完全二叉树的充分条件

完全二叉树的最后一层的叶子节点都是靠左排列的，且除了最后一层的节点都是满的，最后一层可以不是满的。

:::

逻辑上是一颗完全二叉树，存储方式上用数组进行存储的。

:::tip 数组与二叉树的关系

`i` 为数组的下标，逻辑上对应的二叉树位置为：
- 左孩子： `2 * i + 1`
- 右孩子： `2 * i + 2`
![](https://pic.akorin.icu/20250819150044468.webp)
:::

满足 `0 <= i <= (n - 1) / 2` ，`i` 代表数组的下标， `n` 代表最后一个元素的下标。
- 如果 `arr[i] <= arr[2 * i + 1] && arr[i] <= arr[2 * i + 2]` ，就是小根堆  
- 如果 `arr[i] > = arr[2 * i + 1] && arr[i] >= arr[2 * i + 2]` ，就是大根堆

换人话来说就是：根节点（**堆顶**）和两个孩子节点值的大小关系，根节点的值比两个孩子的值大就是 **大根堆**， 比两个孩子的值小就是 **小根堆**。

获取父节点的公式：
- `(i - 1) / 2`  

这里取 `i- 1 `是确保无论最后一个元素是左节点还是右节点都可以找到其父节点。

:::info 叶子节点

叶子节点：**既没有左孩子也没有右孩子**，在树的图形上就是“树枝的尽头”，没有子节点的节点。  

:::

由于堆的性质，叶子节点没有子节点，也就不需要进行比较。需要找到第一个非叶子节点来进行比较和操作。

:::tip 什么是第一个非叶子节点

1. 建堆时要**保证子树先变成堆**，再逐层往上合并。因此，堆都是 **从堆底往顶上看** ，那么第一个非叶子节点就是从堆底开始找。  
2. 第一个非叶子节点也就变成了 **第一个要处理的有孩子的父节点**。  
3. 要找到第一个非叶子节点，可以从最后的元素计算其父节点的位置：  
    - `(n - 1) / 2` 或
    - `size / 2` 其中 `size` 为队列元素个数

:::


### 入堆

入堆即将某个数加入到堆中。入堆步骤（以大根堆为例）：
1. 将要入堆的数据放入数组末尾，并计算对应树中的位置。
2. 计算它的父节点位置，并与父节点进行比较，若大于父节点则与父节点进行位置交换。
3. 重复上述1、2步骤直至无父节点（到达堆顶），或满足大根堆的要求（父节点大于孩子节点）。

上述过程叫做 **上浮** 。在实际应用中，为了效率，上浮过程中不是交换位置，而是只操作父节点往下赋值，直到入堆节点上浮到对应位置，在该位置再赋值要入堆的元素。
![](https://pic.akorin.icu/20250819175059577.webp)

### 出堆

出堆 **只能出堆顶元素** 。出堆步骤（以大根堆为例）：
1. 直接将最后一个元素放到堆顶，然后开始 **下沉** 操作。
2. 此时与其孩子节点做比较，并将较大的孩子与其交换。
3. 重复上述步骤2，直到没有孩子（超出第一个非叶子节点 `i > (n - 1) / 2` ）或者其孩子节点均小于它。

上述过程是 **下沉** ，将堆顶的元素往下放。与上浮相同，为了效率，下沉过程中只操作子节点往上赋值，直到堆顶元素下沉到对应位置再赋最后一个节点元素的值。
![](https://pic.akorin.icu/20250819192544736.webp)

### 入堆出堆的复杂度

- 时间复杂度 O(logn)：即为树的高度。
- 空间复杂度 O(1)；这两个操作都不用占用额外的空间。

### 基于大根堆和小根堆的优先级队列

优先级队列根据元素的 **优先级** 来决定谁先出来，而不单纯看谁先进入。而普通队列（FIFO）是先进先出。
- 小根堆-> 每次取出最小值（优先级最高的元素）。
- 大根堆-> 每次取出最大值（优先级最高的元素）。

用代码实现堆的排序时，可以先实现优先级队列（即实现堆的出堆、入堆、是否空等操作）。

```C++
// 默认构造大根堆
class PriorityQueue {
public:
    using Cmp = function<bool(int, int)>;
    PriorityQueue(int size = 10, Cmp f = greater<int>()) :
        que_(new int[size]), size_(0), cap_(size), cmp_(f) {}

    ~PriorityQueue() {
        delete[] que_;
        que_ = nullptr;
    }
    void push(int data) {
        if (size_ == cap_) {
            int* p = new int[2 * cap_];
            memcpy(p, que_, sizeof(int) * size_);
            delete[] que_;
            que_ = p;
            cap_ *= 2;
        }
        siftUp(data);
        ++size_;
    }
    int pop() {
        if (empty())
            throw "No data. Fuck u!";
        int data = que_[0];
        siftDown();
        --size_;
        return data;
    }
    int top() {
        return que_[0];
    }
    bool empty() {
        return !size_;
    }
    bool full() {
        return size_ == cap_;
    }
private:
    int* que_;
    int size_;   // 有效数据个数
    int cap_;    // 堆内存大小
    Cmp cmp_;    // 比较函数
    void siftUp(int data) {
        // 大根堆比较，直接插入进堆尾
        que_[size_] = data;
        // 堆尾和父节点比较
        int father = (size_ - 1) / 2;
        // 记录入堆节点位置
        int pos = size_;
        // 跳出条件：父节点大于子节点或到达堆顶
        while (cmp_(data, que_[father]) && father != pos) {
            que_[pos] = que_[father];
            pos = father;
            father = (pos - 1) / 2;
        }
        // 到达对应位置跳出
        que_[pos] = data;
    }
    void siftDown() {
        int val = que_[size_ - 1];
        int pos = 0;
        // 先左右子节点对比，再拿较大的和下沉节点比较（三数对比）
        int child = (2 * pos) + 1;
        // 出口条件：大于等于1个子节点不存在或子节点均小于下沉节点
        // 当最后一个节点是右节点，且能下沉到它的父节点位置上
        // 此时就是 右节点和右节点和左节点不带等于的比较，
        // 最后也就是左节点和右节点进行比较，右节点大，
        // 接着就自己和自己比较，然后直接break，
        // 左节点大就正常进行交换操作
        while (child + 1 < size_) {
            if (cmp_(que_[child + 1], que_[child])) {
                ++child;
            }
            if (cmp_(que_[child], val)) {
                que_[pos] = que_[child];
                pos = child;
            } else {
                break;
            }
            // 更新child位置
            child = (2 * pos) + 1;
        }
        // 找到下沉节点新位置，直接赋值
        que_[pos] = val;
    }
};
```
其中下沉操作的代码可以写得逻辑清晰点，这样保证了只有左节点也能比较：
```C++
void siftDown() {
    int val = que_[size_ - 1];
    int pos = 0;
    int child = (2 * pos) + 1;
    while (child + 1 < size_) { // [!code --]
    if (cmp_(que_[child + 1], que_[child])) { // [!code --]
    while (child < size_) { // [!code ++]
        if (child + 1 < size_ && cmp_(que_[child + 1], que_[child])) { // [!code ++]
            ++child;
        }
        if (cmp_(que_[child], val)) {
            que_[pos] = que_[child];
            pos = child;
        } else {
            break;
        }
        child = (2 * pos) + 1;
    }
    que_[pos] = val;
}
```