---
layout: post
title: 大数据查重
date: 2025-08-25 14:50:54
updated: '2025-08-25 17:27:41 +0800'
categories: 算法
tags:
  - 算法
  - 编程
  - C++
cover: 'https://pic.akorin.icu/20250825163634255.webp'
codeHeightLimit: 500
toc: true
time_warning: false
end: false
---
# 大数据查重

这里的大数据不是java那种大数据分析，而是数据量很庞大的数据。

这种大数据查重有几种算法：
- 哈希表查重
- 位图算法
- 布隆过滤器

类似问题有：一亿个数据，哪些元素重复了，谁是第一个重复的，谁是第一个不重复的……且内存限制100M。
<!-- more -->

## 哈希表查重
<!--@include: ./哈希表.md{364,392}-->

## 位图算法(bitmap)

相当于二进制版本的哈希表，每一位对应每条数据。如15对应 **1**000 0000 0000 0000的1。因为是二进制，**它的空间占用率很低**。

对于一亿个int类型元素（100M个数据），则占用 100000000/32 * 4 = **12.5M的内存**。

1. 需要知道元素序列的最大值，根据最大值定义bitmap位图数组。
2. 直到了最大值max，则通过 `/` 计算位图数组大小。定义位图数组：
    ```C++
    char bitmap[max / 8 + 1];
    ```
    其中 `8` 为数据类型为 `char` 型**占用的比特数**。若数据类型是 `int` 型，则需要改成 `32`。
3. 若要查找的某个数为 `n`，通过 `/` 计算数据在第几个比特，通过 `%` 计算数据在对应比特的位置。
    ```C++
    int index = n / 8;
    int offset = n % 8;
    ```
4. 读取该位为 `0` ，说明数据未出现过，若为 `1` ，说明数据出现过。
    ```C++
    bool b = bitmap[index] & (1 << offset); // 获取对应位的值
    ```

```C++
vector<int> vec{7,18,12,6,256,1,5};
int max = vec[0];
for(auto i:vec) {
    if(i > max)
        max = i;
}
// 初始化数组全为0
int *bitmap = new int[max / 32 + 1]();
// 智能指针管理内存，就不用自己释放了
unique_ptr<int> ptr(bitmap);
// 找第一个重复的数字
for (auto key:vec) {
    int offset = key / 32;
}
```