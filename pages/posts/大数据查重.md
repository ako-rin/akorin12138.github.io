---
layout: post
title: 大数据查重
date: 2025-08-25 14:50:54
updated: 2025-08-26 00:20:34
categories: 算法
tags:
  - 算法
  - 大数据
  - 编程
  - C++
cover: 'https://pic.akorin.icu/20250825163634255.webp'
codeHeightLimit: 500
toc: true
time_warning: true
end: true
---
# 大数据查重

这里的大数据不是java那种大数据分析，而是数据量很庞大的数据。

这种大数据查重有几种算法：
- 哈希表查重
- 位图算法
- 布隆过滤器

类似问题有：一亿个数据，哪些元素重复了，谁是第一个重复的，谁是第一个不重复的……且内存限制100M。
<!-- more -->

## 哈希表查重
<!--@include: ./哈希表.md{364,395}-->

## 位图算法(bitmap)

每一位对应每条数据。如15对应 **1**000 0000 0000 0000的1。因为是二进制，**它的空间占用率很低**。

对于一亿个int类型元素（100M个数据），则占用 100000000/32 * 4 = **12.5M的内存**。

1. 需要知道元素序列的最大值，根据最大值定义bitmap位图数组。
2. 直到了最大值max，则通过 `/` 计算位图数组大小。定义位图数组：
    ```C++
    char bitmap[max / 8 + 1];
    ```
    其中 `8` 为数据类型为 `char` 型**占用的比特数**。若数据类型是 `int` 型，则需要改成 `32`。
3. 若要查找的某个数为 `n`，通过 `/` 计算数据在第几个比特，通过 `%` 计算数据在对应比特的位置。
    ```C++
    int index = n / 8;
    int offset = n % 8;
    ```
4. 读取该位为 `0` ，说明数据未出现过，若为 `1` ，说明数据出现过。
    ```C++
    bool b = bitmap[index] & (1 << offset); // 获取对应位的值
    ```

找出所有重复数据：
```C++
vector<int> vec{7,18,12,6,256,1,5};
int max = vec[0];
for(auto i:vec) {
    if(i > max)
        max = i;
}
// 初始化数组全为0
int *bitmap = new int[max / 32 + 1]();
// 智能指针管理内存，就不用自己释放了
unique_ptr<int> ptr(bitmap);
// 找第一个重复的数字
for (auto key:vec) {
    int index = key / 32;
    int offset = key % 32;
    if (!bitmap[index] & (1 << offset)) {
        // 第一次遇到这个数
        bitmap[index] |= (1 << offset);
    } else {
        // 遇到重复的了，打印出来
        cout << "重复数据：" << i << endl;
    }
}
```

还可以改成查找 **第一个不重复** 的数据，那么：
1. 记录数组所有数据。
2. 用 **两个bit** 来记录每个数的状态，可以用01表示记录一次，11表示记录了多次。

### 缺陷

当有数组：`[1,3,1000000000]` ，这样的话就会使得这个 `bitmap` 占用 `1000000000/32 * 4 = 125MB`的空间。

而此时用哈希表，只占用 `3 * 4 * 2 = 24B` 的空间。

位图算法比较好的应用场景是 **最大值** 和数组的大小差不多大。

:::info
- `int` 最大有20亿
- `unsigned int` 最大有40亿
:::

## 布隆过滤器(Bloom Filter)

布隆过滤器是一个高级的位图算法，相当于**哈希表+位图**，也就是**二进制版本的哈希表** ，效率高而且占用也低，但是又与哈希表有很大不同，**布隆过滤器要计算多个哈希** 。

### 使用场景

- 提示过滤一些非法的网站、或者钓鱼网站。

- redis缓存中的应用，把热点数据放入redis中。


### 布隆过滤器注意事项

经过 **k个哈希函数计算** ，得到bitmap位数组里面的一组位的序号。
- **增加元素**： 把得到的 **所有序号对应位置置为1** 。
- **搜索一个元素**： 查看对应位是否为1，若为1则返回true，否则返回false。
- **不支持删除！** ，若删除后且寻找下一个数发生“冲突”时，就不能正确检索到下一个正确的位。
- 布隆过滤器可能会 **共用一些位** ，即与其它数经过k个哈希函数算下来的位相同了。
- 若布隆过滤器查询一个key经过k个哈希函数处理后，对应的位都是1， **不能说明这个位存在！** 因此布隆过滤器可能会产生 **误判！**
- 若博隆过滤器查询一个key经过k个哈希函数处理后，得到对应的位为0，那么这个数 **一定不在** 。
- 综上，如果布隆过滤器太小，误判率就会很高。

### 布隆过滤器算法思想

1. 将元素计算经过k个哈希函数并取模，得到一系列的位数。
2. 将这些位在对应的布隆bit位上置为1。
3. 查找时只有对应的所有位都为1才算做找到。
4. 由于经过布隆过滤器计算发现不存在，那么只要计算出来的哈希值在布隆过滤器中没有，那么该数就一定不存在！
5. 记录和查询的时间复杂度均为 O(1)

::: code-group
```C++ [布隆过滤器代码实现]
class BloomFilter {
public:
    // 取个素数
    BloomFilter(int size = 1471) : bitSize_(size) {
        // int 是32位
        bitMap_.resize(bitSize_ / 32 + 1);
    }

public:
    // 添加函数
    void setBit(const char* str) {
        // 先计算哈希函数的值
        int idx1 = hash1(str) % bitSize_;
        int idx2 = hash2(str) % bitSize_;
        int idx3 = hash3(str) % bitSize_;

        // 把相应的idx1 idx2 idx3对应的位全部置1

        int index = idx1 / 32;
        int offset = idx1 % 32;
        bitMap_[index] |= (1 << offset);
        index = idx2 / 32;
        offset = idx2 % 32;
        bitMap_[index] |= (1 << offset);
        index = idx3 / 32;
        offset = idx3 % 32;
        bitMap_[index] |= (1 << offset);
    }

    bool getBit(const char* str) {
        // 先计算哈希函数的值
        int idx1 = hash1(str) % bitSize_;
        int idx2 = hash2(str) % bitSize_;
        int idx3 = hash3(str) % bitSize_;

        int index = idx1 / 32;
        int offset = idx1 % 32;
        if (!(bitMap_[index] & (1 << offset))) {
            return false;
        }
        index = idx2 / 32;
        offset = idx2 % 32;
        if (!(bitMap_[index] & (1 << offset))) {
            return false;
        }
        index = idx3 / 32;
        offset = idx3 % 32;
        if (!(bitMap_[index] & (1 << offset))) {
            return false;
        }

        // 只有三个位置都是1才能确定存在
        return true;
    }
private:
    int bitSize_;
    vector<int> bitMap_;
};

// 黑名单
class BlackList {
public:
    BlackList(){}
    void add(string url) {
        blockList_.setBit(url.c_str());
    }
    bool query(string url) {
        return blockList_.getBit(url.c_str());
    }

private:
    BloomFilter blockList_;
};
```
```C++ [使用的哈希函数]
// 哈希函数1：使用 std::hash
inline size_t hash1(const std::string& key) {
    return std::hash<std::string>{}(key);
}

// 哈希函数2：DJB哈希
inline size_t hash2(const std::string& key) {
    size_t hash = 5381;
    for (char c : key) {
        hash = ((hash << 5) + hash) + c;   // hash * 33 + c
    }
    return hash;
}

// 哈希函数3：SDBM哈希
inline size_t hash3(const std::string& key) {
    size_t hash = 0;
    for (char c : key) {
        hash = c + (hash << 6) + (hash << 16) - hash;
    }
    return hash;
}

// 哈希函数4：BKDR哈希
inline size_t hash4(const std::string& key) {
    size_t seed = 131;   // 31, 131, 1313, 13131, 131313, etc.
    size_t hash = 0;
    for (char c : key) {
        hash = hash * seed + c;
    }
    return hash;
}

// 哈希函数5：AP哈希
inline size_t hash5(const std::string& key) {
    size_t hash = 0;
    for (size_t i = 0; i < key.size(); ++i) {
        if (i % 2 == 0) {
            hash ^= ((hash << 7) ^ key[i] ^ (hash >> 3));
        } else {
            hash ^= (~((hash << 11) ^ key[i] ^ (hash >> 5)));
        }
    }
    return hash;
}
```
:::

## 扩展

### 误判率公式
布隆过滤器的误判率公式为：
$$
P = \left(1 - e^{-\frac{kn}{m}}\right)^k
$$
其中：
- $P$：误判率
- $k$：哈希函数的数量
- $n$：要存储的元素数量
- $m$：位数组的长度

### 布隆过滤器的大小
为了在给定的误判率下确定布隆过滤器的大小（位数组长度 $m$），公式为：
$$
m = -\frac{n \cdot \ln P}{(\ln 2)^2}
$$
其中：
- $P$ 是目标误判率（例如 $P = 0.01$ 表示 1% 的误判率）。
- $n$ 是要存储的元素数量。

### 哈希函数的最佳数量
最佳的哈希函数数量 $k$ 可以通过以下公式计算：
$$
k = \frac{m}{n} \cdot \ln 2
$$
其中：
- $m$ 是位数组的长度。
- $n$ 是要存储的元素数量。

### 示例
假设：
- 要存储的元素数量 $n = 1,000,000$。
- 目标误判率 $P = 0.01$（1%）。

#### 计算位数组的长度：
$$
m = -\frac{1,000,000 \cdot \ln 0.01}{(\ln 2)^2} \approx 9,585,058 \text{ 位}
$$
即需要约 $9.6 \, \text{MB}$ 的位数组。

#### 计算最佳哈希函数数量：
$$
k = \frac{m}{n} \cdot \ln 2 \approx 6.64
$$
即需要 $6$ 到 $7$ 个哈希函数。
