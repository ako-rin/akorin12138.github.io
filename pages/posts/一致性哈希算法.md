---
layout: post
title: 一致性哈希算法
date: 2025-08-26 15:46:58
categories: 算法
tags:
  - 算法
  - 一致性哈希
  - 编程
  - C++
cover: 'https://pic.akorin.icu/20250826190318220.webp'
codeHeightLimit: 500
toc: true
time_warning: true
end: true
updated: 2025-08-27 16:25:45
---

# 一致性哈希算法

**一致性哈希（Consistent Hashing）** ：是一种特殊的哈希算法，用于解决 **分布式系统中的数据分布与动态伸缩问题。**

- 当 **节点**（机器/缓存服务器）数量发生变化（增加或减少）时，尽可能减少需要重新映射的数据量。
- 避免传统哈希算法带来的大规模数据迁移问题。

<!-- more -->



## 为什么需要一致性哈希

假设有一个缓存集群：
- 普通哈希方法：`hash(key) % N` （N 是机器数量）。
- 如果某台机器宕机，N 变了 → 所有 key 的分布都变了，几乎所有缓存都会失效，需要重算和迁移。

![](https://pic.akorin.icu/20250826185010124.webp)

## 算法思想

1. 哈希环：把整个哈希值空间想象成一个环。
2. 节点映射：每个机器节点通过哈希映射到环上的一个点。
3. 数据映射：每个数据 key 也映射到环上，顺时针找到第一个节点就是它的存储节点。
4. 节点变化：
    - 新增节点：只影响它顺时针方向的一部分 key。
    - 删除节点：只影响它之前负责的一部分 key。
    ![](https://pic.akorin.icu/20250826214336915.webp)

先通过哈希函数计算出哈希值，落在哈希环上的某个位置，在哈希环中沿着顺时针开始找，直到找到节点。

在上图中，哈希值落在B和C区间，最终都会找到C这个节点。 **删改其中的节点只影响到环上的一部分** ，不会造成服务的大量定位，也就不会出现大量请求突然几种请求某个服务节点。


### 虚拟节点

- 一个物理机器对应多个虚拟节点。
- 虚拟节点均匀分布在哈希环上。
- 这样可以解决部分节点“分到的数据太多”的负载不均衡问题。
  ![](https://pic.akorin.icu/20250826215610930.webp)


在真实的主机，一般会放100~200个虚拟节点。

设置虚拟节点是为了防止物理节点过少，导致哈希处理后， **在一致性哈希环上挤在一块** ，防止导致某一台服务器负载太多，其他服务器一直空闲。

:::code-group
```C++ [main.cpp]
#include "md5.h"
#include <iostream>
#include <list>
#include <random>
#include <set>
#include <string>
#include <sys/types.h>
#include <map>

using namespace std;

// 声明虚拟主机
class VirtualHost;

// 物理主机
class PhysicalHost {
public:
    PhysicalHost(string ip, int vHostNums) : ip_(ip) {
        for (int i = 0; i < vHostNums; ++i) {
            // 虚拟节点构造需要传入虚拟ip和物理主机
            virtualHostList_.emplace_back(ip + "#" + to_string(i),
                                          this);
        }
    }

public:
    const string getPhyIP() const {
        return ip_;
    }
    const list<VirtualHost>& getVirtualHostList() const {
        return virtualHostList_;
    }

private:
    string ip_;
    list<VirtualHost> virtualHostList_;
};

class VirtualHost {
public:
    VirtualHost(string vip, PhysicalHost* phy) :
        vip_(vip), phyHost(phy) {
        // 计算md5
        md5_ = md5_to_uint(vip_);
    }

public:
    const uint getMd5() const {
        return md5_;
    }
    const string getVip() const {
        return vip_;
    }
    const PhysicalHost* getPhyHost() const {
        return phyHost;
    }
    bool operator<(const VirtualHost& other) const {
        return md5_ < other.md5_;
    }
    bool operator==(const VirtualHost& other) const {
        // vip_ 算作唯一的标识符
        return vip_ == other.vip_;
    }

private:
    string vip_;
    uint md5_;               //  该虚拟节点的md5值
    PhysicalHost* phyHost;   // 隶属的物理节点
};

class ConsistentHash {
public:
    void addHost(PhysicalHost& phy) {
        for (auto v : phy.getVirtualHostList()) {
            hcircle_.insert(v);
        }
    }
    void delHost(PhysicalHost& phy) {
        // 删除该主机的所有虚拟节点
        // 不能在遍历的过程中动原来的容器
        for (auto vhost : phy.getVirtualHostList()) {
            auto it = hcircle_.find(vhost);
            if (it != hcircle_.end())
                hcircle_.erase(it);
        }
    }
    // 获取负载的真实物理主机ip
    const string getHost(string clientip) const {
        uint md5 = md5_to_uint(clientip);
        // 找第一个大于client的md5的虚拟节点
        for (auto v : hcircle_) {
            if (v.getMd5() > md5) {
                return v.getPhyHost()->getPhyIP();
            }
        }
        // 所有的哈希值都小于等于客户端的哈希值，直接扔给第一个虚拟节点
        // 从0开始遇见的第一个虚拟节点
        return hcircle_.begin()->getPhyHost()->getPhyIP();
    }

private:
    // 红黑树中排序是std::less，需要改
    // 此时是两个类在比较，因此需要重载类的小于运算符
    set<VirtualHost> hcircle_;
};

int main() {
    PhysicalHost host1("10.117.124.10", 150);
    PhysicalHost host2("10.117.124.20", 150);
    PhysicalHost host3("10.117.124.30", 150);

    ConsistentHash chash;
    chash.addHost(host1);
    chash.addHost(host2);
    chash.addHost(host3);

    list<string> iplists;
    // 生成30个192.168.x.y格式的随机IP
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> dist_x(0, 255);
    uniform_int_distribution<> dist_y(1, 254);

    for (int i = 0; i < 30; ++i) {
        int x = dist_x(gen);
        int y = dist_y(gen);
        iplists.push_back("192.168." + to_string(x) + "." +
                          to_string(y));
    }

    map<string, list<string>> logMap;
    for (auto clientip : iplists) {
        string host = chash.getHost(clientip);
        logMap[host].emplace_back(clientip);
    }

    for (auto pair : logMap) {
        cout << "物理主机ip:" << pair.first << endl;
        cout << "客户端映射的数量:" << pair.second.size() << endl;

        for (auto ip : pair.second) {
            cout << ip << endl;
        }
        cout << "----------------------------------" << endl;
    }
    cout << endl;

    // 模拟host1故障
    chash.delHost(host1);
    // 清除原来的log，防止重复记录
    logMap.clear();
    for (auto clientip : iplists) {
        string host = chash.getHost(clientip);
        logMap[host].emplace_back(clientip);
    }

    for (auto pair : logMap) {
        cout << "物理主机ip:" << pair.first << endl;
        cout << "客户端映射的数量:" << pair.second.size() << endl;

        for (auto ip : pair.second) {
            cout << ip << endl;
        }
        cout << "----------------------------------" << endl;
    }
    cout << endl;
    return 0;
}
```
```C++ [md5.cpp]
// md5_uint.cpp
// 简单的 MD5 实现（RFC1321），并提供 md5_to_uint(string) -> unsigned
// int（uint32_t）
// 版权：此实现参考公开域/教学实现，适合学习与工程使用。

#include <cstdint>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <string>
#include <vector>

using uint32 = uint32_t;
using uint8 = uint8_t;

class MD5 {
public:
    MD5() {
        init();
    }

    void update(const uint8* input, size_t length) {
        size_t idx = (count[0] >> 3) & 0x3F;
        uint64_t bits = (uint64_t)length << 3;

        // update bit count
        count[0] += (uint32)bits;
        if (count[0] < (uint32)bits)
            count[1]++;
        count[1] += (uint32)(length >> 29);

        size_t partLen = 64 - idx;
        size_t i = 0;
        if (length >= partLen) {
            memcpy(&buffer[idx], input, partLen);
            transform(buffer);

            for (i = partLen; i + 63 < length; i += 64)
                transform(&input[i]);
            idx = 0;
        } else {
            i = 0;
        }
        memcpy(&buffer[idx], &input[i], length - i);
    }

    void finalize(uint8 digest[16]) {
        static const uint8 PADDING[64] = {0x80};
        uint8 bits[8];
        encodeBits(bits);

        size_t idx = (count[0] >> 3) & 0x3f;
        size_t padLen = (idx < 56) ? (56 - idx) : (120 - idx);
        update(PADDING, padLen);
        update(bits, 8);

        encodeState(digest);
        // clear sensitive data
        memset(buffer, 0, sizeof(buffer));
        count[0] = count[1] = 0;
    }

private:
    void init() {
        count[0] = count[1] = 0;
        // 消息摘要初始向量（RFC1321）
        state[0] = 0x67452301;
        state[1] = 0xEFCDAB89;
        state[2] = 0x98BADCFE;
        state[3] = 0x10325476;
    }

    // 基本左循环宏
    static inline uint32 rotate_left(uint32 x, int n) {
        return (x << n) | (x >> (32 - n));
    }

    // 四个基本函数（RFC1321）
    static inline uint32 F(uint32 x, uint32 y, uint32 z) {
        return (x & y) | (~x & z);
    }
    static inline uint32 G(uint32 x, uint32 y, uint32 z) {
        return (x & z) | (y & ~z);
    }
    static inline uint32 H(uint32 x, uint32 y, uint32 z) {
        return x ^ y ^ z;
    }
    static inline uint32 I(uint32 x, uint32 y, uint32 z) {
        return y ^ (x | ~z);
    }

    void transform(const uint8 block[64]) {
        uint32 a = state[0], b = state[1], c = state[2], d = state[3],
               x[16];

        decodeBlock(block, x);

        // Round 1
        a = b + rotate_left(a + F(b, c, d) + x[0] + 0xd76aa478, 7);
        d = a + rotate_left(d + F(a, b, c) + x[1] + 0xe8c7b756, 12);
        c = d + rotate_left(c + F(d, a, b) + x[2] + 0x242070db, 17);
        b = c + rotate_left(b + F(c, d, a) + x[3] + 0xc1bdceee, 22);
        a = b + rotate_left(a + F(b, c, d) + x[4] + 0xf57c0faf, 7);
        d = a + rotate_left(d + F(a, b, c) + x[5] + 0x4787c62a, 12);
        c = d + rotate_left(c + F(d, a, b) + x[6] + 0xa8304613, 17);
        b = c + rotate_left(b + F(c, d, a) + x[7] + 0xfd469501, 22);
        a = b + rotate_left(a + F(b, c, d) + x[8] + 0x698098d8, 7);
        d = a + rotate_left(d + F(a, b, c) + x[9] + 0x8b44f7af, 12);
        c = d + rotate_left(c + F(d, a, b) + x[10] + 0xffff5bb1, 17);
        b = c + rotate_left(b + F(c, d, a) + x[11] + 0x895cd7be, 22);
        a = b + rotate_left(a + F(b, c, d) + x[12] + 0x6b901122, 7);
        d = a + rotate_left(d + F(a, b, c) + x[13] + 0xfd987193, 12);
        c = d + rotate_left(c + F(d, a, b) + x[14] + 0xa679438e, 17);
        b = c + rotate_left(b + F(c, d, a) + x[15] + 0x49b40821, 22);

        // Round 2
        a = b + rotate_left(a + G(b, c, d) + x[1] + 0xf61e2562, 5);
        d = a + rotate_left(d + G(a, b, c) + x[6] + 0xc040b340, 9);
        c = d + rotate_left(c + G(d, a, b) + x[11] + 0x265e5a51, 14);
        b = c + rotate_left(b + G(c, d, a) + x[0] + 0xe9b6c7aa, 20);
        a = b + rotate_left(a + G(b, c, d) + x[5] + 0xd62f105d, 5);
        d = a + rotate_left(d + G(a, b, c) + x[10] + 0x02441453, 9);
        c = d + rotate_left(c + G(d, a, b) + x[15] + 0xd8a1e681, 14);
        b = c + rotate_left(b + G(c, d, a) + x[4] + 0xe7d3fbc8, 20);
        a = b + rotate_left(a + G(b, c, d) + x[9] + 0x21e1cde6, 5);
        d = a + rotate_left(d + G(a, b, c) + x[14] + 0xc33707d6, 9);
        c = d + rotate_left(c + G(d, a, b) + x[3] + 0xf4d50d87, 14);
        b = c + rotate_left(b + G(c, d, a) + x[8] + 0x455a14ed, 20);
        a = b + rotate_left(a + G(b, c, d) + x[13] + 0xa9e3e905, 5);
        d = a + rotate_left(d + G(a, b, c) + x[2] + 0xfcefa3f8, 9);
        c = d + rotate_left(c + G(d, a, b) + x[7] + 0x676f02d9, 14);
        b = c + rotate_left(b + G(c, d, a) + x[12] + 0x8d2a4c8a, 20);

        // Round 3
        a = b + rotate_left(a + H(b, c, d) + x[5] + 0xfffa3942, 4);
        d = a + rotate_left(d + H(a, b, c) + x[8] + 0x8771f681, 11);
        c = d + rotate_left(c + H(d, a, b) + x[11] + 0x6d9d6122, 16);
        b = c + rotate_left(b + H(c, d, a) + x[14] + 0xfde5380c, 23);
        a = b + rotate_left(a + H(b, c, d) + x[1] + 0xa4beea44, 4);
        d = a + rotate_left(d + H(a, b, c) + x[4] + 0x4bdecfa9, 11);
        c = d + rotate_left(c + H(d, a, b) + x[7] + 0xf6bb4b60, 16);
        b = c + rotate_left(b + H(c, d, a) + x[10] + 0xbebfbc70, 23);
        a = b + rotate_left(a + H(b, c, d) + x[13] + 0x289b7ec6, 4);
        d = a + rotate_left(d + H(a, b, c) + x[0] + 0xeaa127fa, 11);
        c = d + rotate_left(c + H(d, a, b) + x[3] + 0xd4ef3085, 16);
        b = c + rotate_left(b + H(c, d, a) + x[6] + 0x04881d05, 23);
        a = b + rotate_left(a + H(b, c, d) + x[9] + 0xd9d4d039, 4);
        d = a + rotate_left(d + H(a, b, c) + x[12] + 0xe6db99e5, 11);
        c = d + rotate_left(c + H(d, a, b) + x[15] + 0x1fa27cf8, 16);
        b = c + rotate_left(b + H(c, d, a) + x[2] + 0xc4ac5665, 23);

        // Round 4
        a = b + rotate_left(a + I(b, c, d) + x[0] + 0xf4292244, 6);
        d = a + rotate_left(d + I(a, b, c) + x[7] + 0x432aff97, 10);
        c = d + rotate_left(c + I(d, a, b) + x[14] + 0xab9423a7, 15);
        b = c + rotate_left(b + I(c, d, a) + x[5] + 0xfc93a039, 21);
        a = b + rotate_left(a + I(b, c, d) + x[12] + 0x655b59c3, 6);
        d = a + rotate_left(d + I(a, b, c) + x[3] + 0x8f0ccc92, 10);
        c = d + rotate_left(c + I(d, a, b) + x[10] + 0xffeff47d, 15);
        b = c + rotate_left(b + I(c, d, a) + x[1] + 0x85845dd1, 21);
        a = b + rotate_left(a + I(b, c, d) + x[8] + 0x6fa87e4f, 6);
        d = a + rotate_left(d + I(a, b, c) + x[15] + 0xfe2ce6e0, 10);
        c = d + rotate_left(c + I(d, a, b) + x[6] + 0xa3014314, 15);
        b = c + rotate_left(b + I(c, d, a) + x[13] + 0x4e0811a1, 21);
        a = b + rotate_left(a + I(b, c, d) + x[4] + 0xf7537e82, 6);
        d = a + rotate_left(d + I(a, b, c) + x[11] + 0xbd3af235, 10);
        c = d + rotate_left(c + I(d, a, b) + x[2] + 0x2ad7d2bb, 15);
        b = c + rotate_left(b + I(c, d, a) + x[9] + 0xeb86d391, 21);

        state[0] += a;
        state[1] += b;
        state[2] += c;
        state[3] += d;

        // 清理局部变量
        memset(x, 0, sizeof(x));
    }

    void decodeBlock(const uint8 block[64], uint32 x[16]) {
        // MD5 使用小端（little-endian）将 64 字节块分解为 16 个
        // 32-bit 值
        for (int i = 0; i < 16; ++i) {
            x[i] = (uint32)block[i * 4] |
                   (uint32)block[i * 4 + 1] << 8 |
                   (uint32)block[i * 4 + 2] << 16 |
                   (uint32)block[i * 4 + 3] << 24;
        }
    }

    void encodeBits(uint8 output[8]) {
        // 输出 bit 计数（小端）
        uint64_t bits = ((uint64_t)count[1] << 32) | count[0];
        for (int i = 0; i < 8; ++i) {
            output[i] = (uint8)(bits & 0xFF);
            bits >>= 8;
        }
    }

    void encodeState(uint8 digest[16]) {
        for (int i = 0; i < 4; ++i) {
            digest[i * 4] = (uint8)(state[i] & 0xFF);
            digest[i * 4 + 1] = (uint8)((state[i] >> 8) & 0xFF);
            digest[i * 4 + 2] = (uint8)((state[i] >> 16) & 0xFF);
            digest[i * 4 + 3] = (uint8)((state[i] >> 24) & 0xFF);
        }
    }

private:
    uint32 state[4];
    uint32 count[2];   // bit count, low-order then high-order
    uint8 buffer[64];
};

// 公有接口：返回 16 字节 MD5 摘要
std::vector<uint8> md5_raw(const std::string& s) {
    MD5 ctx;
    ctx.update(reinterpret_cast<const uint8*>(s.data()), s.size());
    uint8 digest[16];
    ctx.finalize(digest);
    return std::vector<uint8>(digest, digest + 16);
}

// 将 MD5 前 4 字节按大端合并成 uint32
unsigned int md5_to_uint(const std::string& s) {
    auto d = md5_raw(s);
    // d[0]..d[15] 是小端编码的 MD5 输出（因为 encodeState 按小端写
    // state） 我们取前 4 个字节（d[0]..d[3]）并按大端解释为
    // uint32（通常便于作为哈希环位置）
    unsigned int x = (static_cast<unsigned int>(d[0]) << 24) |
                     (static_cast<unsigned int>(d[1]) << 16) |
                     (static_cast<unsigned int>(d[2]) << 8) |
                     (static_cast<unsigned int>(d[3]));
    return x;
}

// 简单的十六进制输出帮助函数（用于验证）
std::string md5_hex(const std::string& s) {
    auto d = md5_raw(s);
    static const char* hex = "0123456789abcdef";
    std::string out;
    out.reserve(32);
    for (int i = 0; i < 16; ++i) {
        out.push_back(hex[(d[i] >> 4) & 0xF]);
        out.push_back(hex[d[i] & 0xF]);
    }
    return out;
}
```
```C++ [md5.h]
#pragma once
#include <string>

unsigned int md5_to_uint(const std::string& s);
std::string md5_hex(const std::string& s);
```
:::
