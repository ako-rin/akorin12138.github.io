---
layout: post
title: 回溯算法
date: 2025-09-11 10:10:39
tags:
  - 算法
  - 二叉树
  - 编程
  - C++
cover: 'https://pic.akorin.icu/20250911101441807.webp'
codeHeightLimit: 500
toc: true
time_warning: false
end: false
updated: '2025-09-11 23:39:13'
---

# 回溯算法

回溯算法（Backtracking）是一种通过试探并在失败时回退的搜索算法，常用于解决组合、排列、子集、图遍历、约束满足等问题。它的核心思想是：

1. 选择：尝试某个候选解。
2. 约束：判断当前选择是否满足条件。
3. 回溯：若不满足条件，撤销选择（回退一步），继续尝试其他可能。

可以理解为在一棵“状态树”上进行 深度优先搜索（DFS），遇到死胡同时就回到上一步继续探索。

有两种解空间：
- 子集树
- 排列数

<!-- more -->

## 子集树

在递归过程中，记录每一层的选择，从而记录递归时的路径。

当遍历所有的节点后（包括非叶子节点），时间复杂度应为 $2^n$ ，其中 n 为数组元素的个数。

**可以看作成一个二叉树，往左是选择，往右是不选择**

![图源https://algo.itcharge.cn/07_algorithm/07_04_backtracking_algorithm/#_5-1-%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98-%E5%AD%90%E9%9B%86](https://pic.akorin.icu/20250911200714940.webp)

:::code-group
```C++ [子集树模板]
int length = sizeof(arr) / sizeof(arr[0]);
void fun(int arr[], int x[] ,int i) {
    if (i == length) {
        // 到达底层
        
        // 打印子集树
          for (int j = 0; j < length; ++k) {
              if (x[j] == 1) {
                  cout << arr[j];
              }
          }
        // 也可以直接指定某个子集来完成逻辑

    } else {
        // 向左
        x[i] = 1;
        fun(arr, x, i + 1);

        // 向右
        x[i] = 0;
        fun(arr, x, i + 1);
    }
}
```
```C++ [eg.整数选择问题]
// 给定一组整数，从里面挑选出一组整数，让选择的整数的和，和剩下的整数的和的差最小
int arr[10] = {...};
int length = sizeof(arr) / sizeof(arr[0]);
int sum = 0;  // 选择的数之和
// 把所有的数加起来，去掉选择的数后，剩下来的数就是未选择的数之和
int rsum = std::accumulate(arr, std::end(arr), 0); // 未选择的数之和
unsigned int min = 0xffffffff; // 最小的差
int best[length] = {0}; // 记录最佳的序列满足题意
int x[length] = {0}; // 记录递归遍历过程中，选择的方向。
void fun(int arr[], int i) {
    if (i == length) {
        // 遍历完某个路径，尝试更新最小的差值
        int res = abs(sum - rsum);
        if (res < min) {
            min = res;
        }
        for (int j = 0; j < length; ++j) {
            best[j] = x[j]; // 记录当前最佳选择的数
        }
    } else {
        // 向左
        x[i] = 1;
        sum += arr[i];
        rsum -= arr[i];
        fun(arr, i + 1); // 选择i节点

        // 向右
        x[i] = 0;
        sum -=  arr[i];
        rsum += arr[i];
        fun(arr, i + 1); // 不选择i节点
    }
}

int main() {
    ... 
    fun(arr, 0);
    for (int i = 0; i < length; ++i) {
        if (best[i] == 1) {
            // 打印最佳选择的数
            cout << arr[i];
        }
    }
    return 0;
}
```
:::

### 子集树剪枝操作

子集树遍历过程中，遍历每一个叶子节点会导致效率不高，因此在遍历过程中可以判定是否需要继续深度遍历。

#### 2N整数选择问题

2N整数选择问题：给定2n个整数，从中挑选n个整数，让选择的整数和与剩下的整数和之差最小

:::code-group
```C++ [2N整数选择问题]
// 2N整数选择问题：给定2n个整数，从中挑选n个整数，让选择的整数和与剩下的整数和之差最小

// 用向量存取临时数据要方便一点，就不用x[i]来判定是往左还是往右了
std::vector<int> arr[10] = {...};
std::vector<int> x[10] = {0};
std::vector<int> best[10] = {0};
int length = arr.size();

int leftcnt = length; // 记录未处理数字的个数

int sum = 0;
int rsum = std::accumulate(arr.begin(), arr.end(), 0);

void fun(int i) {

    if (i == length) {
        // 剪枝：到达叶子节点时选择的数还没到一半就继续遍历
        if (x.size() != length / 2) {   // [!code ++]
            return; // [!code ++]
        }   // [!code ++]

        int res = abs(sum - rsum);
        if (res < min) {
            min = res;
            best = x;
        }
    } else {
        leftcnt--; // [!code ++]
        // 剪枝：只有选择的个数小于一半时才去选择，多选择的就没必要再遍历了
        if (x.size() < length / 2) {     // [!code ++]
            x.push_back(arr[i]);
            sum += arr[i];
            rsum -= arr[i];
            fun(i + 1); // 遍历左孩子，记录当前的值表示选择

            x.pop_back();
            sum -= arr[i];
            rsum += arr[i];
        }    // [!code ++]
        // 右树枝也可以剪枝：已选择的数字个数+未来能选择的所有数字个数(i+1,i+2...n)>=n个元素
        if (x.size() + leftcnt >= length / 2) {
            fun(i + 1); // 遍历右孩子，不要当前的数
        }
        // 当前i节点处理完成，回溯到父节点
        leftcnt++; // [!code ++]
    }
}

```
:::

#### 挑选数字问题

在数组中挑选一系列的数字，使它们的和等于指定的数。

:::code-group
```C++ [选数字问题]
// 在数组中挑选一系列的数字，使它们的和等于指定的数

std::vector<int> arr[10] = {...};
std::vector<int> x[10] = {0};
std::vector<int> best[10] = {0};
int length = arr.size();

int leftcnt = length; // 记录未处理数字的个数

int sum = 0;
int rsum = std::accumulate(arr.begin(), arr.end(), 0); // 未处理的数之和
int num = ...;

void func(int i) {
    if (i == length) {
        if (sum == num) {
            best = x;
            for (auto it : best) {
                std::cout << it << " ";
            }
            std::cout << std::endl;
        }
    } else {
        rsum -= arr[i];  // [!code ++] 未处理的数之和
        if (sum + arr[i] <= num) {
            sum += arr[i];
            x.push_back(arr[i]);
            func(i + 1);
            // 不选择当前的数
            sum -= arr[i];
            x.pop_back();
        }
        // 剪右树枝
        if (sum + rsum >= num) { // [!code ++] 
            func(i + 1);
        } // [!code ++] 
        // 此时回溯到父节点，处理的数加回去变未处理
        rsum += arr[i]; // [!code ++] 
    }
}
```
```C++ [更高效的算法]
void func(int i, int num) {
    if (num == 0) {   // [!code ++]
        std::cout << "找到可凑出的数" << std::endl;
        for (auto v : best) {
            std::cout << v << " ";
        }
        std::cout << std::endl;
    } else {
        // 从当前节点开始，把剩余元素的孩子节点生成
        // 不用再重复的遍历前面已遍历过的元素
        for (int j = i; j < length; ++j) {  // [!code ++] 
            if (arr[j] <= num) {  // [!code ++]  当前要存的数小于要接近的数才行
                best.push_back(arr[j]);  // [!code ++] 
                func(j + 1, num - arr[j]);   // [!code ++] 
                // 下面这个是可以重复选择同样的数，如：4 4 4 3， 4 4 1 2， 4 4 4 4
                // func(j, num - arr[j]);   // [!code ++] 
                 // [!code ++]  包含当前元素的所有可能遍历结束
                best.pop_back();  // [!code ++] 
            }  // [!code ++] 
        }  // [!code ++] 
    }
}
```
:::

其中更高效的算法中，巧妙地避免了前面已经处理过的数。包含了前面的数处理过了，后面就没必要再重新处理了，可以节省很多时间。

![](https://pic.akorin.icu/20250911200746555.webp)

![](https://pic.akorin.icu/20250911201313799.webp)

#### 背包问题

背包问题，有n个物品，不同物品不同重量且不同价值，指定某个容量下的最大价值配比。

```C++ 
int w[] = {12, 3, 8, 9, 6};   // 物品重量
int v[] = {9, 11, 4, 7, 8};   // 物品价值
const int len = sizeof(w) / sizeof(w[0]);
std::vector<int> sel;                         // 选择的物品
int c = 20;                                   // 背包容量
int r = std::accumulate(v, std::end(v), 0);   // 剩余总价值
int cw = 0;                                   // 已选择物品的重量
int cv = 0;                                   // 已选择物品的价值

unsigned int bestv = 0;

void func(int i) {
    // 背包问题，有n个物品，不同物品不同重量且不同价值，指定某个容量下的最大价值配比。
    if (i == len) {
        // 到达叶子节点
        if (cv > bestv) {
            bestv = cv;
            std::cout << "此时的价值为： " << bestv << std::endl;
            for (auto v : sel) {
                std::cout << v << " ";
            }
            std::cout << std::endl;
        }
    } else {
        // 左剪枝
        if (cw + w[i] <= c) {
            // 选择物品的重量加上即将处理的物品的重量小于背包容量才能选择
            cw += w[i];
            cv += v[i];
            sel.push_back(w[i]);
            func(i + 1);

            sel.pop_back();
            // 没有选择该物品
            cw -= w[i];
            cv -= v[i];
        }
        // 右剪枝
        if (cv + r > bestv) {
            // 只有剩余价值加上当前积累价值大于最大价值才值得继续遍历
            func(i + 1);
        }
    }
}
```

## 排列树

**从 n 个不同元素中，取出所有元素，按照顺序排列** 的一种树形表示方法。

每一条从 **根节点到叶子节点的路径**，对应一个排列。  

换句话说，排列树就是把所有 **全排列** 的生成过程，形象化为一棵树。

```
               (root)
           /     |     \
         1       2      3
       /  \     / \    /  \
      2    3   1  3   1   2
     /    /   /  /   /   /
    3    2  3   2   2   1

```

:::code-group
```C++ [排列树模板]
int vec[5] = {1 ,2 ,3 ,4 ,5};
int len = sizeof(vec) / sizeof(vec[0]);

void swap(int arr[], int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
void func(int arr[], int i) {
    if (i == len) {
        // 到达叶子节点
        for (auto v : vec) {
            std::cout << v << " ";
        }
        std::cout << std::endl;
    } else {
        for (int j = i; j < len; ++j) {
            swap(arr, i, j);
            func(arr, i + 1);
            swap(arr, i ,j);
        }
    }
}
```
:::

在代码中主要通过两个元素的交换，来实现不同的排列。

### N皇后问题

比较经典的就是8皇后问题：皇后会吃点她直线或斜线上的敌人。

现在棋盘上有8个皇后，要怎么摆才不能让互相她们吃掉。

:::code-group
```C++ [交换法排列树]
// 把ar数组的下标当作行，下标对应的元素的值当作列
int ar[] = {1, 2, 3, 4, 5, 6, 7, 8};
int len = sizeof(ar) / sizeof(ar[0]);
int n = 8;
void swap(int i, int j) {
    int temp = ar[i];
    ar[i] = ar[j];
    ar[j] = temp;
}

bool judge(int i) {
    // 当前的皇后和前面的皇后进行比较
    for (int j = 0; j < i; ++j) {
        // i == j：同行
        // ar[i] == ar[j]：同列
        // i - j == ar[i] - ar[j]：同斜线
        if (i == j || ar[i] == ar[j] ||
            std::abs(i - j) == std::abs(ar[i] - ar[j])) {
            return false;
        }
    }
    return true;
}

void func(int i) {
    // 8皇后
    if (i == len) {
        // 叶子节点
        for (auto v : ar) {
            std::cout << v << " ";
        }
        std::cout << std::endl;
    } else {
        for (int j = i; j < len; ++j) {
            swap(i, j);
            if (judge(i)) {
                func(i + 1);
            }
            swap(i, j);
        }
    }
}
```
```C++ [穷举法排列树]
std::vector<bool> state(len, false);
std::vector<int> vec;
bool judge(int i) {
    // 当前的皇后和前面的皇后进行比较
    for (int j = 0; j < i; ++j) {
        // i == j：同行
        // vec[i] == vec[j]：同列
        // i - j == vec[i] - vec[j]：同斜线
        if (i == j || vec[i] == vec[j] ||
            std::abs(i - j) == std::abs(vec[i] - vec[j])) {
            return false;
        }
    }
    return true;
}
void func(int i) {
    // 8皇后
    if (i == len) {
        // 叶子节点
        for (auto v : vec) {
            std::cout << v << " ";
        }
        std::cout << std::endl;

    } else {
        for (int j = 0; j < len; ++j) {
            if (!state[j]) {
                state[j] = true;
                vec.push_back(ar[j]);
                if (judge(i)) {
                    func(i + 1);
                }
                vec.pop_back();
                state[j] = false;
            }
        }
    }
}
```
:::

穷举法获取排列树时，需要记录状态，看是否已经走过。`state[j]` 表示某个候选元素 `ar[j]` 是否已经被使用过（避免重复选择）。
