[{"title":"","tags":[],"categories":[],"author":"akorin","excerpt":"","link":"/404","content":"","cover":"","date":""},{"title":"相册","tags":[],"categories":[],"author":"akorin","excerpt":"\n\n","link":"/album","content":"\n\n","cover":"","date":""},{"title":"关于我","tags":[],"categories":[],"author":"akorin","excerpt":"\n---","link":"/about","content":"\n---","cover":"","date":""},{"title":"关于站点","tags":[],"categories":[],"author":"akorin","excerpt":"\n基于Valaxy + valaxy-theme-yun 搭建的博客\n\n- Default Theme: [valaxy-theme-yun](https://github.com/YunYouJun","link":"/about/site","content":"\n基于Valaxy + valaxy-theme-yun 搭建的博客\n\n- Default Theme: [valaxy-theme-yun](https://github.com/YunYouJun/valaxy/blob/main/packages/valaxy-theme-yun/)\n","cover":"","date":""},{"title":"","tags":[],"categories":[],"author":"akorin","excerpt":"","link":"/albums","content":"","cover":"","date":""},{"title":"Bangumi 追番列表","tags":[],"categories":[],"author":"akorin","excerpt":"","link":"/anime","content":"","cover":"https://pic.akorin.icu/illust_91407736_20211108_230426.jpg","date":""},{"title":"归档","tags":[],"categories":[],"author":"akorin","excerpt":"","link":"/archives","content":"","cover":"https://pic.akorin.icu/cover_achive.jpg","date":""},{"title":"分类","tags":[],"categories":[],"author":"akorin","excerpt":"","link":"/categories","content":"","cover":"https://pic.akorin.icu/cover_cata.jpg","date":""},{"title":"留言板","tags":[],"categories":[],"author":"akorin","excerpt":"","link":"/comment","content":"","cover":"https://pic.akorin.icu/illust_119159339_20241022_013213.png","date":""},{"title":"友联板","tags":[],"categories":[],"author":"akorin","excerpt":"","link":"/links","content":"","cover":"","date":""},{"title":"Dev Notes","tags":[],"categories":[],"author":"akorin","excerpt":"\nHow about writing some dev notes?","link":"/notes","content":"\nHow about writing some dev notes?","cover":"","date":""},{"title":"51单片机编程","tags":["笔记","51单片机","C"],"categories":["笔记"],"author":"akorin","excerpt":"\n51单片机主要使用的函数\n\n","link":"/posts/51microcopmuter","content":"\n51单片机主要使用的函数\n\n<!-- more -->\n\n## 定时器&中断\n- 定时器\n  - Timer0\n  - Timer1\n- 定时模式\n  - 模式0：13位定时/计数器\n  - 模式1：16位定时/计数器\n  - 模式2：8位自动重载/定时计数器\n  - 模式3：仅限定时器0，Timer0分为两个8位计数器\n- 中断\n  - 外部中断0，使用中断号0\n  - 定时中断0，使用中断号1\n  - 外部中断1，使用中断号2\n  - 定时中断1，使用中断号3\n  - 串口中断\n\n> **计算定时时间公式**\n\n$$\n(2^{16}-X)\\times \\frac{12}{f_n}=Time\n$$\n\n> 其中X为定时器初始计数值（填装进Tlx，Thx寄存器）， $f_n$ 为晶振频率\n\n\n:::code-group\n<<< @/code/C/51/51withTimer.c{c}[51单片机定时器及外部中断设计]\n:::\n\n## 写内部FLASH\n\nSTC89C52/AT89C52内部FLASH扇区地址：\n\n| 第一扇区    | 第二扇区    | 第三扇区    | 第四扇区    |\n| ----------- | ----------- | ----------- | ----------- |\n| 2000h~21FFh | 2200h~23FFh | 2400h~25FFh | 2600h~27FFh |\n\n| 第五扇区    | 第六扇区    | 第七扇区    | 第八扇区    |\n| ----------- | ----------- | ----------- | ----------- |\n| 2800h~29FFh | 2A00h~2BFFh | 2C00h~2DFFh | 2E00h~2FFFh |\n\n- 操作模式\n  - 0x00: 空闲\n  - 0x01: 读出\n  - 0x02: 写入\n  - 0x03: 擦除\n- 操作流程：\n\n\n<center>\n\n```mermaid\n\nstateDiagram\n\n  设定ISP等待时间 --> 设定ISP模式\n  设定ISP模式 --> 设定ISP操作地址\n  设定ISP操作地址 --> 关闭全局定时器\n  关闭全局定时器 --> ISP_TRIG寄存器存入0x46\n  ISP_TRIG寄存器存入0x46 --> ISP_TRIG寄存器存入0xB9\n  ISP_TRIG寄存器存入0xB9 --> 等待一个空闲周期\n  等待一个空闲周期 --> 退出ISP模式\n\n```\n</center>\n\n  - 关闭全局定时器是为了确保连续往ISP_TRIG寄存器存入0x46和0xB9，才能使命令生效\n  - 推出ISP模式就是把寄存器ISP_CONTR、ISP_CMD、ISP_TRIG清空\n\n:::code-group\n<<< @/code/C/51/InterFLASH.c{c}[内部FLASH读取设计]\n:::\n\n\n## 驱动数码管\n\n数码管有共阴和共阳的类型，引脚分布从左到右一般对应的是从最上面的灯开始，顺时针数再到中间的灯，最后的是右下角的点。转换成程序来中对应的位为hgfedcba，从高到低排列\n\n数码管结构及引脚如下：\n```\n###     a\n# #  f     b\n###     g\n# #  e     c\n### .   d     h\n```\n\n因此以共阳极的数码管为例，驱动数字为1时，应往引脚传输的电平为:11111001，对应十六进制为0xF9\n\n:::code-group\n<<< @/code/C/51/LEDMatrix.c{c}[数码管驱动]\n:::\n","cover":"https://pic.akorin.icu/20250315185018179.png","date":"2025-03-15 00:00:00"},{"title":"AVL树","tags":["算法","二叉树","AVL树","编程","C++"],"categories":["算法"],"author":"akorin","excerpt":"\n# AVL树\n\nAVL树是一种自平衡二叉查找树（BST），由Adelson-Velsky和Landis提出，在任意一个节点上，左子树和右子树的高度差不超过1，从而保证整棵树的高度始终维持在 O(log n) 级别。\n\n相比普通二叉查找树，AVL树在最坏情况下也能高效完成查找、插入和删除操作，但由于需要频繁旋转，它在插入/删除频繁的场景下性能可能不如红黑树。\n\n","link":"/posts/AVL%E6%A0%91","content":"\n# AVL树\n\nAVL树是一种自平衡二叉查找树（BST），由Adelson-Velsky和Landis提出，在任意一个节点上，左子树和右子树的高度差不超过1，从而保证整棵树的高度始终维持在 O(log n) 级别。\n\n相比普通二叉查找树，AVL树在最坏情况下也能高效完成查找、插入和删除操作，但由于需要频繁旋转，它在插入/删除频繁的场景下性能可能不如红黑树。\n\n<!-- more -->\n\n## AVL的平衡旋转\n\n左旋转和右旋转指该节点旋转到其孩子的左孩子或右孩子。\n\nAVL树为了维护节点平衡引入的四种节点旋转操作：\n\n1. **右旋转操作：** 左孩子的左子树太高了，需要右旋。\n    ![](https://pic.akorin.icu/20250902180720750.webp)\n    ``` \n    LL（左左）失衡：对 A 右旋\n      Before:             After (RightRotate A):\n              A                    B\n            /   \\                /   \\\n          B     T3     ==>     C      A\n          / \\                 / \\    / \\\n        C   T2               T0 T1  T2 T3\n      /  \\\n    T0    T1\n    ```\n2. **左旋转操作：** 右孩子的右子树太高了，需要左旋。\n    ![](https://pic.akorin.icu/20250902180739356.webp)\n    ```\n    RR（右右）失衡：对 A 左旋\n      Before:             After (LeftRotate A):\n            A                      B\n          /   \\                  /   \\\n        T0    B       ==>      A      C\n            /   \\             / \\    / \\\n          T1     C           T0 T1  T2 T3\n                / \\\n              T2  T3\n    ```\n3. **左平衡操作：** 左孩子的右子树太高了，需要先左旋板成第一种情况，然后再右旋。\n    ![](https://pic.akorin.icu/20250902202744510.webp)\n    ```\n    LR（左右）失衡：先左旋 B，再右旋 A\n      Before:            中间（左旋 B）：       After:\n          A                    A                 C\n        /   \\                /   \\             /   \\\n       B    T4   ==>        C    T4   ==>     B     A\n      / \\                  / \\               / \\   / \\\n    T0   C                B  T2            T0  T1 T2  T4\n        /  \\             / \\\n      T1    T2         T0   T1\n\n    ```\n4. **右平衡操作：** 右孩子的左子树太高了，需要先右旋扳成第二种情况，然后再左旋。\n    ![](https://pic.akorin.icu/20250902202817931.webp)\n    ```\n    RL（右左）失衡：先右旋 B，再左旋 A\n      Before:            中间（右旋 B）：      After:\n        A                   A                    C\n      /   \\               /   \\                /   \\\n    T0     B      ==>   T0     C     ==>     A      B\n          /  \\                /  \\           / \\   / \\\n        C    T4             T1    B        T0  T1 T2  T4\n        / \\                      / \\\n      T1 T2                    T2  T4\n    ```\n\n:::code-group\n```C++ [旋转平衡]\n// 右旋转操作\n// 以node为轴做右旋转操作，把新的根节点返回\nNode* rightRotate(Node* node) {\n    // 节点旋转\n    Node* child = node->left_;\n    node->left_ = child->right_;\n    child->right_ = node;\n    // 更新高度，因为child的高度依赖node（child变成node的根节点）\n    // 先更新node再更新child\n    node->height_ =\n        max(getHeight(node->left_), getHeight(node->right_)) + 1;\n    child->height_ =\n        max(getHeight(child->left_), getHeight(node->right_)) + 1;\n    return child;\n}\n// 左旋转操作\n// 以node为轴做左旋转操作，把新的根节点返回\nNode* leftRotate(Node* node) {\n    // 节点旋转\n    Node* child = node->right_;\n    node->right_ = child->left_;\n    child->right_ = node;\n    // 更新高度，因为child的高度依赖node（child变成node的根节点）\n    // 先更新node再更新child\n    node->height_ =\n        max(getHeight(node->left_), getHeight(node->right_)) + 1;\n    child->height_ =\n        max(getHeight(child->left_), getHeight(node->right_)) + 1;\n    return child;\n}\n\n// 左平衡操作\nNode* leftBalance(Node* node) {\n    node->left_ = leftRotate(node->left_);\n    return rightRotate(node);\n}\n// 右平衡操作\nNode* rightBalance(Node* node) {\n    node->right_ = leftRotate(node->right_);\n    return leftRotate(node);\n}\n\n```\n```C++ [AVL节点定义]\nstruct Node {\n    Node(T data) :\n        data_(data),\n        left_(nullptr),\n        right_(nullptr),\n        height_(0) {}\n    T data_;\n    Node* left_;\n    Node* right_;\n    int height_;   // 节点高度\n};\n```\n:::\n\n## AVL的插入\n\n1. 在普通的BST树的插入的回溯上，插入平衡旋转的代码。\n2. 回溯后比较左右孩子的高度。\n3. 若左右孩子高度差大于1，说明此时不平衡，需要旋转平衡操作。\n4. 此时分类属于哪种不平衡的情况（LL、LR、RL、RR）。\n5. 插入过后更新每一层的高度。\n\n```C++ \n// 插入\nvoid insert(const T& val) {\n    root_ = insert(root_, val);\n}\nNode* insert(Node* node, const T& val) {\n    // 到达要插入位置\n    if (!node) {\n        return new Node(val);\n    }\n    if (val < node->data_) {\n        // 递归时执行的代码\n        node->left_ = insert(node->left_, val);\n        // 回溯时执行的代码\n        // 在插完后判断是否失衡，插左边肯定左边更高一点\n        if (getHeight(node->left_) - getHeight(node->right_) >\n            1) {\n            // 左孩子的左子树太高 LL\n            if (getHeight(node->left_->left_) >=\n                getHeight(node->left_->right_)) {\n                // 不在这里返回节点，而是在后面更新完高度再返回\n                node = rightRotate(node);\n            } else {\n              // LR\n                node = leftBalance(node);\n            }\n        }\n    } else if (val > node->data_) {\n        // 递归时执行的代码\n        node->right_ = insert(node->right_, val);\n        // 回溯时执行的代码\n        // 在插完后判断是否失衡，插右边肯定右边更高一点\n        if (getHeight(node->right_) - getHeight(node->left_) >\n            1) {\n            // 右孩子的右子树太高 RR\n            if (getHeight(node->right_->right_) >=\n                getHeight(node->right_->left_)) {\n                node = leftRotate(node);\n            } else {\n              // RL\n                node = rightBalance(node);\n            }\n        }\n    } else {\n        // 相同则直接回溯，不插重复值\n        return node;\n    }\n    // 插入了新的节点，更新当前节点的高度\n    node->height_ =\n        max(getHeight(node->left_), getHeight(node->right_)) + 1;\n    return node;\n}\n```\n\n## AVL的删除\n\n删除与插入最大的不同：插入只可能在回溯路径上的某个节点触发至多一次（或少量）失衡修复；删除会让路径高度下降，可能在多层连续触发再平衡。因此删除阶段的“回溯 + 多次检测”尤为关键。\n\n步骤（结合你的 `remove` 实现）：\n\n1. 常规 BST 定位  \n   递归向左或向右查找目标值 `val`，直到找到要删除的节点或遇到空指针返回。\n\n2. 处理删除的三种结构情况  \n   - 叶子节点（无孩子）：直接删除，返回 `nullptr`。  \n   - 仅有一个孩子：用其非空孩子替换当前节点，删除当前节点。  \n   - 有两个孩子：  \n      **“谁高删谁”** 策略：  \n       a. 若左子树高度 > 右子树高度：找前驱（左子树最右节点），用其值覆盖当前节点，再递归删除前驱节点。  \n       b. 否则：找后继（右子树最左节点），用其值覆盖当前节点，再递归删除后继节点。  \n     这样做的目标是尽量保持整体高度不增，从而减少潜在旋转次数。\n\n3. 回溯阶段更新高度  \n   递归返回时，对沿途节点重新计算：  \n   `height = max(height(left), height(right)) + 1`  \n   （注意：如果你在旋转函数内部已经更新了局部高度，旋转完再统一更新当前返回节点也无妨，保持一致即可。）\n\n4. 删除后检测是否失衡  \n   使用：`bf = height(left) - height(right)`  \n   - `bf > 1` 左侧过高  \n   - `bf < -1` 右侧过高\n\n5. 分类具体失衡类型  \n   删除后产生的失衡方向与插入判断逻辑对称，但判别“单旋 / 双旋”依赖子孩子的“靠外”与“靠内”子树高度：  \n   - 左侧失衡 (`bf > 1`):  \n     - 若 `height(left.left) >= height(left.right)` → **LL 型**：单右旋  \n     - 否则 → **LR 型**：先对 `left` 左旋，再对当前节点右旋  \n   - 右侧失衡 (`bf < -1`):  \n     - 若 `height(right.right) >= height(right.left)` → **RR 型**：单左旋  \n     - 否则 → **RL 型**：先对 `right` 右旋，再对当前节点左旋\n\n6. 旋转平衡  \n   执行所需的（单/双）旋转操作，获得新的子树根节点。旋转内部需正确维护被移动节点与新根节点的高度。\n\n7. 返回新的子树根  \n   每一层完成（更新高度 + 可能的旋转）后返回当前子树根节点供上层继续使用。\n\n```C++ \n// 删除\nNode* remove(Node* node, const T& val) {\n    if (!node)\n        return nullptr;\n    if (val < node->data_) {\n        node->left_ = remove(node->left_, val);\n        // 左子树删除节点后可能造成右子树太高\n        if (getHeight(node->right_) - getHeight(node->left_) > 1) {\n            if (getHeight(node->right_->right_) >\n                getHeight(node->right_->left_)) {\n                // RR\n                node = leftRotate(node);\n            } else {\n                // RL\n                node = rightBalance(node);\n            }\n        }\n    } else if (val > node->data_) {\n        node->right_ = remove(node->right_, val);\n        // 右子树删除节点后可能造成左子树太高\n        if (getHeight(node->left_) - getHeight(node->right_) > 1) {\n            if (getHeight(node->left_->left_) >\n                getHeight(node->left_->right_)) {\n                // LL\n                node = rightRotate(node);\n            } else {\n                // LR\n                node = leftBalance(node);\n            }\n        }\n    } else {\n        // 到达要删除的节点\n        // 先处理情况3\n        if (node->right_ && node->left_) {\n            // 为避免删除前驱/后继造成节点失衡，谁高删谁\n            if (getHeight(node->left_) > getHeight(node->right_)) {\n                // 删前驱\n                Node* cur = node->left_;\n                while (cur->right_) {\n                    cur = cur->right_;\n                }\n                node->data_ = cur->data_;\n                node->left_ = remove(node->left_, cur->data_);\n            } else {\n                // 删后继\n                Node* cur = node->right_;\n                while (cur->left_) {\n                    cur = cur->left_;\n                }\n                node->data_ = cur->data_;\n                node->right_ = remove(node->right_, cur->data_);\n            }\n        } else {\n            // 情况1 / 2\n            Node* child = node->left_ ? node->left_ : node->right_;\n            delete node;\n            return child;\n        }\n    }\n    // 回溯后更新节点高度，只有寻找的这条路径会更新高度\n    // 只有删除有效时才减小高度\n    node->height_ =\n        node ? max(getHeight(node->left_), getHeight(node->right_)) + 1\n              : node->height_;\n\n    return node;\n}\n```\n\n:::warning\n无论是删除节点还是增加节点，最后更新高度都是依靠其孩子的高度来更新， **删除时不要想当然的** `- 1` ：\n\n```C++ \nnode->height_ =\n     max(getHeight(node->left_), getHeight(node->right_)) - 1 // [!code error]\n     max(getHeight(node->left_), getHeight(node->right_)) + 1 // 这才是更新高度\n```\n\n:::\n","cover":"https://pic.akorin.icu/20250901162043571.webp","date":"2025-09-01 14:48:41"},{"title":"B树","tags":["算法","树","B树","数据结构","数据库"],"categories":["算法"],"author":"akorin","excerpt":"\n# B树 (B-Tree)\n\nB 树（Balance Tree / 多路平衡查找树）是一种**多路自平衡搜索树**，广泛应用于数据库与文件系统的索引结构。它通过**把大量有序关键字集中在节点中并尽量减少树高度**，在磁盘 / SSD 的块（page）为单位读取场景下显著降低 I/O 次数。\n\n核心目标：在保持有序字典操作 O(log n) 的同时，把树的高度压低，使得一次查询只需极少磁盘访问。\n\n","link":"/posts/B%E6%A0%91","content":"\n# B树 (B-Tree)\n\nB 树（Balance Tree / 多路平衡查找树）是一种**多路自平衡搜索树**，广泛应用于数据库与文件系统的索引结构。它通过**把大量有序关键字集中在节点中并尽量减少树高度**，在磁盘 / SSD 的块（page）为单位读取场景下显著降低 I/O 次数。\n\n核心目标：在保持有序字典操作 O(log n) 的同时，把树的高度压低，使得一次查询只需极少磁盘访问。\n\n<!-- more -->\n\n## 基本定义与参数\n\n引入两个常见参数：\n\n- 阶 (order) 记为 `m`：一个节点**最多**可以拥有的孩子指针数（即最多 m 个子树）。\n- 最小度数 (minimum degree) 记为 `t`：常见教材用 `t`，与阶的关系：`m = 2t` 或 `m = 2t - 1` 取决于不同实现约定。本文采用 **CLRS 定义**：\n  - 每个非根节点至少有 `t - 1` 个键，至多 `2t - 1` 个键。\n  - 每个非根节点孩子数 ∈ [t, 2t]。\n  - 根节点特殊：可以少于 `t - 1`（当根非叶时，至少 1 个键；当全树只有一个节点它可为空）。\n\n记：\n- 关键字数量范围：`ceil(m/2) - 1 <= keys(node) <= m - 1`（根除外）\n- 孩子指针数：`keys + 1`\n- 节点被填满（满节点 / full node）：`keys == m - 1`\n\n> ceil 表示向上取整。\n\n### 节点结构（逻辑）\n\n```text\n节点:\n  keys[ k1  k2  ...  kk ]  (升序)\n  children[ c0 c1 ... ck ]  (k = keys.length)\n    所有关键字满足:  c0 < k1 < c1 < k2 < c2 < ... < kk < ck\n  leaf 标志: 是否叶子\n```\n\n### 有序性不变量\n对任一节点：\n```\nkeys 升序\nchild i 子树的所有键 ∈ (key_{i}, key_{i+1}) 的开区间（边界视为 -∞/+∞）\n```\n\n## 查找 (Search)\n\n类似多叉二分：在当前节点内先对 keys 做顺序/二分查找找到区间，再沿对应孩子下降。由于节点内的 `keys` 数量 ≤ `2t - 1`，常用 **顺序查找 + 分支预测 + SIMD** 在内存/页内已经足够快；也可以二分。\n\n时间复杂度：`O(h)` = `O(log_t n)`，磁盘 I/O ≈ 高度 `h`。\n\n## 高度估计\n\n最“胖”结构可把 n 关键字压到极低高度。由最小填充情况求上界：\n\n- 除根外每个节点至少有 `t - 1` 个键；根至少 1 个键（非空）。\n- 高度 h（根到叶路径边数）时：\n  - 最少关键字数：`n_min(h) = 1 + (t) * (t) * ... * (t) * (t - 1)`（精确推导更规范如下）\n\n更标准推导：高度 h 的最少关键字数 >= `2 * t^{h} - 1` （根最少 1，下一层起每个节点至少 t 个孩子）。\n\n反向解高度：\n$$ h \\le \\log_t \\frac{n+1}{2} $$\n\n由于 t 较大（一个页往往能放上百个 key），所以 h 极小（常见 2~4）。\n\n## 插入 (Insert)\n\n核心策略：**自顶向下保证不向满节点“继续下探”**，避免回溯复杂度。\n\n步骤：\n1. 若根已满（`2t-1` 键），先分裂根：\n   - 创建新节点 `R'` 做新根\n   - 旧根分裂为两个节点 + 中间 key 上升\n   - 树高度 +1\n2. 从（可能更新后的）根开始向下：\n   - 对当前节点：找到要下降的 child 索引 i。\n   - 如果 child_i 满，先分裂它：\n     - 中间键 `mid` 上升插入当前节点 keys 中\n     - child 分裂成两个节点（左含前 `t-1` 键，右含后 `t-1` 键）\n     - 依据插入的 key 与 `mid` 比较，决定继续走左还是右半部分\n3. 到达叶节点后（必非满），在本地数组中插入目标 key（保持有序）。\n\n这样“**双向不回溯**”：所有分裂都在下降途中完成。\n\n### 分裂示意\n\n假设 t = 3（节点最多 5 个键，满时 5 = 2t-1）：\n\n```\n满节点: [ k0  k1  k2  k3  k4 ]   (5 keys)\n               ^ mid = k2 上升\n左节点: [ k0  k1 ]\n右节点: [ k3  k4 ]\n父插入 k2，并在 k2 左右挂上分裂出的两个孩子。\n```\n\nMermaid（概念化）：\n```mermaid\nflowchart TB\n  A[满: k0 k1 k2 k3 k4] -->|split| P[父节点]\n  P --> L[k0 k1]\n  P --> M((k2 上升))\n  P --> R[k3 k4]\n```\n\n## 删除 (Delete)\n\n删除比插入更繁琐：可能导致节点关键字数量跌破下界 `(t-1)`，需要**借 (borrow)** 或 **合并 (merge)**。同样采用“自顶向下”思想：保证下降到的节点在进入前就至少有 t 个键（从而安全删除其中一个而不至低于 t-1）。\n\n主线：\n1. 若根空（无键且有孩子），直接让唯一孩子成为新根（高度 -1）。\n2. 从根向下定位 key：对当前节点，确保将要进入的 child 在进入前“够格”。\n   - 如果 child 键数 == t-1：\n     - 若相邻兄弟有 ≥ t 键：从兄弟“借”一个（通过父节点旋转键）。\n     - 否则：与兄弟 + 父中的分隔键合并成一个节点（键数 = 2t-1）。\n3. 如果在内部节点命中要删的 key：\n   - 用前驱（左子树最大）或后继（右子树最小）替换，然后递归删除该替换位置的 key。\n   - 或者：若左右子树之一可安全删除直接选路径（实现者策略差异）。\n4. 若在叶子命中：直接删除（此时必满足叶节点 ≥ t 键或下降前已调整）。\n\n### 借与合并图解 (t = 3)\n\n借（兄弟有富余）：\n```\n父:      [   Kp   ]\n        /          \\\n左子: [a b]   右子: [ d e f g ]  (右子 >= t=3 键)\n-- 借一个：右子最左 d 上升为 Kp，Kp 下沉到左子\n父:      [   d   ]\n       /          \\\n左子: [a b Kp] 右子:[ e f g ]\n```\n\n合并（兄弟都仅 t-1 键）：\n```\n父:      [   Kp   x ...]\n        /     \\\n左:[a b] 右:[ c d ]  (皆2 = t-1)\n-- 合并:\n新节点: [ a b Kp c d ] (5 = 2t-1 满)\n父删除 Kp 并去掉右指针\n```\n\n## 与二叉平衡树 (AVL / RBT) 对比\n\n| 维度 | B 树 | 红黑树 | AVL |\n| ---- | ---- | ------ | ---- |\n| 分支因子 | 多路 (几十~上千) | 2 | 2 |\n| 高度 | 极低 (2~4 常见) | O(log n) 较小 | O(log n) 更严格 |\n| 适用存储 | 磁盘 / SSD / Page Cache | 内存 | 内存 |\n| 旋转/结构调整 | 分裂 / 合并 / 借 | 单/双旋 + 变色 | 频繁旋转 |\n| 查找常数因子 | 少层 + 节点内顺序/二分 | 多层 | 多层 |\n| 插入/删除复杂度 | O(log_t n) | O(log n) | O(log n) |\n| 典型应用 | DB 索引、文件系统 | 语言库 map/set | 内存频繁查找 |\n\n## 设计动机与磁盘友好性\n\n- 一个页 4KB，若每个 key+指针 16B，可放 ~256 key（t ≈ 128）。\n- 高度估算：百万级数据 `n=1e6`：`h ≤ log_128((1e6+1)/2) ≈ 3.x`，I/O 仅 3~4 次。\n- 利用**局部性**：一个节点内连续 keys 顺序存放，CPU 缓存与预取友好。\n\n## 常见误区\n\n| 误区 | 更正 |\n| ---- | ---- |\n| B 树 = B-树 = B+ 树 | B+ 树是 B 树的变体（所有数据只在叶子，链表串联叶子）。|\n| 插入必须回溯分裂 | 标准实现自顶向下：先分裂满子节点再下降。|\n| 删除一定很难实现 | 关键在“进入前保证 child >= t”。|\n| t 越大越好 | 过大导致节点内查找代价上升；需权衡页大小/CPU 缓存。|\n| B 树节点一定全满 | 只要求范围约束；满只是极端。|\n","cover":"https://pic.akorin.icu/20250905223311409.webp","date":"2025-09-05 22:30:00"},{"title":"Japan计划！","tags":["计划","日本"],"categories":["旅行计划"],"author":"akorin","excerpt":"\n去霓虹准备的东西以及大致路线、要去圣地巡礼的地点。具体路线根据住宿的位置来决定\n\n","link":"/posts/JapanTravel","content":"\n去霓虹准备的东西以及大致路线、要去圣地巡礼的地点。具体路线根据住宿的位置来决定\n\n<!-- more -->\n\n# 霓虹Plan\n\n## 行前准备\n### 必备证件\n- 护照（直接拿身份证去办）\n- 签证（淘宝代办）\n- 身份证复印件\n\n::: danger\n\n不要带**无磁条**（单芯片）的银联卡（特指新版本的工行卡），ATM机读取不了无磁条的银行卡，但是部分商家POS机（麦当劳等）能够读取单芯片银联卡\n\n:::\n\n### 交通卡与通讯\n- SUICA/PASMO卡（覆盖关东关西）\n- 日本流量卡\n\n### 必备软件\n- agoda/安彼迎（酒店、民宿）\n- Google地图\n\n### 巡礼地图\n- [anitabi](https://anitabi.cn/)\n\n## 机票方案\n### （贵阳→大阪→贵阳）\n|      | 路线           | 时间                    | 价格    | 备注                 |\n| ---- | -------------- | ----------------------- | ------- | -------------------- |\n| 去程 | 贵阳→济南→大阪 | 11:15~20:45+转机        | ￥1940  | 去程和返程机票一起订 |\n| 返程 | 大阪→济南→贵阳 | 21:45~19:05+转机(+1day) | ------- | 在济南多呆一天       |\n\n## 行程路线📅（15天）\n按「城市、作品、地点」分段，标注交通时间与核心体验：\n\n### 关西篇\n#### 大阪\n##### 路线：\n![大阪](https://www.helloimg.com/i/2025/01/30/679b70e66e19d.png)\n- **大致路线**：关西国际机场→大阪城公园→通天阁→道遁窟→心斋桥（紫色路线）\n- **大学**：大阪大学\n\n#### 奈良\n- **大致路线**：奈良公园→春日大社→若草山（可选）\n![屏幕截图 2025-01-30 220625.png](https://www.helloimg.com/i/2025/01/30/679b863c57495.png)\n\n#### 宇治\n##### 圣地巡礼：\n**《京吹》**\n- **《京吹》**：宇治站、宇治桥、大吉山（可选）、宇治站台、京坂黄檗\n##### 路线：\n![宇治](https://www.helloimg.com/i/2025/01/30/679b7649abfc1.png)\n- **大致路线**：宇治站→宇治桥→大吉山（可选）→宇治站台→京坂黄檗→京都府立菟道高等学校\n\n#### 京都\n##### 圣地巡礼：\n**《轻音少女》《玉子市场》**\n- **《玉子市场》**：宇治站、宇治桥、大吉山（可选）、宇治站台、京坂黄檗\n- **《轻音少女》**：豐鄉町立豐鄉小學校\n##### 路线：\n- **大致路线**：黃檗（京阪）→株式会社京都→千本鸟居→伏见稻荷大社→鴨川三角洲→出町桝形商店街\n![屏幕截图 2025-01-30 212247.png](https://www.helloimg.com/i/2025/01/30/679b7bfeb6a9d.png)\n京都市→豐鄉→豐鄉町立豐鄉小學校\n![屏幕截图 2025-01-30 212848.png](https://www.helloimg.com/i/2025/01/30/679b7d5fa7fe9.png)\n### 中部篇\n#### 名古屋\n- **可去地点**：名古屋城\n\n#### 滨松\n##### 圣地巡礼：\n- **《星之梦》**：WINS笠井屋ビル附近\n![屏幕截图 2025-01-30 215548.png](https://www.helloimg.com/i/2025/01/30/679b83a76bb50.png)\n\n#### 静冈\n##### 圣地巡礼：\n- **《摇曳露营》**：富士山本宮淺間大社\n- **可去地点**：三保之松原、富士山本宮淺間大社\n##### 路线：\n![屏幕截图 2025-01-30 215340.png](https://www.helloimg.com/i/2025/01/30/679b833c0afe5.png)\n- **大致路线**：静冈→富士\n- **大学**：静冈大学\n\n### 关东篇\n#### 东京\n##### 圣地巡礼：\n**《少女歌剧》《mygo》《mujica》《GBC》《孤独摇滚》《P5》《我心危》《路人女主》《命运石之门》**\n- **《少女歌剧》**： 品川水族馆、和光本馆、东京塔、芝公园、女神桥\n- **《mygo》**：日本女子大学（羽丘）、サンシャイン60通り交差点、千登世步道桥、千登世小桥、飞鸟山公园\n- **《mujica》**：台场海滨公园\n- **《GBC》**：島村楽器 ラゾーナ川崎店、川崎アゼリア、川崎駅前\n- **《孤独摇滚》**：下北沢\n![guduyaogun.png](https://www.helloimg.com/i/2025/01/30/679b549cefea6.png)\n- **《P5》**：東京都世田谷区三軒茶屋２丁目１４−20\n- **《我心危》**：全家便利店原町二丁目店\n- **《路人女主》**：のぞき坂\n- **《命运石之门》**：秋叶原广播会馆、カフェ メイリッシュ（女仆咖啡厅）\n\n##### 路线：\n![大致路线图](https://www.helloimg.com/i/2025/01/30/679b6348e6b97.png)\n- **大致路线**：横滨→川崎→东京\n- **可去地点**：涩谷Sky、浅草寺、日枝神社（你的名字取景地）\n- **大学**：东京大学、东京工业大学、早稻田大学\n\n#### 镰仓\n##### 路线：\n- **可去地点**：七里ガ浜\n","cover":"https://pic.akorin.icu/conwtz3p.png","date":"2025-01-29 00:00:00"},{"title":"C++学习记录","tags":["学习","编程","C++"],"categories":["笔记"],"author":"akorin","excerpt":"\n## 怎么这么难啊\n在C语言的基础上继续学习CPP\n\n","link":"/posts/gccSimpleLearn","content":"\n## 怎么这么难啊\n在C语言的基础上继续学习CPP\n\n<!-- more -->\n\n## C++基础知识\n\n### C++中函数声明的正确格式：\n\n```C++\n<返回类型> <函数名>(<参数列表>) [const] [其他限定符];\n```\n其中 `const` 可选，后面跟着其他限定符。\n\n### `extern` 的用法\n\n在预编译的过程中，会自动展开头文件。因此定义在头文件的变量就会被多次定义。\n`extern` 关键字用于声明一个变量或函数，使其可以在其他文件中访问，而不在当前文件中分配内存。\n\n::: info 总结\n头文件只做变量的声明，不能做变量的定义\n头文件声明变量可以采用extern的方式\n:::\n\n### 变量作用域\n与C不同C++多了几种作用域。作用域决定了变量的生命周期和可见性。\n\n1. 全局作用域：在函数外部声明变量，一般只在需要的时候才使用，便于代码维护\n2. 局部作用域：在函数内部、 `if` 语句或 `for` 循环内声明的变量。它们只在声明的代码块内被访问。\n3. 命名空间作用域：在命名空间中声明的变量\n4. 类作用域：在类内部声明的变量和成员函数。成员变量和成员函数只能通过类的对象访问，而在某些情况（如静态成员）可以直接通过类名访问。\n5. 块作用域：是局部作用域的一个特例，在函数中额外用大括号 `{}` 来包围的代码块内声明的变量，这些变量只能在代码块内被访问，即使在函数内但是超出代码块也依旧不能访问。\n\n\n:::code-group\n```C++ [命名空间作用域]\nnamespace MyNamespace {\n  int namespaceVar = 10;\n}\n\nint main(){\n  int a = MyNamespace::namespaceVar;\n}\n```\n```C++ [类作用域]\nclass MyClass {\n  public:\n    int classVar;\n}\n\nint main(){\n  MyClass obj;\n  obj.classVar = 10;\n}\n```\n```C++ [块作用域]\nvoid fun() {\n  {\n    int a = 1;\n  }\n  // 下列代码尝试块外访问块内变量会导致编译错误\n  // int b = a;\n}\n```\n:::\n\n### 存储空间\nC++通过存储的数据类型、生命周期和作用域来划分。\n\n1. 代码区（Code Segment/Text Segment）：存储程序执行代码（机器指令）的内存区域，只读，在执行程序时不会改变。\n2. 全局/静态存储区（Global/Static Storage Area）：存储全局变量和静态变量的区域。\n3. 栈区（Stack Segment）：存储局部变量、函数参数、返回地址等的内存区域。栈是后进先出的数据结构，存储函数调用和自动变量。\n4. 堆区（Heap Segment）：由程序员通过动态分配函数（ `new` 或 `malloc` ）分配的内存区域。堆的内存分配和释放是手动的，由程序员需要负责管理的内存，避免内存泄漏或野指针等问题。\n5. 常量区（Constant Area）：存储如字符串常量、 `const` 饰的全局变量的区域，这部分内存也是只读的。在C++中，使用双引号括起来的字符串字面量通常存储在常量区。若 `const` 修饰的全局变量的值在编译时就已确定，则也可能存储在常量区。\n\n:::tip\n`const` 修饰的变量是只读的，编译器处理时一般时直接将 `const` 修饰的变量替换成其初始化的值。默认情况下 `const` 对象被设定为仅在文件内有效，因此当多个文件中出现了同名的 `const` 修饰的变量时，其实相当于在不同的文件中定义了不同的变量。比如filea.c和fileb.c都包含了fileh.h文件，而fileh.h中声明了一个 `const` 修饰的变量var，filea.c和fileb.c中引用该变量其实是不同的，即filea.c中的var与fileb.c中的var地址不相同。\n:::\n\n[代码源](https://gitbookcpp.llfc.club/sections/cpp/base/cppbase02.html)\n:::code-group\n```C++ [示例代码]\n#include <iostream>\n#include <cstring> // 用于strlen\n\n// 全局变量，存储在全局/静态存储区\nint globalVar = 10;\n\n// 静态变量，也存储在全局/静态存储区，但仅在其声明的文件或函数内部可见\nstatic int staticVar = 20;\n\nvoid func() {\n    // 局部变量，存储在栈区\n    int localVar = 30;\n\n    // 静态局部变量，虽然声明在函数内部，但存储在全局/静态存储区，且只在第一次调用时初始化\n    static int staticLocalVar = 40;\n\n    std::cout << \"Inside func:\" << std::endl;\n    std::cout << \"localVar = \" << localVar << std::endl;\n    std::cout << \"staticLocalVar = \" << staticLocalVar << std::endl;\n\n    // 尝试通过动态内存分配在堆区分配内存\n    int* heapVar = new int(50);\n\n    std::cout << \"heapVar = \" << *heapVar << std::endl;\n\n    // 释放堆区内存（重要：实际使用中不要忘记释放不再使用的堆内存）\n    delete heapVar;\n}\n\nint main() {\n    // 访问全局变量\n    std::cout << \"Inside main:\" << std::endl;\n    std::cout << \"globalVar = \" << globalVar << std::endl;\n    std::cout << \"staticVar = \" << staticVar << std::endl; // 注意：staticVar在外部不可见（除非在同一个文件中或通过特殊方式）\n\n    // 调用函数，展示栈区和堆区的使用\n    func();\n\n    // 字符串常量通常存储在常量区，但直接访问其内存地址并不是标准C++的做法\n    // 这里我们仅通过指针来展示其存在\n    const char* strConst = \"Hello, World!\";\n    // 注意：不要尝试修改strConst指向的内容，因为它是只读的\n    std::cout << \"strConst = \" << strConst << std::endl;\n    // 尝试获取字符串常量的长度（这不会修改常量区的内容）\n    std::cout << \"Length of strConst = \" << strlen(strConst) << std::endl;\n\n    return 0;\n}\n```\n```[输出结果]\nInside main:\nglobalVar = 10\nstaticVar = 20\nInside func:\nlocalVar = 30\nstaticLocalVar = 40\nheapVar = 50\n```\n:::\n从下图中可以看出字符串都存储在了常量区。\n![alt text](https://pic.akorin.icu/20250712171019110.png)\n\n\n### 引用\n\n引用可以看作是另一个变量的别名，其用法也较为简单：\n```C++\nint a = 1;\nint &b = a;\n```\n使用符号 `&` 表示引用，此时变量 `a` 和 `b` 的地址相同。此时修改b的值相当于修改a的值，b就是a的别名。\n\n:::warning 注意\n1. 必须初始化。在创建引用时，必须指向一个已存在的对象。\n2. 一旦引用绑定后就不能再修改。\n3. 不能存在空引用。\n:::\n\n#### 左值引用和右值引用\n在C++中左值( `lvalue` )和右值( `rvalue` )是表达式的两种基本分类，它们决定了表达式的结果在内存中的位置和状态。\n**左值**通常指具有持久状态的对象，有明确的内存地址，可以被多次赋值。左值引用是C++98就有的特性。\n**右值**是临时、没有持久状态的值（临时对象或即将被销毁的对象），通常没有内存地址，或其内存地址在表达式结束后变得无效。右值引用是C++11新增的特性。\n\n:::code-group\n```C++[左值引用]\nint a = 10;\nint& b = a; // b是a的左值引用\n```\n```C++[右值引用]\nint&& c = 20; // c是整数字面量20的右值引用（但这种情况不常见，通常用于函数参数或返回值）\n\nstd::string foo() {\n    return std::string(\"Hello, World!\"); // 返回的临时字符串是一个右值\n}\n\nstd::string &&d = foo(); // d是foo()返回的临时字符串的右值引用\n```\n:::\n右值引用的主要用途是作为函数参数（实现移动语义）和返回值（允许链式调用等）。\n\n### 指针\n\n指针是一种特殊变量。它存储的是另一个变量的地址，而不是该变量本身。通过操作指针可以直接操作内存的数据。\n`nullptr` 为空指针，在C++中 0为 `false` ，非0为 `true`。\n指针存储的是地址，因此指针有两种赋值方式：\n1. **直接赋值**，但是这不常用。\n2. 利用**取地址符号** `&` 获取变量的地址并将其传给指针。取地址符号 `&` 获取的地址只能传给指针类型的变量，否则会报错。\n\n```C++\nint var = 10;\nint *ptr = &var;\n```\n指针本身也是个变量，其存储的是另一个变量的地址，因此计算机也会为指针开辟空间，指针有自己的地址。\n再看下面的代码：\n```C++\nint var = 10;\nint *ptr1 = &var;\nint *ptr2 = ptr1;\n```\nptr1是指针，存储的是var的地址，ptr2也是指针，获取了ptr1存储的值也就是var的地址，此时ptr2也指向了var。\n\n#### 指针和引用的区别\n\n指针与引用类似，都能够对其它对象进行间接地访问，但是指针又与引用有许多不同。\n1. 指针本身就是一个对象，允许对指针赋值和拷贝，在指针地生命周期内可以指向不同的对象，而引用在初始化时就已固定。\n2. 指针无须初始化。在指针未初始化时其存储的值是不确定的。\n\n#### 万能指针和指向指针的指针\n\n`void*` 是一种特殊的指针类型，能够存放任意对象的地址。`void*` 指针存放一个地址，但是该地址存放的数据类型是不知道的。\n由于不知道 `void*` 指向的对象的类型，因此不能利用 `void*` 直接去操作指向的对象。\n\n`void*` 主要用来和别的指针进行比较、作为函数的输入或输出，或赋给另一个 `void*` 指针。\n\n除了万能指针还有指向指针的指针，即`**ptr`，指向指针的指针存取的是另一个指针的地址。\n\n#### 指针和数组\n\n指针能够通过自增和自减来控制指针存取的地址，通过这种特性，将指针指向一个数组，并让指针自增自减就能起到指针选取不同数组内的元素。\n当指针指向数组时，一般指向数组的第一个元素。\n\n```C++\n//指针可以进行算术运算，如递增（++）和递减（--），\n// 这些操作会改变指针所指向的内存地址。但是，这种操作仅限于指向数组元素的指针。\nint arr[5] = {1, 2, 3, 4, 5};\nint *ptr_arr = arr;\nstd::cout << \"ptr_arr is : \" << ptr_arr << std::endl;\nint firstElement = *ptr_arr;\nstd::cout << \"firstElement is \" << firstElement << std::endl;\n// 递增指针\n++ptr_arr; // ptr 现在指向 arr[1]\nstd::cout << \"ptr_arr is : \" << ptr_arr << std::endl;\n// 访问新位置的值\nint secondElement = *ptr_arr; // secondElement 等于 2\nstd::cout << \"secondElement is \" << secondElement;\n```\n上面的代码可以看出指针指向数组时，**数组不用取地址符号**。因为数组名在表达式中会自动转换为**指向其首元素的指针**，即 `arr` 是一个指针并指向数组的第一个元素，也即 `arr` 存取数组第一个元素的地址。在上面的代码中 `arr` 表示数组的首地址，类型为 `int*` 等价于\n```C++\narr = &arr[0];\nint *ptr_arr = &arr[0];\n```\n\n还有指向整个数组的指针：\n```C++\nint a[5] = {1, 2, 3, 4, 5};\nint (*para)[5] = &a;\n```\n这里的 `para` 不是指针数组，而是**数组指针**，这意味着 `para` 应看作成一个整体，其数据类型为 `int*[5]`。\n因此 `para[1]` 并不是指代数组 `a` 的第二个元素，而是偏移了一个 `int[5]` 的单位后的野指针。 `para` 本身不是数组，而是指向了一整个数组的**指针**。\n```C++\nstd::cout << (*para)[1] << std::endl;\n```\n`(*para)[1]` 才是指代数组 `a` 的第二个元素，其中 `para` 在物理意义上存取数组 `a` 的首地址，但在C++中是存取整个数组的地址。\n\n`a` 等价于 `para[0]` ， `a[0]` 等价于 `(*para)[0]`或 `*para` ， `(*para)[1]` 等价于 `para[0][1]` 或 `a[1]`。\n\n在使用**数组指针**时，`*para[0]` 这种写法不够清晰，且容易引起歧义，因此不能这么写，应写成 `(*para)[0]`。\n\n容易混淆的是`para[0][1]` 前一个 `[]` 表示指针位置（指向的地址），后一个 `[]` 表示数组指针指代数组的元素。\n\n这个在普通的指针上也有类似的情况：\n```C++\nint a = 1;\nint *p = &a;\n```\n `p` 等价于 `p[0]`，而 `p[1]` 就是野指针了。\n\n与指针数组对比：\n```C++\nint *para[5];\n```\n上面的代码意味着 `para` 数组有5个 `int` 型指针。\n指针数组有n个指针，而数组指针只有一个。\n\n### `const` 关键字\n\n`const` 修饰的变量为常量，必须初始化且在不能修改。通过 `const` 提高代码的安全性和可读性。\n\n指针本身也是变量，因此也能够被`const`修饰。 `const` 也能修饰函数，一般放在参数列表后面。\n\n#### `const` 在声明变量中的位置\n\n`const` 关键字一般放在变量类型之前：\n```C++\nconst int a =10;\n```\n也可以放在变量类型之后，但比较少见：\n```C++\nint const a = 10;\n```\n\n#### `const`引用\n\n当有 `const` 关键词修饰变量时，其引用也必须是 `const` 修饰的；被引用地变量没有 `const` 修饰时，其引用也可以用 `const` 修饰。\n`const` 修饰的引用变量类型可以与被引用的变量类型不同，在编译过程中会进行隐式地类型转换。\nC++ 允许常量引用绑定到类型不同的右值或临时变量。\n\n```C++\ndouble dval = 3.14;\nint &rd = dval;       // [!code error] 错误\nconst int &rt = dval; // 正确\n// 相当于\nconst int temp = dval;\nconst int &rt = temp;\n```\n此时 `rt` 绑定了一个临时对象 `temp`， 对象 `temp` 进行类型转换。临时对象常常被称作**临时量**。\n\n#### 常量指针\n\n指针也能够被 `const` 修饰，类似于常量对象，在初始化后指向的对象就不能被改变。\n要指向常量对象，必须使用常量指针：\n```C++\nconst double PI = 3.14;\ndouble * ptr = &PI;       // [!code error] 错误\nconst double *cptr0 = &PI; // 正确  普通指针\nconst double *const cptr1 = &PI; // 正确  常量指针\n```\n`cptr0` 是指向常量的指针，可以修改指向的对象。\n`cptr1` 是指向常量的**常量指针**，不能修改指向的对象。\n\n```C++\nconst int a = 10;\nconst int b = 20;\nint c = 30;\nconst int *ptra = &a;\nptra = &b;  // 正确\nconst int *const ptrb = &a;\nptrb = &b;  // [!code error] 错误\nconst int *ptrc = &c;  // 正确\nconst double *ptrc = &c;  // [!code error] 错误\n```\n在上面代码中\n```C++\nconst int *const ptrb = &a;\n```\n前一个 `const` 称作底层 `const` ，后一个 `const` 称作顶层 `const`。\n\n1. **顶层** `const` 表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。\n2. **底层** `const` 则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层 `const` 也可以是底层 `const` ，这一点和其他类型相比区别明显。\n\n```C++\nconst int *ptrc = &c;\nconst double *ptrc = &c;// [!code error]\n```\nC++ **不允许**不同类型的指针直接相互赋值，即使都是常量指针，这点与常量引用不同。\n只有底层 `const` 修饰指针，表示该指针不能修改指向对象的值，但是可以修改指向的对象。\n\n#### `constexpr` 和常量表达式\n\n`constexpr` 是 **C++11**新标准引入的新类型。C++11允许将变量声明为 `constexpr` 类型，让编译器在编译期间就将该类型的值转换成字面量。 `constexpr` 修饰的变量也一定是常量。\n\n`constexpr` 修饰的指针其初始值必须是0或 `nullprt` ，也可以是某个固定地址中的对象（全局对象等）。\n\n### `auto` 关键词\n\n有时候需要从表达式的返回值赋值给变量，这使得创建的变量要与表达式相同，在工程中要实现这一目标比较不变甚至无法实现，C++11 新标准引入 `auto` 类型说明符来自动推算变量类型。\n但是一条 `auto` 只能声明一种基本数据类型。\n```C++\nauto a = 0, pi = 3.14;// [!code error]\n```\n可以在 `auto` 前加上 `const` 来指示推断数据类型为常量。\n\n### `decltype` 关键词\n\n`decltype(function()) x` 通过自动推断函数 `function()` 的返回值类型，并用它来声明变量 `x` ，使 `x` 与 `function()` 的返回值类型一致。\n\n### `for` 循环\nc++中 `for` 循环多了“范围循环”的形式：\n```C++\nfor (a : b){}\n```\n在**C++11**的 `for` 范围循环代码块中，若出现了向量 `vector` ，在背后会自动调用向量的 `begin()/end()` 函数，即可以直接写成：\n```C++\nstd::vector<int> vec = {1 , 2 ,3};\nfor(auto c : vec){}\n```\n等价于：\n```C++\nstd::vector<int> vec = {1 , 2 ,3};\nfor (auto it = vec.begin(); it != vec.end(); ++it) {}\n```\n\n### 向量 `vector`\n\n向量 `vector` 是C++标准模板库(STL)中的一种序列容器，能够动态管理可变大小的数组。\n\n定义一个向量：\n```C++\nstd:vector<int> numbers;  //整数向量\nstd:vector<std:string> words; //字符串向量\n```\n\n向量可以直接增删改查：\n- `push_back()` ：在向量末尾添加一个已有的对象。\n- `emplace_back()` ：在向量末尾原地构造一个对象。\n- `pop_back()` ：移除向量末尾的元素。\n- `insert()` ：在指定位置插入元素。\n- `erase()` ：移除指定位置的元素或范围内的元素。\n- `clear()` ：移除所有元素。\n- `operator[]` ：通过索引访问元素。\n- `at()` ：通过索引访问元素，带边界检查。\n- `front()` ：返回指向第一个元素（底层元素）的迭代器。\n- `back()` ：返回指向最后一个元素迭代器。\n- `size()` ：返回向量中元素的数量。\n- `capacity()`：返回向量目前为止分配的存储容量。\n- `empty()` ：检查向量是否为空。\n- `begin()` : 返回指向向量第一个元素的迭代器，\n- `end()` : 指向“最后一个元素之后”的位置（不能解引用）。\n- `data()` ： 返回指向第一个元素的指针。\n- `find()` ： 在向量中查找所需的元素。\n- `reverse()` ： 预留内存。\n\n:::info\n虽然向量可以直接像数组一样操作和赋值，但是向量本身并不是直接指向第一个元素的指针，而是一个对象，因此需要使用 `vector.begin()` 或 `vector.data()` 来获取向量第一个元素的迭代器或指针。\n```C++\nfor (auto i = vector; i != vector.end(); i++){} // [!code error]\nfor (auto i = vector.begin(); i != vector.end(); i++){}\n```\n:::\n\n#### 二维向量：\n```C++\nstd::vector<std::vector<int>> matrix(3, std::vector<int>(4, 0));\n```\n\n#### 向量内存优化\n\n向量会动态地管理内存，自动调整向量的容量以适应新增或删除的元素，频繁地内存分配可能会影响性能。\n1. 使用 `reverse()` 来预留内存，减少内存分配地次数。\n2. 使用 `shrink_to_fit()` 释放向量的多余容量，匹配向量大小。\n\n### 迭代器\n\n迭代器( `Interator` ) 是C++标准模板库( `STL` ) 的一个重要概念。迭代器就像一个指针，但是迭代器只能访问容器内的元素，因此比指针更加安全。\n\n一些具有迭代器的容器（向量等）都会有成员函数 `begin()` 和 `end()` 来返回迭代器。\n\n#### 迭代器的运算\n\n- `*iter` ：返回迭代器所指元素的引用。\n- `iter->mem` ： 解引用迭代器所指的元素，等价于 `(*iter).mem`\n- `++iter` ： 指向下一个元素\n- `--iter` ： 指向上一个元素\n- `iter1 == iter2` ： 判断两个迭代器是否相等\n- `iter1 != iter2` ： 判断两个迭代器是否不相等\n\n比较类似于指针指向数组。\n\n#### 迭代器失效\n\n由于向量 `vector` 可以动态增长，但是不能再 `for` 循环中向 `vector` 对象添加元素。且任何能够可能改变 `vector` 对象容量的操作（ `push_back` 、 `pop_back` 等）都会使该 `vector` 对象的迭代器失效。\n```C++\n//注意下面逻辑错误，在for循环中push元素导致迭代器失效,也会导致死循环\nfor(auto it = numbers.begin(); it != numbers.end(); ++it) {\n    numbers.push_back(1);\n}\n```\n\n#### 指针类似迭代器用法\n\n指针也是迭代器，在C++11中利用 `std::begin()` 可以获取数组第一个元素的指针， `std::end()` 获取数组'最后一个元素之后' 的指针，与迭代器的 `end()` 位置相同。\n```C++\nint ia[] = {0,1,2,3,4,5,6,7,8,9};\nint * beg = std::begin(ia);\nint * end = std::end(ia);\nfor(auto it = beg; it != end; ++it){\n    std::cout << *it << \" \";\n}\n```\n\n### C 风格字符串\n\nC风格字符串以空字符作为结束( `/0` )。在字符串的末尾一般会自动加上空字符( `/0` )。\n```C++\nchar *str = \"hello world!\";\n```\n或\n```C++\nchar str[] = \"hello world!\";\n```\n此时会在 `!` 后面自动加上 `/0` 。\n但是须注意:\n```C++\nchar str[] = {'a', 'b', 'c'};\n```\n虽然这里的 `str` 也是字符串数组，但是内部没有 `/0` ，这就会导致使用查询字符串长度函数 `strlen` 时，会一致沿着 `str` 在内存的位置直到找到 `/0` 才停下来，这也是C风格字符串的漏洞。\n\n### **类**\n\n类就像一个汽车图纸，而对象就是图纸造出来的汽车。实际上类和结构体差不多，类有的结构体也有，它们唯一的区别只有对成员默认访问权限不同：\n- 类：默认是 `private`\n- 结构体：默认是 `piblic`\n\n#### 类的定义\n\n类有三种成员，分别是\n- 公有成员(public)：可以被所有代码访问。\n- 私有成员(private)：只能被类的成员函数和友元访问。\n- 受保护成员(protected)：只能被类的成员函数、友元和派生类访问。\n\n:::tip 友元\n友元的关键词为 `friend` ，能够让一个函数或者类去访问另一个类的私有成员或受保护成员。友元一般定义在类里，在 `public` `private` `protected` 之外。\n:::\n\n#### 构造函数\n\n构造函数是与类名相同的特殊成员函数，**没有返回类型**，在创建对象时自动执行，主要负责对象的初始化。\n一般是**公有成员**，这样外部才能创建该类的对象。若构造函数是私有的，那么只能在类的内部（比如通过静态成员函数）创建对象。\n构造函数的具体实现可以放在类外也可以放在类里。\n成员变量一般以下划线结尾（如： `name_` ），以此区分局部变量。\n\n#### 初始化列表\n\n是一种用于在构造函数中初始化类成员变量的语法，写在构造函数的参数列表和函数体之间，用冒号 `:` 引导。\n\n某些情况下必须使用初始化列表来初始化变量，比如：\n1. `const` 成员。\n2. 引用成员。\n3. 对象成员没有默认构造函数。\n4. 基类构造函数。\n5. `explicit`成员对象初始化。\n\n因此用初始化列表能解决 99% 的问题。\n```C++\nclass Student {\nprivate:\n    std::string name_;\n    int age_;\n\npublic:\n    Student(const std::string& name, int age)\n        : name_(name), age_(age) { // 初始化列表\n        // 构造函数体（通常可以为空）\n    }\n};\n```\n等价于：\n```C++\nStudent(const std::string& name, int age) {\n    name_ = name;\n    age_ = age;\n}\n```\n同时构造函数也可以在外部实现：\n```C++\nStudent :: Student(const std::string& name, int age)\n: name_(name), age_(age) {\n}\n```\n\n复杂一点的例子：\n```C++\n#include <iostream>\n#include <string>\n\nclass Date {\npublic:\n    int year, month, day;\n    Date(int y, int m, int d) : year(y), month(m), day(d) {}\n};\n\nclass Student {\nprivate:\n    const int id_;         // const 成员变量（必须初始化）\n    std::string& school_;  // 引用类型成员（必须初始化）\n    std::string name_;     // 普通变量（可以在构造函数体赋值，但最好初始化）\n    Date birthday_;        // 对象成员（必须调用构造函数初始化）\n\npublic:\n    // 构造函数使用初始化列表\n    Student(int id, std::string& school, const std::string& name, const Date& birthday)\n        : id_(id),         // const：必须在初始化列表中初始化\n          school_(school), // 引用：也必须在初始化列表中初始化\n          name_(name),\n          birthday_(birthday) {\n        std::cout << \"Student constructed.\\n\";\n    }\n\n    void print() {\n        std::cout << \"ID: \" << id_ << \", Name: \" << name_\n                  << \", School: \" << school_\n                  << \", Birthday: \" << birthday_.year << \"-\" << birthday_.month << \"-\" << birthday_.day << \"\\n\";\n    }\n};\n```\n\n:::info\n这里构造函数传递 `name` 时，是引用传递，可以使得 `name` 变量直接传递给 `name_` 成员，仅一次拷贝。若只是普通传参，则：\n- 传参时会**复制一份字符串**（从实参到形参）。\n- 构造函数体内又复制一份字符串（从形参到变量）。\n**发生了两次拷贝操作**，性能损耗较大。\n:::\n\n#### 拷贝构造函数和移动构造函数\n上述的构造函数是**参数化构造函数**，除此之外还有：\n- 拷贝构造函数：用一个对象去创建另一个对象时。\n  ```C++\n  ClassName(const ClassName& other) {\n    _name = other._name;\n    _age = other._age;\n  };\n  Student s1(\"Alice\", 20);\n  Student s2 = s1;  // 触发拷贝构造函数\n  ```\n- 移动构造函数：使用一个临时对象（右值）初始化另一个对象时（避免不必要的深拷贝）。\n  ```C++\n  ClassName(ClassName&& other) noexcept {\n    _name = std::move(other._name);\n    _age = std::move(other._age);\n  };\n  Student s3 = Student(\"Bob\", 21);  // 触发移动构造函数\n  ```\n  临时对象（右值）优先调用移动构造函数初始化 `s3` ，避免深度拷贝，提高性能。如果类没有定义移动构造函数，则会退而使用拷贝构造，降低效率。\n  理论上移动构造函数和直接赋值性能上差不多，在C++17之后，编译器在开启优化的前提下，会**强制执行拷贝省略**（也称返回值优化 RVO）。\n\n:::tip\n其中 `noexcept` 表示不会抛出异常，若没有这个关键字，则STL会退而求其次使用拷贝构造。\n:::\n\n涉及到移动构造函数，这不得不提C++的**Rule of Five（五法则）**，或\n**Special Member Functions Generation Rules（特殊成员函数生成规则）**：\n\n如果在类中定义了以下五个函数：\n1. 拷贝构造函数（Copy Constructor）\n2. 拷贝赋值运算符（Copy Assignment）\n3. 移动构造函数（Move Constructor）\n4. 移动赋值运算符（Move Assignment）\n5. 析构函数（Destructor）\n则编译器不会自动生成移动构造函数。若需要支持移动语义，除了显式写出移动构造函数，还可以写：\n```C++\n// 放在public区域才能给外界使用\nB(B&& other) = default;\n```\n或\n```C++\nB(B&&) = default; // other可以不用显式\nB& operator=(B&&) = default; // 一般还要写全移动赋值运算符\n```\n\n#### 拷贝赋值运算符和移动赋值运算符\n赋值运算符（ `operator=` ）是给已存在的对象赋值，**不是创建新的对象**，与构造函数不同，因此不能用初始化列表。\n\n这里涉及到**运算符重载**：\n:::tip\n在C++中， `operator` 关键字用于重载运算符。可以重新定义使用运算符时( `+`, `-`, `=`, `==`, `[]`等)该怎么运行。本节涉及到赋值运算符重载( `operator=` )。\n:::\n\n- 拷贝赋值运算符：将一个已有对象的内容拷贝到当前对象。\n  ```C++\n  T& operator=(const T& other);\n  ```\n- 移动赋值运算符：把一个右值对象的资源移动到当前对象，避免不必要的拷贝。\n  ```C++\n  T& operator=(T&& other);\n  ```\n\n逐字分解：\n- `T&`：返回当前对象本身的引用。\n- `operator=`：赋值运算符重载。\n- `const T& other`：参数是另一个 `T` 类对象的常量引用。\n- `T&& other`：参数是另一个 `T` 类对象的右值引用。\n\n声明赋值运算符时又与声明构造函数不同，由于是对已有的对象进行操作，因此多了一些防止内存泄漏、二次释放以及自我赋值检查的操作。\n示例代码：\n```C++\nclass MyClass {\npublic:\n    MyClass(int val) {\n        data = new int(val);\n    }\n    // 拷贝赋值运算符\n    MyClass& operator=(const MyClass& other) {\n        if (this == &other) return *this; // 自我赋值检查\n        delete data;\n        data = new int(*other.data); // 深拷贝\n        return *this;\n    }\n    // 移动赋值运算符\n    MyClass& operator=(MyClass&& other) noexcept {\n        if (this == &other) return *this; // 自我赋值检查\n        delete data;\n        data = other.data;\n        other.data = nullptr; // 避免析构时重复释放\n        return *this;\n    }\n    ~MyClass() {\n        delete data;\n    }\nprivate:\n    int* data;\n};\n```\n在这段代码中，只要是重构赋值运算符的代码中：\n1. 先进行自我赋值检查，**防止赋值给自己导致逻辑出错或资源被提前释放**。\n2. 释放已有的资源，**防止内存泄漏**。\n\n须注意一点是，移动赋值运算符中，还要让**源对象(other)的资源指针**设为 `nullptr` ，**避免它在析构时发生二次释放的问题**。\n:::tip\n\n指向 `nullptr` 的指针可以**安全地重复** `delete` 操作，不会导致程序崩溃或行为未定义。\n\n`delete` 只是**释放指针所指向的内存**，并没有自动地将指针指向 `nullptr` ，因此有不需要再使用的指针时，进行 `delete` 的操作后，还要手动将指针设为 `nullptr`。\n```C++\nint* p = new int(42);\ndelete p;\np = nullptr;\n```\n\n`delete` 和 `new` **只能用于指针**。 `new` **创建的指针必须用** `delete` ， `new[]` **创建的指针必须用** `delete[]`。\n因为在**分配方式上的不同**，使用 `new[]` 时编译器会在内存中“偷偷藏一个额外的数字”来记住数组大小，以便于调用析构函数（如果是对象数组）。\n`delete` **只释放一个对象**，如果是对 `new[]` 创建的指针进行 `delete` 此时可能就会造成内存泄漏或崩溃。\n`new` 和 `delete` 都是针对 **堆内存（手动分配）** 进行操作的，如果对 **栈内存（程序自动分配）** 操作可能会出现未定义行为或崩溃。\n```C++\nint* p = new int(10);\ndelete p;\nint* arr = new int[5];\ndelete[] arr;\n```\n:::\n\n#### 类继承\n\n类继承允许一个派生类从另一个基类继承属性和行为。通过继承，派生类可以用基类的代码（成员、函数），可以重写现有成员和添加新的成员。派生类继承基类的写法如下：\n\n```C++\nclass Base {\n  // code\n  virtual ~Base() = default;\n}\nclass Derived : public Base {\n  // code\n}\n```\n上式中 `public` 表示公有继承，它保持基类中 `public` 和  `protected` 成员的访问权限不变。\n\n- 若写成 `protected` ：基类的 `public` 和 `protected` 成员全部变成 `protected` ，只能在派生类及其子类中访问。\n- 若写成 `private` ：基类的 `public` 和 `protected` 成员都会变成 `private` ，只能在该派生类中访问，子类访问不到。\n\n上述代码的基类中涉及到继承，应该声明一个 **虚析构函数**：\n1. 保证通过基类指针/引用删除派生类对象时不会“资源泄漏”。\n2. 更安全的类层次设计，防止将来踩坑。\n\n#### 虚函数\n\n虚函数允许派生类重新定义基类中的函数，以实现多态性。在类中使用关键字 `virtual` 来声明函数为虚函数。\n\n基类中定义：\n```C++\nclass Base {\npublic:\n    virtual void function() {\n      std::cout << \"Base virtual function\" << std::endl;\n    }\n    virtual void constfunction() const {}\n}\n```\n在派生类（子类）中定义：\n```C++\nclass Child : public Base {\npublid:\n    void function() override {\n      // 重载代码\n      std::cout << \"Child virtual function\" << std::endl;\n    }\n    void constfunction() override {\n      // 重载代码\n    }\n}\n```\n\n如果基类不写 `virtual` 那么子类即使写了重名的函数也不会发生重载（覆盖）。\n通过基类指针访问重载后的函数，仍然使用被重载后的代码：\n\n```C++\nMyChild *c = new Child;\nMyClass *b = new Class;\nMyClass *p = c;   // 创建基类指针\np->function;      // 使用基类指针访问基类的函数\n```\n此时会输出 `Child virtual function`。\n\n:::info\n类继承基类后，如果基类没有**无参数构造函数**，则子类应显式调用基类的含参构造函数，为基类进行初始化。\n:::\n\n#### 纯虚函数\n\n纯虚函数是在基类中声明但不定义的虚函数，目的是为了让派生类强制实现它。包含了至少一个纯虚函数的类被称为 **抽象基类(Abstract Base Class, ABC)**，在声明的虚函数后面加上 `=0` 表示纯虚函数。抽象基类**不能实例化**，抽象基类的目的是作为接口（interface）使用，派生类必须实现其所有纯虚函数，才能实例化对象。\n\n```C++\nclass Shape {\npublic:\n    virtual void draw() const = 0; // 纯虚函数\n    virtual ~Shape() = default;\n};\nclass Circle : public Shape {\npublic:\n    void draw() const override {\n        cout << \"Drawing Circle\" << endl;\n    }\n};\nShape s;    // [!code error] 抽象类不能被实例化\nCircle c;   // 派生类实现了纯虚函数，可以实例化\nShape* ptr = &c; // 使用基类指针访问被重载后的函数\nptr->draw();\nreturn 0;\n```\n最后会输出 `Drawing Circle`。\n\n#### 拷贝/移动构造与拷贝/移动运算符控制\n\n当基类声明了拷贝/移动构造函数和拷贝/移动赋值运算符时，子类可以直接调用基类已声明的构造和运算符。\n\n##### 拷贝构造和拷贝运算符：\n```C++\nclass Base {\npublic:\n    Base(std::string str) : name_(str) {\n        std::cout << \"Name:\" << name_ <<std::endl;\n    }\n    Base(const Base& other) : name_(other.name_) {\n        std::cout << \"Base copy constructor\" << std::endl;\n    }\n    Base& operator=(const Base& other) {\n        std::cout << \"Base copy assignment\" << std::endl;\n        if (this != &other) {\n            name_ = other.name_;\n        }\n        return *this;\n    }\n    virtual ~Base() = default;\nprotected:\n    std::string name_;\n};\nclass Derived : public Base {\npublic:\n    Derived(std::string str, int value) : Base(str), value_(value) {\n        std::cout << \"Value:\" << value_ <<std::endl;\n    }\n    Derived(const Derived &other) : Base(other) {\n         std::cout << \"Derived copy constructor\" << std::endl;\n    }\n    Derived& operator=(const Derived& other) {\n        std::cout << \"Derived copy assignment\" << std::endl;\n        if (this != &other) {\n            Base::operator=(other);  // 显式调用基类的拷贝赋值运算符\n            value_ = other.value_;\n        }\n        return *this;\n    }\nprivate:\n    int value_;\n};\nint main() {\n    Derived s1 = Derived(\"Alice\", 16);\n    Derived s2 = s1;\n    Derived s3(\"David\", 14);\n    s3 = s1;\n    return 0;\n}\n```\n此时输出：\n```\nName:Alice\nValue:16\nBase copy constructor\nDerived copy constructor\nName:David\nValue:14\nDerived copy assignment\nBase copy assignment\n```\n\n##### 移动构造和移动运算符：\n```C++\nclass Base {\npublic:\n    Base(std::string str) : name_(str) {\n        std::cout << \"Name:\" << name_ << std::endl;\n    }\n    Base(Base &&other) noexcept : name_(std::move(other.name_)) {\n        std::cout << \"Base move constructor\" << std::endl;\n    }\n    Base &operator=(Base &&other) noexcept {\n        std::cout << \"Base move assignment\" << std::endl;\n        if (this != &other) {\n            name_ = std::move(other.name_);\n        }\n        return *this;\n    }\n    virtual ~Base() = default;\nprotected:\n    std::string name_;\n};\nclass Derived : public Base {\npublic:\n    Derived(std::string str, int value) : Base(str), value_(value) {\n        std::cout << \"Value:\" << value_ << std::endl;\n    }\n    Derived(Derived &&other) noexcept : Base(std::move(other)) {\n        std::cout << \"Derived move constructor\" << std::endl;\n    }\n    Derived &operator=(Derived &&other) {\n        std::cout << \"Derived move assignment\" << std::endl;\n        if (this != &other) {\n            Base::operator=(std::move(other)); // 显式调用基类的移动赋值运算符\n            value_ = other.value_;\n        }\n        return *this;\n    }\nprivate:\n    int value_;\n};\nint main() {\n    Derived s1 = std::move(Derived(\"Alice\", 16));\n    Derived s2(\"David\", 14);\n    s2 = std::move(s1);\n    return 0;\n}\n```\n:::info\n这里显式调用 `std::move` 是因为 `Base` 这个类中没有动态调整内存（使用指针或开辟空间），如果不显式调用 `std::move` 编译器会触发返回值优化（Return Value Optimization,RVO），直接将s1构造在s2的地址空间里，而不会触发移动构造。\n:::\n\n此时输出：\n```\nName:Alice\nValue:16\nBase move constructor\nDerived move constructor\nName:David\nValue:14\nDerived move assignment\nBase move assignment\n```\n\n#### 容器与继承\n\n在 C++ 中，**对象切片（object slicing）** 是指当一个派生类对象赋值给一个基类对象 **（而不是指针或引用）** 时，只有基类的部分会被拷贝，派生类中新增的成员变量和虚函数行为就会 **被“切掉”**，这会导致多态失效，这一情况在容器类中比较容易出现。\n\n```C++\nclass Base {\npublic:\n    virtual void speak() const {\n        std::cout << \"Base speaking\\n\";\n    }\n    virtual ~Base() = default;\n};\nclass Derived : public Base {\npublic:\n    void speak() const override {\n        std::cout << \"Derived speaking\\n\";\n    }\n};\nint main() {\n    std::vector<Base> vec;\n    vec.push_back(Derived()); // [!code error]此时会发生切片\n    for (const auto& ptr : vec) {\n        ptr->speak(); // 输出：Base speaking\n    }\n}\n```\n此时会输出基类声明的虚函数： `Base speaking`。\n\n此时要解决**切片**问题，应使用指针或智能指针来解决，即往容器中存储对象指针。则主函数 `main` 应这样改写：\n\n```C++\nint main() {\n    std::vector<Base*> vec;\n    vec.push_back(new Derived());\n    for (auto ptr : vec) {\n        ptr->say();  // 输出：Derived speaking\n    }\n    // ❗手动释放内存\n    for (auto ptr : vec) {\n        delete ptr;\n    }\n    return 0;\n}\n```\n或者使用智能指针：\n```C++\nint main() {\n    std::vector<std::unique_ptr<Base>> vec;\n    vec.push_back(std::make_unique<Derived>());\n    for (const auto& ptr : vec) {\n        ptr->speak(); // 输出：Derived speaking\n    }\n}\n```\n智能指针能够避免忘记删除指针，防止内存泄漏。同时由于多个指针都指向同一块地址，容易发生二次释放，因此使用智能指针更安全。最后如果**中途抛出异常**，则可能不会执行 `delete ptr` ，依然会造成内存泄露。\n\n:::tip\n智能指针能够自动释放资源，无需手动 `delete`，且支持转移所有权，符合限带C++的 RAII哲学，还支持异常安全。\n:::\n\n| 名称               | 本质                               | 用法目的                         |\n| ------------------ | ---------------------------------- | -------------------------------- |\n| `unique_ptr<T>`    | 独占式智能指针（不能拷贝可以移动） | 自动释放内存，避免手动 `delete`  |\n| `shared_ptr<T>`    | 引用计数式共享智能指针             | 多处共享对象，最后一个释放才释放 |\n| `make_unique<T>()` | 安全创建 `unique_ptr<T>`           | 比较推荐的方式，避免裸用 `new`   |\n| `make_shared<T>()` | 安全创建 `shared_ptr<T>`           | 在堆上只分配一次内存             |\n\n### `map`\n\n`std::map` 是C++标准模板库(STL)中的一个关联容器，用于存储键值对(key-value pairs)，每个简直都是唯一的，自动排序（一般是升序）。\n\n#### 声明 `map`\n\n```C++\n// 键：int  值: std::string\nstd::map<int,std::string> myMap;\n// 键：std::string  值: int\nstd::map<std::string,double> myMap;\n```\n\n#### 初始化 `map`\n\n```C++\nstd::map<int, std::string> myMap = {\n    {1, \"Apple\"},\n    {2, \"Banana\"},\n    {3, \"Cherry\"}\n};\n```\n\n#### 常见用法\n\n- `insert`:插入\n    ```C++\n    myMap.insert(pair<int, string>(4, \"Date\"));\n    myMap.insert(make_pair(5, \"Elderberry\"));\n    myMap.insert( {6, \"Fig\"} );\n    ```\n- 运算符 `[]` 操作\n    ```C++\n    myMap[7] = \"Grape\";\n    // 如果键 8 不存在，则会插入键 8 并赋值\n    myMap[8] = \"Honeydew\";\n    ```\n- `at`: 键值查询\n    ```C++\n    string fruit = myMap.at(2); // 获取键为 2 的值 \"Banana\"\n    ```\n- `find`: 元素查询，返回迭代器\n    ```C++\n    auto it = myMap.find(3);\n    ```\n- `eraser`: 删除\n    ```C++\n    myMap.erase(2);   // 传入键值\n    myMap.erase(it);  // 传入迭代器\n    myMap.erase(myMap.begin(),myMap.find(2));  // 传入范围\n    ```\n- `clear`: 删除所有元素\n    ```C++\n    myMap.clear(); // 删除所有元素\n    ```\n- `size()`: 获取容器中元素的数量\n- `empty()`: 判断容器是否为空\n- `count(key)`: 返回具有指定键元素的数量\n- `lower_bound(key)`: 返回指向第一个不小于键的迭代器\n- `upper_bound(key)`: 返回指向第一个不大于键的迭代器\n- `equal_range(key)`: 返回包含等于指定键元素的范围\n\n#### 自定义排序顺序\n```C++\nstruct Compare {\n    bool operator()(const int& a, const int& b) const {\n        return a > b; // 降序排序\n    }\n};\nmap<int, string, Compare> myMapDesc;\nmyMapDesc[1] = \"Apple\";\nmyMapDesc[2] = \"Banana\";\n```\n\n### `unordered_map`\n\n与 `map` 不同， `unordered_map` 是基于哈希表的键值对存储结构，而 `map` 是基于红黑树实现。\n\n#### 基本定义\n\n```C++\nstd::unordered_map<\n    KeyType,\n    ValueType,\n    Hash = std::hash<KeyType>,\n    KeyEqual = std::equal_to<KeyType>,\n    Allocator = std::allocator<std::pair<const KeyType, ValueType>>\n>\n```\n其中：\n- `KeyType`：键的类型，需要支持哈希运算和相等比较。\n- `ValueType`：值的类型。\n- `Hash`：哈希函数，默认为 `std::hash<KeyType>`。\n- `KeyEqual`：键相等的比较函数，默认为 `std::equal_to<KeyType>`。\n- `Allocator`：内存分配器，默认为 `std::allocator`。\n\n\n#### 插入元素\n- `insert`\n- 下标操作符 `[]`\n```C++\n// 方式一：使用 insert(pair)\nmp.insert({1, \"apple\"});\nmp.insert(make_pair(2, \"banana\"));\n\n// 方式二：使用下标操作符 []\nmp[3] = \"cherry\";   // 若 key=3 不存在，创建并赋值\nmp[2] = \"blueberry\"; // 覆盖原值\n```\n\n#### 查找元素\n- `find`：查找值并返回迭代器。\n- `at`：查找值，没找到就抛出异常\n- `count`：若存在指定的key，则返回1否则返回0。\n- `first` 取出键（key）。\n- `second` 取出值（value）。\n\n```C++\n// 使用 find()\nauto it = mp.find(3);\nif (it != mp.end()) {\n    // it 指向一个元素，类型是 pair<const Key, T>\n    // 其中 it->first 表示 key，it->second 表示 value\n    cout << \"Found: \" << it->first << \" -> \" << it->second << endl;\n} else {\n    cout << \"Not found\" << endl;\n}\n\n// 使用 at()\ntry {\n    cout << \"Key=1, value=\" << mp.at(1) << endl;\n    cout << \"Key=3, value=\" << mp.at(3) << endl; // 不存在，抛出异常\n} catch (const out_of_range &e) {\n    cout << \"Exception: \" << e.what() << endl;\n}\n// 使用 count()\nif (mp.count(2)) cout << \"存在 key=2\" << endl;\n\n\n```\n\n#### 删除元素\n- `erase`：删除指定的key，或者迭代器。\n- `clear`：清空。\n\n\n## 补充\n\n### 堆内存管理器- `allocator`\n\n- **堆内存管理器（Allocator）** 是操作系统或运行时库提供的一类组件，用于管理 **堆（Heap）** 上的动态内存分配与释放。\n- 应用程序通过 `malloc/free`（C）、`new/delete`（C++）或 STL 容器的 `allocator` 来请求或释放堆内存。\n- 它解决了内存动态管理中的三个核心问题：\n  1. **分配（Allocation）**：给定大小，找到一块可用的空闲内存并返回指针。\n  2. **释放（Deallocation）**：回收不再使用的内存块。\n  3. **重用与合并（Reuse & Coalescing）**：减少内存碎片，提高利用率。\n\n### 堆内存分配的基本原理\n1. **堆的组织结构**\n   - 堆通常被看作一个大的内存池。\n   - 内存块分为 **已分配块** 和 **空闲块**。\n   - 空闲块通过链表或树结构组织。\n\n2. **分配算法**\n   - **First Fit（首次适应）**：从头开始找，找到第一个足够大的空闲块。\n   - **Best Fit（最佳适应）**：找到大小最接近所需的空闲块，减少浪费。\n   - **Worst Fit（最差适应）**：找最大的空闲块，避免过多碎片。\n   - **Buddy System（伙伴系统）**：将内存块按 2 的幂划分，方便合并。\n\n3. **释放与合并**\n   - 当释放一个内存块时，如果其前后也是空闲块，就会 **合并** 以减少外部碎片。\n   - 内存管理器可能维护 **空闲链表** 或 **位图** 来快速查找可用块。\n\n### 常见堆内存管理器实现\n1. **glibc malloc（ptmalloc）**\n   - 基于 **bin + 空闲链表**。\n   - 多线程时采用 **arena** 机制，减少锁竞争。\n2. **jemalloc**\n   - 用于 FreeBSD、Firefox。\n   - **多 arena 并行分配**，减少锁竞争。\n   - **slab 分配**，适合小对象。\n3. **tcmalloc（Google）**\n   - Thread-Caching Malloc。\n   - 每个线程维护本地缓存（thread cache），加速分配释放。\n4. **STL Allocator**\n   - C++ STL 容器的分配器接口。\n   - 可以自定义替换，决定容器使用哪种内存管理方式。\n\n### C++ Allocator 接口（简要）\n```cpp\ntemplate <class T>\nstruct allocator {\n    using value_type = T;\n\n    allocator() noexcept {}\n    template <class U> allocator(const allocator<U>&) noexcept {}\n\n    // 分配 n 个元素的空间（不构造）\n    T* allocate(std::size_t n) {\n        return static_cast<T*>(::operator new(n * sizeof(T)));\n    }\n\n    // 释放内存（不析构）\n    void deallocate(T* p, std::size_t) noexcept {\n        ::operator delete(p);\n    }\n};\n\n```\n### 内存碎片问题\n\n- **外部碎片**\n  空闲内存总量足够，但不连续，导致分配失败。\n  例如：内存被分割成多个小块，虽然总和大于请求的大小，但没有连续的可用空间。\n\n- **内部碎片**\n  分配的内存块比请求的要大，导致浪费。\n  例如：申请 13 字节，但分配器按 16 字节对齐，浪费了 3 字节。\n\n#### 优化方法\n- 使用 **伙伴系统（buddy system）** 合并空闲块，减少外部碎片。\n- 使用 **slab allocator** 预先分配固定大小的内存块，适合频繁的小对象分配。\n\n### 各内存管理器对比\n\n| 管理器            | 特点 | 优化点 |\n|-------------------|------|--------|\n| **glibc malloc**  | bin + 空闲链表，支持多线程 | arena 机制，减少锁竞争 |\n| **jemalloc**      | slab 分配，适合小对象 | 多 arena 并行分配，提高并发性能 |\n| **tcmalloc**      | Thread-Caching Malloc | 每线程本地缓存，加速分配释放 |\n| **STL Allocator** | C++ 标准库接口 | 可自定义替换，灵活适配不同需求 |\n","cover":"https://pic.akorin.icu/c++cover.jpg","date":"2025-07-10 00:00:00"},{"title":"Zen Browser默认打开卡顿","tags":["Zen Browser","优化"],"categories":["浏览器"],"author":"akorin","excerpt":"\n**Zen浏览器在全屏使用的时候总有卡顿，最后发现每次启动时，核显的占用率都会达到99%，而Chrome不会**\n\n## 解决方案\n\n- 等待Zen Browser的后续优化\n- 启动Zen Browser时使用高性能（独立显卡启动）：\n\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/20250221164427234.png)\n\n","link":"/posts/zenbrowser","content":"\n**Zen浏览器在全屏使用的时候总有卡顿，最后发现每次启动时，核显的占用率都会达到99%，而Chrome不会**\n\n## 解决方案\n\n- 等待Zen Browser的后续优化\n- 启动Zen Browser时使用高性能（独立显卡启动）：\n\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/20250221164427234.png)\n\n<!-- more -->\n","cover":"https://pic.akorin.icu/67jja5nl.png","date":"2025-02-21 00:00:00"},{"title":"一致性哈希算法","tags":["算法","一致性哈希","编程","C++"],"categories":["算法"],"author":"akorin","excerpt":"\n# 一致性哈希算法\n\n**一致性哈希（Consistent Hashing）** ：是一种特殊的哈希算法，用于解决 **分布式系统中的数据分布与动态伸缩问题。**\n\n- 当 **节点**（机器/缓存服务器）数量发生变化（增加或减少）时，尽可能减少需要重新映射的数据量。\n- 避免传统哈希算法带来的大规模数据迁移问题。\n\n","link":"/posts/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95","content":"\n# 一致性哈希算法\n\n**一致性哈希（Consistent Hashing）** ：是一种特殊的哈希算法，用于解决 **分布式系统中的数据分布与动态伸缩问题。**\n\n- 当 **节点**（机器/缓存服务器）数量发生变化（增加或减少）时，尽可能减少需要重新映射的数据量。\n- 避免传统哈希算法带来的大规模数据迁移问题。\n\n<!-- more -->\n\n\n\n## 为什么需要一致性哈希\n\n假设有一个缓存集群：\n- 普通哈希方法：`hash(key) % N` （N 是机器数量）。\n- 如果某台机器宕机，N 变了 → 所有 key 的分布都变了，几乎所有缓存都会失效，需要重算和迁移。\n\n![](https://pic.akorin.icu/20250826185010124.webp)\n\n## 算法思想\n\n1. 哈希环：把整个哈希值空间想象成一个环。\n2. 节点映射：每个机器节点通过哈希映射到环上的一个点。\n3. 数据映射：每个数据 key 也映射到环上，顺时针找到第一个节点就是它的存储节点。\n4. 节点变化：\n    - 新增节点：只影响它顺时针方向的一部分 key。\n    - 删除节点：只影响它之前负责的一部分 key。\n    ![](https://pic.akorin.icu/20250826214336915.webp)\n\n先通过哈希函数计算出哈希值，落在哈希环上的某个位置，在哈希环中沿着顺时针开始找，直到找到节点。\n\n在上图中，哈希值落在B和C区间，最终都会找到C这个节点。 **删改其中的节点只影响到环上的一部分** ，不会造成服务的大量定位，也就不会出现大量请求突然几种请求某个服务节点。\n\n\n### 虚拟节点\n\n- 一个物理机器对应多个虚拟节点。\n- 虚拟节点均匀分布在哈希环上。\n- 这样可以解决部分节点“分到的数据太多”的负载不均衡问题。\n  ![](https://pic.akorin.icu/20250826215610930.webp)\n\n\n在真实的主机，一般会放100~200个虚拟节点。\n\n设置虚拟节点是为了防止物理节点过少，导致哈希处理后， **在一致性哈希环上挤在一块** ，防止导致某一台服务器负载太多，其他服务器一直空闲。\n\n:::code-group\n```C++ [main.cpp]\n#include \"md5.h\"\n#include <iostream>\n#include <list>\n#include <random>\n#include <set>\n#include <string>\n#include <sys/types.h>\n#include <map>\n\nusing namespace std;\n\n// 声明虚拟主机\nclass VirtualHost;\n\n// 物理主机\nclass PhysicalHost {\npublic:\n    PhysicalHost(string ip, int vHostNums) : ip_(ip) {\n        for (int i = 0; i < vHostNums; ++i) {\n            // 虚拟节点构造需要传入虚拟ip和物理主机\n            virtualHostList_.emplace_back(ip + \"#\" + to_string(i),\n                                          this);\n        }\n    }\n\npublic:\n    const string getPhyIP() const {\n        return ip_;\n    }\n    const list<VirtualHost>& getVirtualHostList() const {\n        return virtualHostList_;\n    }\n\nprivate:\n    string ip_;\n    list<VirtualHost> virtualHostList_;\n};\n\nclass VirtualHost {\npublic:\n    VirtualHost(string vip, PhysicalHost* phy) :\n        vip_(vip), phyHost(phy) {\n        // 计算md5\n        md5_ = md5_to_uint(vip_);\n    }\n\npublic:\n    const uint getMd5() const {\n        return md5_;\n    }\n    const string getVip() const {\n        return vip_;\n    }\n    const PhysicalHost* getPhyHost() const {\n        return phyHost;\n    }\n    bool operator<(const VirtualHost& other) const {\n        return md5_ < other.md5_;\n    }\n    bool operator==(const VirtualHost& other) const {\n        // vip_ 算作唯一的标识符\n        return vip_ == other.vip_;\n    }\n\nprivate:\n    string vip_;\n    uint md5_;               //  该虚拟节点的md5值\n    PhysicalHost* phyHost;   // 隶属的物理节点\n};\n\nclass ConsistentHash {\npublic:\n    void addHost(PhysicalHost& phy) {\n        for (auto v : phy.getVirtualHostList()) {\n            hcircle_.insert(v);\n        }\n    }\n    void delHost(PhysicalHost& phy) {\n        // 删除该主机的所有虚拟节点\n        // 不能在遍历的过程中动原来的容器\n        for (auto vhost : phy.getVirtualHostList()) {\n            auto it = hcircle_.find(vhost);\n            if (it != hcircle_.end())\n                hcircle_.erase(it);\n        }\n    }\n    // 获取负载的真实物理主机ip\n    const string getHost(string clientip) const {\n        uint md5 = md5_to_uint(clientip);\n        // 找第一个大于client的md5的虚拟节点\n        for (auto v : hcircle_) {\n            if (v.getMd5() > md5) {\n                return v.getPhyHost()->getPhyIP();\n            }\n        }\n        // 所有的哈希值都小于等于客户端的哈希值，直接扔给第一个虚拟节点\n        // 从0开始遇见的第一个虚拟节点\n        return hcircle_.begin()->getPhyHost()->getPhyIP();\n    }\n\nprivate:\n    // 红黑树中排序是std::less，需要改\n    // 此时是两个类在比较，因此需要重载类的小于运算符\n    set<VirtualHost> hcircle_;\n};\n\nint main() {\n    PhysicalHost host1(\"10.117.124.10\", 150);\n    PhysicalHost host2(\"10.117.124.20\", 150);\n    PhysicalHost host3(\"10.117.124.30\", 150);\n\n    ConsistentHash chash;\n    chash.addHost(host1);\n    chash.addHost(host2);\n    chash.addHost(host3);\n\n    list<string> iplists;\n    // 生成30个192.168.x.y格式的随机IP\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_int_distribution<> dist_x(0, 255);\n    uniform_int_distribution<> dist_y(1, 254);\n\n    for (int i = 0; i < 30; ++i) {\n        int x = dist_x(gen);\n        int y = dist_y(gen);\n        iplists.push_back(\"192.168.\" + to_string(x) + \".\" +\n                          to_string(y));\n    }\n\n    map<string, list<string>> logMap;\n    for (auto clientip : iplists) {\n        string host = chash.getHost(clientip);\n        logMap[host].emplace_back(clientip);\n    }\n\n    for (auto pair : logMap) {\n        cout << \"物理主机ip:\" << pair.first << endl;\n        cout << \"客户端映射的数量:\" << pair.second.size() << endl;\n\n        for (auto ip : pair.second) {\n            cout << ip << endl;\n        }\n        cout << \"----------------------------------\" << endl;\n    }\n    cout << endl;\n\n    // 模拟host1故障\n    chash.delHost(host1);\n    // 清除原来的log，防止重复记录\n    logMap.clear();\n    for (auto clientip : iplists) {\n        string host = chash.getHost(clientip);\n        logMap[host].emplace_back(clientip);\n    }\n\n    for (auto pair : logMap) {\n        cout << \"物理主机ip:\" << pair.first << endl;\n        cout << \"客户端映射的数量:\" << pair.second.size() << endl;\n\n        for (auto ip : pair.second) {\n            cout << ip << endl;\n        }\n        cout << \"----------------------------------\" << endl;\n    }\n    cout << endl;\n    return 0;\n}\n```\n```C++ [md5.cpp]\n// md5_uint.cpp\n// 简单的 MD5 实现（RFC1321），并提供 md5_to_uint(string) -> unsigned\n// int（uint32_t）\n// 版权：此实现参考公开域/教学实现，适合学习与工程使用。\n\n#include <cstdint>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing uint32 = uint32_t;\nusing uint8 = uint8_t;\n\nclass MD5 {\npublic:\n    MD5() {\n        init();\n    }\n\n    void update(const uint8* input, size_t length) {\n        size_t idx = (count[0] >> 3) & 0x3F;\n        uint64_t bits = (uint64_t)length << 3;\n\n        // update bit count\n        count[0] += (uint32)bits;\n        if (count[0] < (uint32)bits)\n            count[1]++;\n        count[1] += (uint32)(length >> 29);\n\n        size_t partLen = 64 - idx;\n        size_t i = 0;\n        if (length >= partLen) {\n            memcpy(&buffer[idx], input, partLen);\n            transform(buffer);\n\n            for (i = partLen; i + 63 < length; i += 64)\n                transform(&input[i]);\n            idx = 0;\n        } else {\n            i = 0;\n        }\n        memcpy(&buffer[idx], &input[i], length - i);\n    }\n\n    void finalize(uint8 digest[16]) {\n        static const uint8 PADDING[64] = {0x80};\n        uint8 bits[8];\n        encodeBits(bits);\n\n        size_t idx = (count[0] >> 3) & 0x3f;\n        size_t padLen = (idx < 56) ? (56 - idx) : (120 - idx);\n        update(PADDING, padLen);\n        update(bits, 8);\n\n        encodeState(digest);\n        // clear sensitive data\n        memset(buffer, 0, sizeof(buffer));\n        count[0] = count[1] = 0;\n    }\n\nprivate:\n    void init() {\n        count[0] = count[1] = 0;\n        // 消息摘要初始向量（RFC1321）\n        state[0] = 0x67452301;\n        state[1] = 0xEFCDAB89;\n        state[2] = 0x98BADCFE;\n        state[3] = 0x10325476;\n    }\n\n    // 基本左循环宏\n    static inline uint32 rotate_left(uint32 x, int n) {\n        return (x << n) | (x >> (32 - n));\n    }\n\n    // 四个基本函数（RFC1321）\n    static inline uint32 F(uint32 x, uint32 y, uint32 z) {\n        return (x & y) | (~x & z);\n    }\n    static inline uint32 G(uint32 x, uint32 y, uint32 z) {\n        return (x & z) | (y & ~z);\n    }\n    static inline uint32 H(uint32 x, uint32 y, uint32 z) {\n        return x ^ y ^ z;\n    }\n    static inline uint32 I(uint32 x, uint32 y, uint32 z) {\n        return y ^ (x | ~z);\n    }\n\n    void transform(const uint8 block[64]) {\n        uint32 a = state[0], b = state[1], c = state[2], d = state[3],\n               x[16];\n\n        decodeBlock(block, x);\n\n        // Round 1\n        a = b + rotate_left(a + F(b, c, d) + x[0] + 0xd76aa478, 7);\n        d = a + rotate_left(d + F(a, b, c) + x[1] + 0xe8c7b756, 12);\n        c = d + rotate_left(c + F(d, a, b) + x[2] + 0x242070db, 17);\n        b = c + rotate_left(b + F(c, d, a) + x[3] + 0xc1bdceee, 22);\n        a = b + rotate_left(a + F(b, c, d) + x[4] + 0xf57c0faf, 7);\n        d = a + rotate_left(d + F(a, b, c) + x[5] + 0x4787c62a, 12);\n        c = d + rotate_left(c + F(d, a, b) + x[6] + 0xa8304613, 17);\n        b = c + rotate_left(b + F(c, d, a) + x[7] + 0xfd469501, 22);\n        a = b + rotate_left(a + F(b, c, d) + x[8] + 0x698098d8, 7);\n        d = a + rotate_left(d + F(a, b, c) + x[9] + 0x8b44f7af, 12);\n        c = d + rotate_left(c + F(d, a, b) + x[10] + 0xffff5bb1, 17);\n        b = c + rotate_left(b + F(c, d, a) + x[11] + 0x895cd7be, 22);\n        a = b + rotate_left(a + F(b, c, d) + x[12] + 0x6b901122, 7);\n        d = a + rotate_left(d + F(a, b, c) + x[13] + 0xfd987193, 12);\n        c = d + rotate_left(c + F(d, a, b) + x[14] + 0xa679438e, 17);\n        b = c + rotate_left(b + F(c, d, a) + x[15] + 0x49b40821, 22);\n\n        // Round 2\n        a = b + rotate_left(a + G(b, c, d) + x[1] + 0xf61e2562, 5);\n        d = a + rotate_left(d + G(a, b, c) + x[6] + 0xc040b340, 9);\n        c = d + rotate_left(c + G(d, a, b) + x[11] + 0x265e5a51, 14);\n        b = c + rotate_left(b + G(c, d, a) + x[0] + 0xe9b6c7aa, 20);\n        a = b + rotate_left(a + G(b, c, d) + x[5] + 0xd62f105d, 5);\n        d = a + rotate_left(d + G(a, b, c) + x[10] + 0x02441453, 9);\n        c = d + rotate_left(c + G(d, a, b) + x[15] + 0xd8a1e681, 14);\n        b = c + rotate_left(b + G(c, d, a) + x[4] + 0xe7d3fbc8, 20);\n        a = b + rotate_left(a + G(b, c, d) + x[9] + 0x21e1cde6, 5);\n        d = a + rotate_left(d + G(a, b, c) + x[14] + 0xc33707d6, 9);\n        c = d + rotate_left(c + G(d, a, b) + x[3] + 0xf4d50d87, 14);\n        b = c + rotate_left(b + G(c, d, a) + x[8] + 0x455a14ed, 20);\n        a = b + rotate_left(a + G(b, c, d) + x[13] + 0xa9e3e905, 5);\n        d = a + rotate_left(d + G(a, b, c) + x[2] + 0xfcefa3f8, 9);\n        c = d + rotate_left(c + G(d, a, b) + x[7] + 0x676f02d9, 14);\n        b = c + rotate_left(b + G(c, d, a) + x[12] + 0x8d2a4c8a, 20);\n\n        // Round 3\n        a = b + rotate_left(a + H(b, c, d) + x[5] + 0xfffa3942, 4);\n        d = a + rotate_left(d + H(a, b, c) + x[8] + 0x8771f681, 11);\n        c = d + rotate_left(c + H(d, a, b) + x[11] + 0x6d9d6122, 16);\n        b = c + rotate_left(b + H(c, d, a) + x[14] + 0xfde5380c, 23);\n        a = b + rotate_left(a + H(b, c, d) + x[1] + 0xa4beea44, 4);\n        d = a + rotate_left(d + H(a, b, c) + x[4] + 0x4bdecfa9, 11);\n        c = d + rotate_left(c + H(d, a, b) + x[7] + 0xf6bb4b60, 16);\n        b = c + rotate_left(b + H(c, d, a) + x[10] + 0xbebfbc70, 23);\n        a = b + rotate_left(a + H(b, c, d) + x[13] + 0x289b7ec6, 4);\n        d = a + rotate_left(d + H(a, b, c) + x[0] + 0xeaa127fa, 11);\n        c = d + rotate_left(c + H(d, a, b) + x[3] + 0xd4ef3085, 16);\n        b = c + rotate_left(b + H(c, d, a) + x[6] + 0x04881d05, 23);\n        a = b + rotate_left(a + H(b, c, d) + x[9] + 0xd9d4d039, 4);\n        d = a + rotate_left(d + H(a, b, c) + x[12] + 0xe6db99e5, 11);\n        c = d + rotate_left(c + H(d, a, b) + x[15] + 0x1fa27cf8, 16);\n        b = c + rotate_left(b + H(c, d, a) + x[2] + 0xc4ac5665, 23);\n\n        // Round 4\n        a = b + rotate_left(a + I(b, c, d) + x[0] + 0xf4292244, 6);\n        d = a + rotate_left(d + I(a, b, c) + x[7] + 0x432aff97, 10);\n        c = d + rotate_left(c + I(d, a, b) + x[14] + 0xab9423a7, 15);\n        b = c + rotate_left(b + I(c, d, a) + x[5] + 0xfc93a039, 21);\n        a = b + rotate_left(a + I(b, c, d) + x[12] + 0x655b59c3, 6);\n        d = a + rotate_left(d + I(a, b, c) + x[3] + 0x8f0ccc92, 10);\n        c = d + rotate_left(c + I(d, a, b) + x[10] + 0xffeff47d, 15);\n        b = c + rotate_left(b + I(c, d, a) + x[1] + 0x85845dd1, 21);\n        a = b + rotate_left(a + I(b, c, d) + x[8] + 0x6fa87e4f, 6);\n        d = a + rotate_left(d + I(a, b, c) + x[15] + 0xfe2ce6e0, 10);\n        c = d + rotate_left(c + I(d, a, b) + x[6] + 0xa3014314, 15);\n        b = c + rotate_left(b + I(c, d, a) + x[13] + 0x4e0811a1, 21);\n        a = b + rotate_left(a + I(b, c, d) + x[4] + 0xf7537e82, 6);\n        d = a + rotate_left(d + I(a, b, c) + x[11] + 0xbd3af235, 10);\n        c = d + rotate_left(c + I(d, a, b) + x[2] + 0x2ad7d2bb, 15);\n        b = c + rotate_left(b + I(c, d, a) + x[9] + 0xeb86d391, 21);\n\n        state[0] += a;\n        state[1] += b;\n        state[2] += c;\n        state[3] += d;\n\n        // 清理局部变量\n        memset(x, 0, sizeof(x));\n    }\n\n    void decodeBlock(const uint8 block[64], uint32 x[16]) {\n        // MD5 使用小端（little-endian）将 64 字节块分解为 16 个\n        // 32-bit 值\n        for (int i = 0; i < 16; ++i) {\n            x[i] = (uint32)block[i * 4] |\n                   (uint32)block[i * 4 + 1] << 8 |\n                   (uint32)block[i * 4 + 2] << 16 |\n                   (uint32)block[i * 4 + 3] << 24;\n        }\n    }\n\n    void encodeBits(uint8 output[8]) {\n        // 输出 bit 计数（小端）\n        uint64_t bits = ((uint64_t)count[1] << 32) | count[0];\n        for (int i = 0; i < 8; ++i) {\n            output[i] = (uint8)(bits & 0xFF);\n            bits >>= 8;\n        }\n    }\n\n    void encodeState(uint8 digest[16]) {\n        for (int i = 0; i < 4; ++i) {\n            digest[i * 4] = (uint8)(state[i] & 0xFF);\n            digest[i * 4 + 1] = (uint8)((state[i] >> 8) & 0xFF);\n            digest[i * 4 + 2] = (uint8)((state[i] >> 16) & 0xFF);\n            digest[i * 4 + 3] = (uint8)((state[i] >> 24) & 0xFF);\n        }\n    }\n\nprivate:\n    uint32 state[4];\n    uint32 count[2];   // bit count, low-order then high-order\n    uint8 buffer[64];\n};\n\n// 公有接口：返回 16 字节 MD5 摘要\nstd::vector<uint8> md5_raw(const std::string& s) {\n    MD5 ctx;\n    ctx.update(reinterpret_cast<const uint8*>(s.data()), s.size());\n    uint8 digest[16];\n    ctx.finalize(digest);\n    return std::vector<uint8>(digest, digest + 16);\n}\n\n// 将 MD5 前 4 字节按大端合并成 uint32\nunsigned int md5_to_uint(const std::string& s) {\n    auto d = md5_raw(s);\n    // d[0]..d[15] 是小端编码的 MD5 输出（因为 encodeState 按小端写\n    // state） 我们取前 4 个字节（d[0]..d[3]）并按大端解释为\n    // uint32（通常便于作为哈希环位置）\n    unsigned int x = (static_cast<unsigned int>(d[0]) << 24) |\n                     (static_cast<unsigned int>(d[1]) << 16) |\n                     (static_cast<unsigned int>(d[2]) << 8) |\n                     (static_cast<unsigned int>(d[3]));\n    return x;\n}\n\n// 简单的十六进制输出帮助函数（用于验证）\nstd::string md5_hex(const std::string& s) {\n    auto d = md5_raw(s);\n    static const char* hex = \"0123456789abcdef\";\n    std::string out;\n    out.reserve(32);\n    for (int i = 0; i < 16; ++i) {\n        out.push_back(hex[(d[i] >> 4) & 0xF]);\n        out.push_back(hex[d[i] & 0xF]);\n    }\n    return out;\n}\n```\n```C++ [md5.h]\n#pragma once\n#include <string>\n\nunsigned int md5_to_uint(const std::string& s);\nstd::string md5_hex(const std::string& s);\n```\n:::\n","cover":"https://pic.akorin.icu/20250826190318220.webp","date":"2025-08-26 15:46:58"},{"title":"九个二叉树常见问题","tags":["算法","二叉树","编程","C++"],"categories":["算法"],"author":"akorin","excerpt":"\n一些经典的关于二叉树的算法问题。\n\n# 我脑子不转了，有什么头猪吗。\n\n","link":"/posts/%E4%B9%9D%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98","content":"\n一些经典的关于二叉树的算法问题。\n\n# 我脑子不转了，有什么头猪吗。\n\n<!-- more -->\n\n## 树区间元素搜索问题\n\n比如在某一棵BST树中，输出区间为 `10~50` 之间的所有数。\n\n区间内的节点就输出，如果在区间外就不用遍历了。\n\n其实不用中序遍历也行，但是中序遍历输出就是有序的值。\n```C++\nvoid findValues(Node* node, int i, int j) {\n    if (!node)\n        return;\n    // 中序遍历\n    if (node->data_ > i)\n        findValues(node->left_, i, j);   // L\n    // V\n    if (node->data_ <= j && node->data_ >= i) {\n        cout << node->data_ << \" \";\n    }\n    if (node->data_ < j)\n        findValues(node->right_, i, j);   // R\n}\nvoid findValues(int i, int j) {\n    findValues(root_, i, j);\n    cout << endl;\n}\n```\n\n## 判断一颗二叉树是否是BST树\n\n利用 **中序遍历升序** 的特点，只要发现当前节点的值小于前一个节点的值，那就判断肯定不是BST树。\n\n:::warning\n不要用局部的 左孩子 < 根节点 < 右孩子 来判断是否是BST树，应该看全局。\n:::\n\n```C++\n// 需要只用引用指针，否则更改指针也只是更改拷贝的指针，带不回上一层\nstatic bool isBST(Node* node, Node* &pre) {\n    if (!node)\n        return true;\n    if (!isBST(node->left_, pre))\n        return false;\n    // V\n    Comp comp_; // typename Comp = less<T>\n    // 第一次回程时pre指针依然是nullptr，此时跳过\n    if (pre && comp_(node->data_, pre->data_)) {\n        return false;\n    }\n    // 如果满足条件，更新当前正在遍历的父节点\n    pre = node;\n    // 进入右子树遍历\n    return isBST(node->right_, pre);\n}\n```\n\n## BST树求子树问题\n\n判断子树是不是大树的一部分，判断是否有多余的节点。如果子树有节点而大树没有，说明该子树不是大树的子树。\n\n```C++\nbool isChildTree(BSTree<T>& child) {\n    // 在当前二叉树上找child树的根节点\n    if (!child.root_)\n        return true;\n    Node* cur = root_;\n    // 找与子树根节点相同的节点\n    while (cur) {\n        if (cur->data_ == child.root_->data_) {\n            break;\n        } else if (comp_(cur->data_, child.root_->data_)) {\n            cur = cur->right_;\n        } else {\n            cur = cur->left_;\n        }\n    }\n    // 没找到\n    if (!cur)\n        return false;\n    return isChildTree(cur, child.root_);\n}\nbool isChildTree(Node* father, Node* child) {\n    if (!father && !child) {\n        return true;\n    } else if (father && !child) {\n        // 大树有节点子树没有\n        return true;\n    } else if (!father && child){\n        // 子树有节点大树没有\n        return false;\n    } else {\n        // 大树和子树都有节点\n        if (father->data_ != child->data_) {\n            return false;\n        }\n        // if (!isChildTree(father->left_, child->left_)) {\n        //     return false;\n        // }\n        // return isChildTree(father->right_,child->right_);\n        // 上面那4行就直接浓缩成下面这一行\n        return isChildTree(father->left_,child->left_) &&\n            isChildTree(father->right_,child->right_);\n    }\n}\n```\n\n## 求LCA最近公共祖先节点\n\n给定一棵二叉树（不一定是 BST），以及两个节点 p 和 q，它们的 **最近公共祖先（Lowest Common Ancestor, LCA）** 定义为：  \n在树中同时拥有 p、q 作为后代（允许一个节点是它自身的后代）的最深的那个节点。\n\n### 如何找到最近祖先节点？\n\n两个节点的最小祖先节点，它们必定在祖先节点的两边。\n\n```C++\nint getLCA(int val1, int val2) {\n    Node* p = getLCA(root_, val1, val2);\n    if (!p)\n        throw \"No LCA!\";\n    return getLCA(root_, val1, val2)->data_;\n}\nNode* getLCA(Node* node, int val1, int val2) {\n    if (!node)\n        return nullptr;\n    if (node->data_ < val1 && node->data_ < val2) {\n        // 根节点均小于两数，说明最小祖先在右孩子\n        return getLCA(node->right_, val1, val2);\n    } else if (node->data_ > val2 && node->data_ > val2) {\n        // 根节点均大于两数，说明最小祖先在左孩子\n        return getLCA(node->left_, val1, val2);\n    } else {\n        // 找到LCA\n        return node;\n    }\n}\n```\n\n## 二叉树镜像翻转问题\n\n将一个二叉树或BST树照镜子一样翻转过来。\n\n```mermaid\ngraph TD;\n    A(8) --> B(3);\n    A --> C(10);\n    B --> D(1);\n    B --> E(6);\n    E --> F(4);\n    E --> G(7);\n    C --> H(14);\n    H --> I(13);\n```\n镜像后：\n```mermaid\ngraph TD;\n    A(8) --> C(10);\n    A --> B(3);\n    C --> H(14);\n    H --> I(13);\n    B --> E(6);\n    B --> D(1);\n    E --> G(7);\n    E --> F(4);\n```\n\n遍历根节点时，直接交换左右孩子即可。\n\n\n```C++\n  void mirror() {\n      mirror(root_);\n  }\n  void mirror(Node* node) {\n      if (!node)\n          return;\n      // v\n      Node* p = node->left_;\n      node->left_ = node->right_;\n      node->right_ = node->left_;\n      mirror(node->left_); // l\n      mirror(node->right_);// r\n  }\n```\n\n## 二叉树镜像对称问题\n\n判断该树是否是对称的：\n\n```mermaid\ngraph TB;\n    A(1);\n    A --> B(2);\n    A --> C(2);\n\n    B --> B1(3);\n    B --> B2(4);\n\n    C --> C1(4);\n    C --> C2(3);\n\n    B1 --> B1L(5);\n    C2 --> C2R(5);\n```\n\n左右孩子都是相等的\n\n```C++\nbool isMirror() {\n    return isMirror(root_,root_);\n}\nbool isMirror(Node* p, Node* q) {\n    // 一直遍历到底都相等就返回true\n    if (!p && !q) {\n        return true;\n    }\n    if (!q || !p) {\n        return false;\n    }\n    if (p->data_ != q->data_) {\n        return false;\n    }\n    return isMirror(p->left_, q->right_) &&\n            isMirror(p->right_, q->left_);\n\n}\n```\n\n## 前序遍历和中序遍历重建二叉树\n\n已知一棵二叉树的\n\n前序遍历序列：`Pre = [ 根 | 左子树前序 | 右子树前序 ]`\n\n中序遍历序列：`In  = [ 左子树中序 | 根 | 右子树中序 ]`\n\n利用前序的 **“第一个一定是当前子树的根”** ，结合中序里根的位置能切出左右子树区间，从而递归重建整棵树。\n\n因此：\n- 前序遍历确定根。\n- 中序确定哪个是左孩子哪个是右孩子。\n\n前序的起始第 `i` 个元素就是分界点，在中序中确定左右子树的范围。\n\n```C++\nNode* rebuild(int pre[], int i, int j, int in[], int m, int n) {\n    if (i > j || m > n) {\n        // 当前创建完毕\n        return nullptr;\n}\n// 创建当前子树的根节点\nNode* root = new Node(pre[i]);\nfor (int k = m; k <= n; ++k) {\n    if (in[k] == pre[i]) {\n        root->left_ =\n            rebuild(pre, i + 1, i + k - m, in, m, k - 1);\n        root->right_ =\n            rebuild(pre, i + k - m + 1, j, in, k + 1, n);\n        return root;\n    }\n}\nreturn root;\n```\n\n其中 `i` `j` `m` `n` 的含义：\n- `i`：当前子树在前序数组 `pre` 中的起始下标（该位置元素就是当前子树根）。\n- `j`：当前子树在前序数组中的结束下标（`[i..j]` 是这棵子树的完整前序片段，包含根 + 左子树 + 右子树）。\n- `m`：当前子树在中序数组 `in` 中的起始下标。\n- `n`：当前子树在中序数组中的结束下标（`[m..n]` 是这棵子树的完整中序片段）。\n\n找到根值在中序中的位置 `k(m <= k <= n)`后：\n\n假设已知了前序数组和中序数组：\n- `pre = [58 24 0 5 34 41 67 62 64 69 78]`\n- `in = [0 5 24 34 41 58 62 64 67 69 78]`\n\n- 左子树节点个数 `k - m`\n- 左子树：\n    - 前序区间 `[i+1 .. i+k-m]`\n    - 中序区间 `[m   .. k-1]`\n- 右子树：\n    - 前序区间 `[i+k-m+1 .. j]`\n    - 中序区间 `[k+1 .. n]`\n\n![](https://pic.akorin.icu/20250901003048555.webp)\n\n## 判断二叉树是否是平衡树\n\n平衡树：任意节点的左右孩子的高度差不能超过1。\n\n只有 **每一层** 的左右子树高度差都不超过1才行。\n\n:::code-group\n```C++ [常规写法]\nbool isBalance() {\n    bool is = true;\n    isBalance(root_, 0, is);\n    return is;\n}\nint isBalance(Node* node, int l, bool& is) {\n    if (!node)\n        return l;\n    int left = isBalance(node->left_, l + 1, is);\n    if (!is)\n        return left;\n    int right = isBalance(node->right_, l + 1, is);\n    if (!is)\n        return right;\n    int diff = left >= right ? left - right : right - left;\n    is = (diff <= 1) & is;\n    // 返回最深层\n    return left > right ? left : right;\n}\n```\n```C++ [简洁写法]\nbool isBanlance() {\n    return isBanlance(root_) != -1;\n}\nint isBalance(Node* node) {\n    if (!node)\n        return 0;\n    int lh = isBalance(node->left_);\n    if (lh == -1) return -1;\n    int rh = isBalance(node->right_);\n    if (rh == -1) return -1;\n    int diff = lh > rh ? lh - rh : rh - lh;\n    if (diff > 1) {\n        return -1;\n    }\n    return lh > rh ? lh + 1 : rh + 1;\n}\n```\n:::\n\n## 求BST树中序遍历的倒数第k个节点\n\n中序VLR求倒数第k个 = **VRL** 求正数第k个。\n\nVRL相当于VLR的倒序。\n\n\n```C++\nint getKVal(int k) {\n    // 从1开始算\n    int i = 0;\n    Node* p = getKVal(root_, i, k);\n    if (p)\n        return p->data_;\n    else {\n        throw \"no data\";\n    }\n}\nNode* getKVal(Node* node, int& n, int k) {\n    if (!node)\n        return nullptr;\n    Node* nr = getKVal(node->right_, n, k);\n    if (nr)\n        return nr;\n    // V\n    if (++n == k) {\n        return node;   // 在VRL下找到正数第k个\n    }\n    Node* nl = getKVal(node->left_, n, k);\n    return nl ? nl : nr;\n}\n```\n\n:::warning 在这里要注意\n\n不能直接将临时值（右值）赋给非常量引用。要修改非常量引用的值，必须对引用本身执行 `++n`、`n += 1` 或 `n = n + 1`，而不是试图通过传递 `n+1` 达到“自增”效果。下面这段代码就是错误的。\n\n```C++\nNode* nr = getKVal(node->right_, n + 1, k); // [!code error]\n```\n\nconst 左值引用 (const T&) 可以绑定到：\n- 左值（可转换）\n- 右值 / 临时对象 / 字面量 / 表达式结果（比如 n+1） 绑定后临时对象的生命周期被延长到该引用的作用域结束。\n\n表达式 `n+1` 产生一个右值，没有名字；只有 `const T&` 或 `T&&` 能接它；`T&` 不行。\n\n:::\n","cover":"https://pic.akorin.icu/20250827175108039.webp","date":"2025-08-31 13:37:48"},{"title":"二叉树","tags":["算法","二叉树","编程","C++"],"categories":["算法"],"author":"akorin","excerpt":"\n# 二叉树\n二叉树（Binary Tree）是一种 树形数据结构，它的每个节点最多有 两个子节点，通常称为：\n- 左子节点（Left Child）\n- 右子节点（Right Child）\n所以，二叉树的每个节点最多分叉 2 个，而不是任意多个。\n\n","link":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91","content":"\n# 二叉树\n二叉树（Binary Tree）是一种 树形数据结构，它的每个节点最多有 两个子节点，通常称为：\n- 左子节点（Left Child）\n- 右子节点（Right Child）\n所以，二叉树的每个节点最多分叉 2 个，而不是任意多个。\n\n<!-- more -->\n\n## 各种节点\n\n- **根节点**：二叉树最顶端的节点，没有父节点。\n- **父节点**：有子节点的节点，直接连接其子节点。\n- **子节点**：由父节点直接指向的节点。\n- **兄弟节点**：拥有同一个父节点的节点。\n- **叶子节点**：没有任何子节点的节点。\n- **内部节点**：既不是根节点也不是叶子节点的节点。\n- **左孩子节点**：父节点的左边分支上的节点。\n- **右孩子节点**：父节点的右边分支上的节点。\n- **祖先节点**：从根节点到该节点路径上的所有节点。\n- **后代节点**：以某节点为根的子树中的所有节点。\n\n## 搜索二叉树\n\n对于二叉树上的每一个节点，如果满足：\n\n**左孩子的值 < 父节点的值 < 右孩子的值**\n\n则称为 **搜索二叉树(BST, Binary Search Tree)**\n\n推广到大范围：\n\n**左孩子的所有值都小于父节点，右孩子的所有值都大于父节点**\n\n第 $L$ 层的孩子节点 $n$ 个数公式如下：\n\n$$\nn = 2^{(L-1)}\n$$\n\n### 插入节点\n\n1. 从根节点开始，比较插入值 `val` 与当前节点值 `cur->val`\n2. 如果 `val < cur->val`，进入左子树；如果 `val > cur->val`，进入右子树\n3. 递归或循环找到空位置，插入新节点\n4. 保持 BST 性质不变\n\n### 删除节点\n\n1. **节点没有孩子（叶子）**\n   - 直接删除节点即可\n2. **节点只有一个孩子**\n   - 用孩子顶替节点位置\n   - 如果删除的是根节点，更新 root 指针\n3. **节点有两个孩子**\n   - 找右子树最小节点（也叫做 **后继节点** ）（或左子树最大节点（也叫做 **前驱节点** ））\n   - 用该节点值覆盖要删除节点\n   - 删除右子树最小节点（或左子树最大节点），其孩子数 ≤ 1\n\n### 寻找节点\n\n1. 从根节点开始，设当前节点为 `cur`\n2. 比较目标值 `key` 与 `cur->val`\n   - 如果 `key == cur->val` → 找到节点，返回\n   - 如果 `key < cur->val` → 进入左子树继续查找\n   - 如果 `key > cur->val` → 进入右子树继续查找\n3. 若节点为空 (`nullptr`) → 查找失败，节点不存在\n\n```C++ [非递归实现增删查]\ntemplate<typename T, typename Comp = less<T>>\nclass BSTree {\npublic:\n    BSTree(Comp camp = Comp()) : root_(nullptr),comp_(camp) {}\n\npublic:\n    // 避免不必要的拷贝\n    bool insert(const T& val) {\n        if (root_ == nullptr) {\n            root_ = new Node(val);\n            return true;\n        }\n        Node* parent = nullptr;\n        Node* cur = root_;\n\n        while (cur) {\n            parent = cur;\n            if (comp_(val, cur->data_)) {\n                cur = cur->left_;\n            } else if (comp_(cur->data_, val)) {\n                cur = cur->right_;\n            } else {\n                // 不计入重复数\n                return false;\n            }\n        }\n        cur = new Node(val);\n        if (comp_(val, parent->data_)) {\n            parent->left_ = cur;\n        } else {\n            parent->right_ = cur;\n        }\n        return true;\n    }\n    bool del(const T& val) {\n        if (!root_) {\n            return false;\n        }\n        Node* cur = root_;\n        Node* parent = nullptr;\n\n        // 移动cur\n        while (cur) {\n            if (comp_(val, cur->data_)) {\n                parent = cur;\n                cur = cur->left_;\n            } else if (comp_(cur->data_, val)) {\n                parent = cur;\n                cur = cur->right_;\n            } else {\n                // 找到了/没找到\n                break;\n            }\n        }\n        // 没找到\n        if (!cur)\n            return false;\n\n        // 先处理情况3：\n        // root有两个孩子节点\n        // 处理完成后自动变成处理情况1/2\n        if (cur->left_ && cur->right_) {\n            Node* p = cur;\n            parent = cur;\n            cur = cur->left_;\n            while (cur->right_) {\n                // 在这里找前驱，也可以找后继\n                parent = cur;\n                cur = cur->right_;\n            }\n            // 此时出来后 cur 即为最大的左子树值\n            // cur 也是前驱节点\n            p->data_ = cur->data_;\n        }\n\n        // 此时处理情况1/2\n        // 要判断处理此时前驱节点的孩子\n        // 此时有可能是删的只有一个孩子的头节点\n        Node* child = cur->left_ ? cur->left_ : cur->right_;\n        if (!parent) {\n            // 删只有一个孩子的头节点\n            root_ = child;\n        } else if (parent->left_ == cur) {\n            parent->left_ = child;\n        } else {\n            parent->right_ = child;\n        }\n        delete cur;\n        return true;\n    }\n    bool find(const T& val) {\n        Node* cur = root_;\n        while (cur) {\n            if (comp_(val, cur->data_)) {\n                cur = cur->left_;\n            } else if (comp_(cur->data_, val)) {\n                cur = cur->right_;\n            } else {\n                // 不计入重复数\n                return true;\n            }\n        }\n        return false;\n    }\n\nprivate:\n    struct Node {\n        Node(T data = T()) :\n            data_(data), left_(nullptr), right_(nullptr) {}\n        T data_;\n        Node* left_;\n        Node* right_;\n    };\n\nprivate:\n    Comp comp_;\n    Node* root_;\n};\n```\n\n### 递归的前中后层序遍历\n\n- V：根节点\n- L：左孩子节点\n- R：右孩子节点\n\n**不管是什么遍历都是L出现在R之前。**\n\n访问头节点的次序决定了不同的访问方式，因此就有：\n\n- VLR：前序遍历\n- LVR：中序遍历\n- LRV：后序遍历\n\n访问根节点的孩子后，当前的孩子节点又作为根节点来访问孩子。\n\n对于BST树，由于排列方式都是 左孩子<根节点<右孩子。因此 **BST树中序遍历后就是一个从小到大升序的数列。**\n\n:::code-group\n```C++ [前序遍历]\nvoid preOrder() {\n    preOrder_(root_);\n}\nvoid preOrder_(Node* p) {\n    if (!p)\n        return;\n    cout << p->data_ << \" \";\n    preOrder_(p->left_);\n    preOrder_(p->right_);\n}\n```\n```C++ [中序遍历]\nvoid inOrder() {\n    inOrder_(root_);\n}\nvoid inOrder_(Node* p) {\n    if (!p)\n        return;\n    inOrder_(p->left_);\n    cout << p->data_ << \" \";\n    inOrder_(p->right_);\n}\n```\n```C++ [后序遍历]\nvoid postOrder() {\n    postOrder_(root_);\n}\nvoid postOrder_(Node* p) {\n    if (!p)\n        return;\n    postOrder_(p->left_);\n    postOrder_(p->right_);\n    cout << p->data_ << \" \";\n}\n```\n```C++ [层序遍历]\n// 获取当前树的层数\nint getLevel() {\n    return getLevel_(root_);\n}\n// 获取树总节点个数\nint getNum() {\n    return getNum_(root_);\n}\nvoid levelOrder() {\n    int level = getLevel();\n    for (int i = 0; i < level; ++i) {\n        levelOrder_(root_, i);\n    }\n}\n\nint getLevel_(Node* p) {\n    if (!p)\n        return 0;\n    int left = getLevel_(p->left_);\n    int right = getLevel_(p->right_);\n    return left > right ? left + 1 : right + 1;\n}\nint getNum_(Node* p) {\n    if (!p)\n        return 0;\n    int left = getNum_(p->left_);\n    int right = getNum_(p->right_);\n    return left + right + 1;\n}\nvoid levelOrder_(Node* p, int l) {\n    if (!p)\n        return;\n    // 当记录层l归0说明到达该层\n    if (!l) {\n        cout << p->data_ << \" \";\n        return;\n    }\n    levelOrder_(p->left_,l - 1);\n    levelOrder_(p->right_,l - 1);\n}\n```\n:::\n\n### 递归插入\n\n1. 像查询一样，要插入的值与头节点做比较，小的往左大的往右走。\n2. 进入下一层，直至为 `nullptr`。\n3. 到达 `nullptr` 层时说明找到了要插入的位置，那就要让上一层连接到该层。\n4. 返回该层的节点。\n\n```C++\nvoid insert(const T& val) {\n    // 插入第一个元素的时候没有对root进行更新\n    root_ = insert_(root_,val);\n}\n\nNode* insert_(Node* p, const T &val) {\n    // 出口:找到了要插入的位置\n    if (!p) {\n        return new Node(val);\n    }\n    // 避免重复插入\n    if (p->data_ == val) {\n        return p;\n    } else if (comp_(val, p->data_)) {\n        p->left_ = insert_(p->left_, val);\n        return p;\n    } else {\n        p->right_ = insert_(p->right_, val);\n        return p;\n    }\n}\n```\n\n### 递归搜索\n\n1. 搜索就只需要找到值即可。\n2. 没有新插入的值，不用让上一层连接到该层，找到就返回节点即可。\n\n```C++\nNode* find(const T& val) {\n    return find_(root_, val);\n}\n\nNode* find_(Node* p, const T& val) {\n    if (!p) {\n        return nullptr;\n    }\n    if (p->data_ == val) {\n        return p;\n    } else if (comp_(val, p->data_)) {\n        return  find_(p->left_, val);\n    } else {\n        return  find_(p->right_, val);\n    }\n}\n```\n\n### 递归删除\n\n1. 由于要删除节点，孩子要变化，因此需要将变化的孩子连接到上一层。\n2. 找到要删除的节点就要判断是否是情况三（有两个孩子）。\n3. 如果是情况3就需要找到前驱/后继节点并删除，删除前驱/后继就直接转移到了删除情况1/2。\n4. 因为每一层都会连接对应的孩子，因此如果是情况1/2，删除前驱/后继节点后，返回其孩子的节点。\n\n```C++\nvoid remove(const T& val) {\n    root_ = remove_(root_, val);\n}\n\nNode* remove_(Node* p, const T& val) {\n    if (!p) {\n        return nullptr;\n    }\n    if (p->data_ == val) {\n        // 删除操作，返回删除过后新的孩子\n        // 情况3\n        if (p->left_ && p->right_) {\n            Node* pre = p->left_;\n            while (pre->right_) {\n                pre = pre->right_;\n            }\n            // 找到前驱，前驱至多有一个孩子\n            p->data_ = pre->data_;\n            // 删除前驱节点，到达情况1/2那一层\n            p->left_ = remove_(p->left_, pre->data_);\n            return p;\n        }\n        // 情况1/2（只有一个孩子或无孩子）\n        Node* q = p->left_ ? p->left_ : p->right_;\n        delete p;\n        return q;\n    } else if (comp_(val, p->data_)) {\n        p->left_ = remove_(p->left_, val);\n    } else {\n        p->right_ = remove_(p->right_, val);\n    }\n    return p;\n}\n```\n\n### 非递归的前中后层序遍历\n\n遍历不是说只用递归就万事大吉了，非递归形式也是很有必要的。递归有个缺点就是占用栈空间太大了，而栈的容量小，容易爆栈。在工程上一般还是非递归的代码较多。\n\n非递归下，需要借助其它的数据结构来存储。比如说 **栈** 。\n\n根据栈的先入后出原则， **先要遍历的后入栈**。\n\n**编程的固定模式：**\n1. 深度遍历：使用 **栈** 结构。\n2. 广度遍历：使用 **队列** 结构。\n\n#### 前序遍历VLR\n\n由于右孩子最后才访问，需要把右孩子先保存着，后面再访问。\n\n1. 先把右孩子压进栈。\n2. 再压左孩子，左孩子再出栈（如果有）。\n3. 此时把左孩子作为根节点，重复1 2步骤。\n\n```C++\nvoid npreOrder() {\n    cout << \"非递归前序遍历\" << endl;\n    if (!root_)\n        return;\n    stack<Node*> s;\n    s.push(root_);\n    while (!s.empty()) {\n        Node* top = s.top();\n        s.pop();\n        // 处理v\n        cout << top->data_ << \" \";\n        if (top->right_)\n            s.push(top->right_); // R\n        if (top->left_)\n            s.push(top->left_); // L\n    }\n    cout << endl;\n}\n```\n\n#### 中序遍历LVR\n\n这里要先访问左孩子，则需要先存入所有的左孩子。\n\n1. 要先保存所有的左孩子直至 `nullptr` 。\n2. 然后弹栈1个节点。此时出栈的节点就是父节点，即V。\n3. 用一个指针 `cur` 指向该父节点的右孩子，在下一次循环中判断是否存在，若存在返回到步骤1。\n4. 当栈空且指针为 `nullptr` 时结束。\n\n```C++\nvoid ninOrder() {\n    if (!root_)\n        return;\n    cout << \"非递归中序遍历\" << endl;\n    stack<Node*> s;\n    Node* cur = root_;\n    while (!s.empty() || cur) {\n        // 先存入所有左孩子\n        while (cur) {\n            s.push(cur);\n            cur = cur->left_;\n        }\n        Node* top = s.top();\n        s.pop();\n        cout << top->data_ << \" \";\n        cur = top->right_;\n    }\n    cout << endl;\n}\n```\n\n#### 后序遍历LRV\n\n- 后序遍历有两种思路，一个是先反向得 **VRL**，然后再反向输出就得到后续遍历，此时需要 **两个栈** 来存储。\n    1. 准备两个栈 `s1` 和 `s2`。\n    2. 按照前序遍历那样，左孩子先入栈 `s1` 再压右孩子。\n    3. 右孩子出栈时不要打印，压入到另一个栈 `s2` 。接着处理右孩子的左右孩子。\n    4. 遍历完毕后， `s2` 存入的顺序就是 **VRL** ，此时 `s2` 再全部弹出，其输出的顺序就是 **LRV** 了，满足后序遍历的条件。\n\n\n- 还有一种就是延续中序遍历得思想，进入右孩子时先进行一个判断，先判断这个右孩子是否已经进去过了，如果进去过了说明已经轮到该父节点弹栈了。\n    1. 先把所有左孩子压入栈，和中序遍历一样。\n    2. 此时弹出一个节点，该节点就是父节点。\n    3. 判断是否有右孩子，若有就将当前指针 `cur` 指向其右孩子，然后重复步骤1。\n    4. 若没有说明到头了该弹出父节点并输出， 更新 `pre` 指针到当前弹出的节点，返回到步骤3。\n    5. 在循环中若上一次弹出的节点就是当前父节点的右孩子，说明右孩子已遍历过，返回到步骤4。\n\n    :::info 要如何判断是否进入过右孩子呢？\n\n    用一个指针指向上一次弹过栈的节点，判断右孩子是否是上一次弹过的节点，如果是就说明进去过了。\n\n    :::\n\n:::code-group\n```C++ [双栈反序遍历思想]\nvoid n1postOrder() {\n    if (!root_)\n        return;\n    stack<Node*> s1;\n    stack<Node*> s2;\n    s1.push(root_);\n    while (!s1.empty()) {\n        Node* top = s1.top();\n        s1.pop();\n        // 出栈就放入另一个栈\n        s2.push(top);\n        if (top->left_) {\n            s1.push(top->left_);\n        }\n        if (top->right_) {\n            s1.push(top->right_);\n        }\n    }\n    while (!s2.empty()) {\n        cout << s2.top()->data_ << \" \";\n        s2.pop();\n    }\n    cout << endl;\n}\n```\n```C++ [延续中序遍历思想]\nvoid npostOrder() {\n    if (!root_)\n        return;\n    Node* cur = root_;\n    Node* pre = nullptr;\n    stack<Node*> s;\n    while (cur || !s.empty()) {\n        while (cur) {\n            s.push(cur);\n            cur = cur->left_;\n        }\n        // 左孩子装完，此时栈顶是父节点但是不弹栈\n        Node* top = s.top();\n        // 观察当前的父节点\n        // 需要判断右孩子是否弹出过栈\n        if (top->right_ && top->right_ != pre) {\n            cur = top->right_;\n        } else { // 此时为父节点弹栈输出\n            cout << top->data_ << \" \";\n            s.pop();\n            // 此时需返程了，记录弹出了的节点\n            pre = top;\n        }\n    }\n    cout << endl;\n}\n```\n:::\n\n#### 层序遍历\n\n层序遍历也叫做广度遍历，每一层的孩子都遍历之后再访问下一层。此时可以使用 **队列** ，队列的先进先出原则正好符合需要。先入队的父节点出队，其孩子节点再入队，如此循环往复。\n\n1. 所有这一层的父节点先入队。\n2. 所有的父节点出队判断其孩子节点是否存在，若存在则所有父节点的所有孩子节点入队。\n3. 重复步骤1，2。\n\n```C++\nvoid nlevelOrder() {\n    if (!root_)\n        return;\n    queue<Node*> q;\n    Node* cur = root_;\n    q.push(cur);\n    while (!q.empty()) {\n        Node* front = q.front();\n        q.pop();\n        cout << front->data_ << \" \";\n        if (front->left_)\n            q.push(front->left_);\n        if (front->right_)\n            q.push(front->right_);\n    }\n    cout << endl;\n}\n```\n\n## 关于BST的构造与析构\n\n:::code-group\n```C++ [构造与析构]\ntemplate<typename T, typename Comp = less<T>>\nclass BSTree {\n\npublic:\n    BSTree(Comp camp = Comp()) : \n    root_(nullptr), \n    comp_(camp) {}\n\n    // 层序遍历释放\n    ~BSTree() {\n        if (!root_)\n            return;\n        queue<Node*> q;\n        q.push(root_);\n        while (!q.empty()) {\n            Node* front = q.front();\n            q.pop();\n            if (front->left_) {\n                q.push(front->left_);\n            }\n            if (front->right_) {\n                q.push(front->right_);\n            }\n            delete front;\n        }\n    }\n...\n}\n\n```\n```C++ [私有变量的定义]\nprivate:\n    Comp comp_;\n    Node* root_;\nprivate:\n    struct Node {\n        Node(T data = T()) :\n            data_(data), left_(nullptr), right_(nullptr) {}\n        T data_;\n        Node* left_;\n        Node* right_;\n    };\n\n```\n```C++ [复杂类型的BST树实例]\n    using Elm = pair<int, string>;\n    using Functor = function<bool(Elm, Elm)>;\n    BSTree<Elm, Functor> bst([](Elm p1, Elm p2) -> bool {\n        return p1.first > p2.first;\n    });\n```\n:::\n","cover":"https://pic.akorin.icu/20250831134230877.webp","date":"2025-08-27 17:01:08"},{"title":"信号的Matlab编程","tags":["笔记","信号与系统","速通","matlab"],"categories":["笔记"],"author":"akorin","excerpt":"\n记录基于Matlab的有关信号的编程\n\n","link":"/posts/%E4%BF%A1%E5%8F%B7Matlab","content":"\n记录基于Matlab的有关信号的编程\n\n<!-- more -->\n\n## 矩阵运算\n\n- `*`:  普通的矩阵运算，如1xn和mx1的矩阵相乘得到nxm的矩阵\n- `.*`: 对矩阵内的每个元素对应相乘\n- `:  矩阵求转置\n\n## 绘制图像\n### 连续信号\n\n$$\nf(t)=5e^{-0.8t}\\sin(\\pi t),0<t<5\n$$\n\n```matlab\na=5;\nb=0.8;\nt=0:0.01:5;\nx=b*exp(-a*t).*sin(pi*t);\nfigure(1);\nplot(t, x);\n```\n![](https://pic.akorin.icu/20250225210740529.png)\n\n### 离散信号\n\n$$\nf(t)=2(0.8)^{k},-5<k<5\n$$\n\n```matlab\nc=2;\nd=0.8;\nk=-5:5;\ny=c*(0.8).^k;\nfigure(2);\nstem(k, y);\n```\n\n![](https://pic.akorin.icu/20250225210818824.png)\n\n\n```matlab\nt=0:0.01:5;\n```\n取值范围从0到5，且步长取0.01，当省略步长，则默认为1\n\n```matlab\nx=b*exp(-a*t).*sin(pi*t);\n```\n与括号相邻的乘除（*或/）前面都要加点号（.*或./）\n\n:::warning\n\n矩阵和矩阵之间对应的元素之间的运算，在运算符(*、/、^)前也要加点号(.*、./、.^)\n\n:::\n\n\n### 函数\n\n- `plot(t,x);` 绘制连续曲线图像\n- `stem(k,y);` 绘制离散图像\n- `ezplot(表达式);` 绘制使字符表达式等于0的隐函数曲线，无需准备数据\n- `figure(n);` 简历画布\n- `subplot(a,b,c);` 将画布分为a行b列并在c块上绘制\n\n## 利用卷积与变换（拉氏变换、Z变换）求解\n### 拉普拉斯变换\n\n计算\n$$\nf_1(t)=e^{-t}\\varepsilon(t),f_2(t)=te^{-\\frac{1}{2}t}\\varepsilon(t)\n$$\n的卷积\n\n```matlab\nsyms t;                     %新建一个符号变量\nt=sym('t','positive');      %设置符号变量的属性：字符串t为符号变量且为正\nfs1=laplace(exp(-t));       %求函数f1的拉氏变换fs1\nfs2=laplace(t*exp(-t));     %求函数f1的拉氏变换fs1\nyt=simplify(ilaplace(fs1*fs2)); %求拉式反变换\nezplot(yt);                     %绘制变换后的图像\n```\n![](https://pic.akorin.icu/20250225211440024.png)\n\n\n### 离散信号Z变换\n\n求函数\n$$\nf(k)=\\cos(ak)\\varepsilon(k)\n$$\n的Z变换\n\n```matlab\nsyms k a;\nk=sym('k','positive');\nf=cos(a*k);\nF=ztrans(f)\n```\n输出：\n```matlab\n(z*(z - cos(a)))/(z^2 - 2*cos(a)*z + 1)\n\n```\n---\n求函数\n\n$$\nF(z)=\\frac{1}{(z+1)^2}\n$$\n\n的逆Z变换\n```matlab\nsyms z;\nF=1/(1+z)^2;\nf=iztrans(F)\n```\n\n输出：\n\n```matlab\nkroneckerDelta(n, 0) + (-1)^n*(n - 1)\n```\n\n### 函数\n\n- `syms`  定义符号变量，即一个自变量，不带入具体数值，是一个字符或字符串，最后的计算结果也不是固定值，而是表达式，\n- `laplace(表达式);` 求拉氏变换，输出一个字符串表达式\n- `ilaplace(表达式);` 求拉氏反变换，输出一个字符串表达式\n- `simplify(表达式);` 将表达式化为最简形式\n- `ztrans(表达式);` 求Z变换，返回一个字符串表达式\n- `iztrans(表达式);` 求逆Z变换，返回一个字符串表达式\n\n## 求卷积（利用变换求）\n\n$$\nf_1(t)=\n\\begin{cases}\n    2,0<t<1 \\\\\n    0,else\n\\end{cases},\nf_2(t)=\n\\begin{cases}\n    t,0<t<2 \\\\\n    0,else\n\\end{cases}\n$$\n用MATLAB画出 $f_1(t)*f_2(t)$\n\n```matlab\nt1=0:0.001:1;\nt2=0:0.001:2;\nft1=2*rectpuls(t1-0.5,1);\nft2=t2;\nft3=0.001*conv(ft1,ft2);\nt3=0:0.001:3;\nplot(t3,ft3);\ntitle('ft1(t)*ft2(t)')\n```\n![](https://pic.akorin.icu/20250225214019300.png)\n\n:::warning\nmatlab用conv函数求卷积时，要在前面乘上采样间隔才正确\n:::\n\n求\n$$\nx_1(k)=\\sin(k),0\\le k\\le 10 \\quad x_2(k)=0.8^k,0\\le k\\le 15\n$$\n的卷积\n```matlab\nk1=0:10;k2=0:15;\nx1=sin(k1);\nx2=0.8.^k2;\ny=conv(x1,x2);\nk=0:25;\nsubplot(3, 1, 1);stem(k1,x1);\nsubplot(3, 1, 2);stem(k2,x2);\nsubplot(3, 1, 3);stem(k,y);\n```\n![](https://pic.akorin.icu/20250225215129580.png)\n\n```matlab\nx2=0.8.^k2;\nx2=0.8^k2;  %[!code error]\n```\n由于k2是一个矩阵，不能直接用运算符与之做运算，需要在运算符前加一个点号表明将矩阵的每个元素分别做运算\n\n### 函数\n\n- `rectpuls(t-a,1);` 产生方波信号，宽度为1，中心点移到t=a处，幅度默认为1，在函数前乘系数可得不同幅度，t为时间范围\n- `square(a*t,duty);` 产生**周期**方波信号，a=1时，周期为 $2\\pi$ ，峰值为 $\\pm1$ ；duty为占比单位是%，取0-100\n- `conv(ft1,ft2);` 求这两个函数的卷积结果\n\n:::warning\n\nMatlab中的卷积函数conv(f1,f2)不区分离散和连续，都按照离散的形式来计算\n\n:::\n\n## 绘制零极点图\n### 连续系统\n\n$$\nH(s)=\\frac{s^2+4s+3}{s^4+3s^3+4s^2+6s+4}\n$$\n\n```matlab\nb=[1 4 3];          %分子系数矩阵，且为高次向低次\na=[1 3 4 6 4];      %分母系数矩阵\nsys=tf(b,a);\npzmap(sys);\nsgrid;\nzap=roots(a);\n```\n![](https://pic.akorin.icu/20250225225143483.png)\n\n### 离散系统\n\n$$\nH(z)=\\frac{z^{-1}+2z^{-2}+z^{-3}}{1-0.5z^{-1}-0.005z^{-2}+0.3z^{-3}}\n$$\n\n```matlab\nb=[1 2 1];\na=[1 -0.5 -0.005 0.3];\nfigure(1);\nzplane(b,a);\ntitle('零极点分布图');\nnum=[0 1 2 1];\nden=[1 -0.5 -0.005 0.3];\nh=impz(num,den);\nfigure(2);\nstem(h,'.');\ntitle('冲激响应图');\n[H,w]=freqz(num,den);\nfigure(3);\nplot(w/pi,abs(H));\ntitle('幅频响应');\n```\n\n<div class=\"flex flex-col\">\n\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![](https://pic.akorin.icu/20250225235445908.png)\n\n![](https://pic.akorin.icu/20250225235457967.png)\n\n![](https://pic.akorin.icu/20250225235507923.png)\n\n</div>\n\n</div>\n\n```matlab\nstem(h,'.');\n```\nh是要绘制的离散数据；'.'表示一个字符串，指定绘制数据点的标记样式\n\n### 函数\n\n- `tf(b,a);` 生成系统函数，b为分子系数向量，a为分母系数向量\n- `pzmap(sys);` 绘制连续系统函数sys的零极点图\n- `sgrid;` 绘制极坐标网格\n- `zap=roots(a);` 求出零极点\n- `zplane(b,a);` 绘制离散系统零极点分布图，分子不含常数项\n- `h=impz(num,den);` 计算和绘制离散时间系统的单位脉冲响应（冲激响应），分子包含常数项\n- `[H,w]=freqz(num,den);` 求频率响应，分子包含常数项，结果有幅值及对应的角频率\n\n## 求响应（已知系统函数）\n### 连续函数\n\n已知\n\n$$\nH(s)=\\frac{1}{s^3+2s^2+3s+1}\n$$\n\n画出零极点分布，并求单位冲激响应h(t)和频率冲激响应 $H(j\\omega)$，并判断系统是否稳定\n\n```matlab\nnum=[1];\nden=[1 2 3 1];\nsys=tf(num,den);\npoles=roots(den);\n\nfigure(1);\npzmap(sys);\nsgrid;\ntitle('Pole and Zero');\nt=0:0.02:10;\nh=impulse(num,den,t);\n\nfigure(2);\nplot(t,h);\ntitle('impulse Respone');\n[H,w]=freqs(num,den);\n\nfigure(3);\nplot(w,abs(H));     %横坐标为角频率w，纵坐标为幅度H的绝对值\ntitle('Frequency Spectrum');\n```\n\n<div class=\"flex flex-col\">\n\n<div class=\"flex grid-cols-2 justify-center\">\n\n![](https://pic.akorin.icu/20250227152233684.png)\n\n![](https://pic.akorin.icu/20250227152306961.png)\n\n![](https://pic.akorin.icu/20250227152317892.png)\n\n</div>\n\n</div>\n\n```matlab\nplot(w,abs(H));     %横坐标为角频率w，纵坐标为幅度H的绝对值\n```\n必须要有绝对值才是求幅频响应\n\n### 离散函数\n\n$$\nH(j\\omega)=\\frac{1-j\\omega}{1+j\\omega} \\quad f(t)=\\sin(t)+\\sin(3t)\n$$\n\n```matlab\nt=0:pi/100:4*pi\nb=[-1,1];\na=[1,1];\nft=sin(t)+sin(3*t);\nyt=lsim(b,a,ft,t);\nsubplot(2,1,1);\nplot(t,ft);\ntitle('激励');\nsubplot(2,1,2);\nplot(t,yt);\ntitle('响应');\n```\n![](https://pic.akorin.icu/20250227153908502.png)\n\n### 函数\n\n- `impulse(num,den,t);` 计算和绘制连续时间系统的单位脉冲响应，同时输入也可以最直接接入tf函数定义的传递函数impulse(tf(sys));\n- `lsim(b,a,ft,t);` 模拟和绘制线性时不变对任意输入信号响应\n\n## 根据状态方程求解函数响应\n### 连续系统\n\n$$\n\\begin{bmatrix}\n  \\dot{x}_1(t) \\\\\n  \\dot{x}_2(t)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  -2 & -2 \\\\\n  1 & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n  {x}_1(t) \\\\\n  {x}_2(t)\n\\end{bmatrix}\n+\\begin{bmatrix}\n  10 \\\\\n  0\n\\end{bmatrix}f(t)\n\n$$\n\n$$\n\ny(t)=\\begin{bmatrix}\n  1 & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n  {x}_1(t) \\\\\n  {x}_2(t)\n\\end{bmatrix}\n$$\n\n其中系统输入为：\n\n$$\nf(t)=t\\varepsilon(t)\n$$\n\n初始状态为：\n\n$$\n\\begin{bmatrix}\n  {x}_1(0) \\\\\n  {x}_2(0)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  5 \\\\\n  0\n\\end{bmatrix}\n$$\n\n\n```matlab\n%%%% 求零输入响应 %%%%\nA=[-2 -2;1 0];\nB=[10;0];\nC=[1 0];\nD=[0];\nv0=[5;0];\nt=0:0.01:5;\nX=[0*ones(size(t))];          %输入\n[y,v]=lsim(A,B,C,D,X,t,v0);\nsubplot(2,1,1);\nplot(t,y);\ngrid;\nxlabel('t');\nylabel('y');\ntitle('零输入响应')\n%%%% 求零状态响应 %%%%\nv0=[0;0];\nX=[1*t];                      %输入\n[y,v]=lsim(A,B,C,D,X,t,v0);\nsubplot(2,1,2);\nplot(t,y);\ngrid;\nxlabel('t');\nylabel('y');\ntitle('零状态响应')\n```\n![](https://pic.akorin.icu/20250227160441605.png)\n\n### 离散系统\n\n$$\n\\begin{bmatrix}\n  x_1(k+1) \\\\\n  x_2(k+1)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  0 & 1 \\\\\n  -1 & 1.9021\n\\end{bmatrix}\n\\begin{bmatrix}\n  x_1(k) \\\\\n  x_2(k)\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n  1 \\\\\n  0\n\\end{bmatrix}\n\\begin{bmatrix}\n  f(k)\n\\end{bmatrix}\n\n$$\n$$\n\n\ny(k)=\n\\begin{bmatrix}\n  -1 & 1\n\\end{bmatrix}\n\n\\begin{bmatrix}\n  x_1(k) \\\\\n  x_2(k)\n\\end{bmatrix}\n\n\\quad\n\n\\begin{bmatrix}\n  x_1(0) \\\\\n  x_2(0)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  -10  \\\\\n  -4\n\\end{bmatrix}\n$$\n\n```matlab\nA=[0 1;-1 1.9021];\nB=[1;0];\nC=[-1 1];\nD=[0];\nk=0:1:40;\nv0=[-10;-4];\nX=[1*ones(size(k))];\n[y,v]=dlsim(A,B,C,D,X,v0);\nstem(k,y);\nxlabel('k');\nylabel('y');\ntitle('全响应')\n```\n![](https://pic.akorin.icu/20250227161354348.png)\n\n## 实现Sa信号的采样和恢复\n\n:::tip Sa信号恢复\n\n$$\nf(t)=T_s\\frac{\\omega_c}{\\pi}\\sum\\limits_{n=-\\infty}^{\\infty}f(nT_s)Sa[\\omega_c(t-nT_s)]\n$$\n\n其中 $T_s$ 是采样周期， $\\omega_c$ 是低通滤波器的截止频率，一般取信号的最大频率\n:::\n\ne.g 信号sa(t)作为被采样信号，信号带宽B=1，即信号的最大角频率为1，采样频率 $\\omega_s=2B$ ，此频率下的采样为Nyquist采样，对采样及恢复过程用Matlab进行仿真\n\n```matlab\nws=2;wm=1;\nTs=2*pi/ws;\nN=50;\nn=-N:N;\nnTs=n.*Ts;\nfs=pi*sinc(wm*nTs/pi);\nt=-6*pi:0.001:6*pi;\n%%%% 信号重构 %%%%\nf=fs*1/pi*pi*sinc(1/pi*(ones(length(nTs),1)*t-nTs'*ones(1,length(t))));\nerror=abs(f-pi*sinc(t/pi));\nsubplot(3,1,1);plot(t,pi*sinc(t/pi));\ntitle('Sa函数原始信号')\nsubplot(3,1,2);plot(t,f);\ntitle('恢复信号')\nsubplot(3,1,3);plot(t,error);\ntitle('恢复信号与原信号之间的差值');\n```\n![](https://pic.akorin.icu/20250308212833536.png)\n\n```matlab\nf=fs*1/pi*pi*sinc(1/pi*(ones(length(nTs),1)*t-nTs'*ones(1,length(t))));\n```\n在这段代码中利用矩阵的性质，实现求和\n\n```matlab\nones(length(nTs),1)*t\n```\n这段是nx1的矩阵乘上1xm的矩阵得到nxm的矩阵，此时这个矩阵上的点都是t的点，每一列上对应不同的时间点\n```matlab\nnTs'*ones(1,length(t))\n```\nnTs的转置再乘上ones函数，将nTs矩阵扩展成nxm，此时上面的矩阵都是nTs的点，每一行对应不同的nTs的时间点\n\n两式相减后，每一列就是在单个时间t的点上t-nTs的集合，前面的fs的点数和nTs相同，fs再和后面得到的sinc的矩阵就能得到每个时间t点对应的sinc(t-nTs)的和\n\n### 函数\n\n- `fs=sinc(nTs/pi);` 即辛格函数，sinc函数与Sa函数的数学表达形式相同，有时会区分归一化sinc函数和非归一化sinc函数，而在matlab中`sinc`是归一化sinc函数\n  - 非归一化sinc函数\n  $$\n  sinc(x)=\\frac{\\sin(x)}{x}\n  $$\n  - 归一化sinc函数\n  $$\n  sinc(x)=\\frac{\\sin(\\pi x)}{\\pi x}\n  $$\n\n## 对任意信号的采样频谱分析及恢复\n\n$$\nf(t)=\\sin(2\\pi f_0 t)+ \\frac{1}{3} \\sin(6\\pi f_0 t)\n$$\n\n求该信号的频谱并在采样信号\n\n$$\nFs>2f_m,F_s=2f_m,Fs<2f_m\n$$\n\n的情况下绘制采样波形以及对采样后的信号进行恢复。其中 $f_0=1Hz$，取最高有限带宽频率 $f_m=5f_0$\n\n```matlab\nclc;clear;close all;\n\n% 信号常量\nf0=1;\nfm=5*f0;\nFs1=5*fm;Fs2=2*fm;Fs3=1*fm;\ntl=-2;th=2;\nt=tl:0.001:th;\nnTs1=tl:1/Fs1:th;\nnTs2=tl:1/Fs2:th;\nnTs3=tl:1/Fs3:th;\n\n% 原始信号和采样信号\n\nf=sin(2*pi*f0*t)+(1/3)*sin(6*pi*f0*t);\n\nfs1=sin(2*pi*f0*nTs1)+1/3.*sin(6*pi*f0*nTs1);\nfs2=sin(2*pi*f0*nTs2)+1/3.*sin(6*pi*f0*nTs2);\nfs3=sin(2*pi*f0*nTs3)+1/3.*sin(6*pi*f0*nTs3);\n\nfigure;\nsubplot(4,1,1);\nplot(t,f);\ntitle('原信号');\n\nsubplot(4, 1, 2);\nstem(nTs1,fs1,'.');\nsubplot(4, 1, 3);\nstem(nTs2,fs2,'.');\nsubplot(4, 1, 4);\nstem(nTs3,fs3,'.');\n\n% fft求各采样信号的频谱\n\nx1=fftshift(fft(fs1));f1=linspace(-Fs1/2,Fs1/2,length(x1));\nx2=fftshift(fft(fs2));f2=linspace(-Fs2/2,Fs2/2,length(x2));\nx3=fftshift(fft(fs3));f3=linspace(-Fs3/2,Fs3/2,length(x3));\n\n% 绘图\n\nfigure;\nsubplot(3, 1, 1);\nstem(f1,2.*abs(x1)/length(x1),'.');\nxlabel('f/Hz');ylabel('幅值');\n\nsubplot(3, 1, 2);\nstem(f2,2.*abs(x2)/length(x2),'.');\nxlabel('f/Hz');ylabel('幅值');\n\nsubplot(3, 1, 3);\nstem(f3,2.*abs(x3)/length(x3),'.');\nxlabel('f/Hz');ylabel('幅值');\n\n% 重建信号并求绘图\n\nF1=fs1*1/Fs1*2*pi*fm/pi*sinc(1/pi*2*pi*fm*(ones(length(nTs1),1)*t-nTs1'*ones(1,length(t))));\nfigure;\nsubplot(311);\nplot(t, F1,'r',t,f,'b');\n\nF2=fs2*1/Fs2*2*pi*fm/pi*sinc(1/pi*2*pi*fm*(ones(length(nTs2),1)*t-nTs2'*ones(1,length(t))));\nsubplot(312);\nplot(t, F2,'r',t,f,'b');\n\nF3=fs3*1/Fs3*2*pi*fm/pi*sinc(1/pi*2*pi*fm*(ones(length(nTs3),1)*t-nTs3'*ones(1,length(t))));\nsubplot(313);\nplot(t, F3,'r',t,f,'b');\n```\n\n\n<div class=\"flex flex-col\">\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![](https://pic.akorin.icu/20250310170814974.png)\n\n![](https://pic.akorin.icu/20250310170821224.png)\n\n![](https://pic.akorin.icu/20250310170845805.png)\n\n</div>\n</div>\n\n## 求群时延\n\n```matlab\nclc;clear;close all;\n\nb=[100*2e-9];\na=[22e-6*2e-9,100*2e-9,1];\n\n[h,w]=freqs(b,a);\n\n%% 普通画图：\n\n% figure;\n% subplot(2, 1, 1);\n% loglog(w,20*log10(abs(h)));\n% ylabel('幅值(dB)')\n% xlabel('频率(rad/s)')\n% title('幅频响应');\n% subplot(2, 1, 2);\n% plot(w, 180*angle(h)/pi);\n% axis([1e6,1e8,-180,0]);\n% ylabel('角度')\n% xlabel('频率(rad/s)')\n% title('相频响应');\n\n%% 直接利用freqs生成图更美观\n\nfigure;\nfreqs(b,a);\n\n%% 扩展w的个数，使画图更准确\nfigure;\nw=linspace(w(1),w(end),length(w)*1000);\n[h1,w1]=freqs(b,a,w);\ngroupDelay = -gradient(angle(h1),w1)/360;\ngrid on\n\n%% 生成对x取10为对数的坐标的图\nsemilogx(w,groupDelay)\nylabel('延迟')\nxlabel('频率(rad/s)')\n```\n\n### 函数\n\n- `gradient`: 用法：`[FX,FY] = gradient(F,H)` 或 `Fx = gradient(F,H)` 以H对离散点F求导\n\n```matlab\ngroupDelay = -gradient(angle(h1),w1)/360;\n```\n满足了群时延的定义，即角度对角频率的负导数即为群时延。群时延是系统三大特征之一（另外两个分别是幅频响应和相频响应），群时延标志着信号中的频率分量通过系统的时间。全通系统的作用就是用来对信号中某些频率分量的延时。\n","cover":"https://pic.akorin.icu/封面3.png","date":"2025-02-25 00:00:00"},{"title":"哈希表","tags":["笔记","编程","C++"],"categories":["笔记"],"author":"akorin","excerpt":"\n# 哈\n","link":"/posts/%E5%93%88%E5%B8%8C%E8%A1%A8","content":"\n# 哈\n<!-- more -->\n\n## 哈希表\n\n- 哈希表（Hash Table）：一种基于 键（key）→值（value）映射 的数据结构。\n- 核心思想：通过哈希函数（Hash Function）把 key 转换成数组下标，从而快速访问数据。\n- 时间复杂度：\n  - 查找、插入、删除：理想情况下接近 O(1)。\n  - 最坏情况下（大量冲突）：O(n)。\n\n## 哈希函数\n\n也叫 **散列函数** 或者 **映射函数** ，照某种规律将关键字k映射到某个值的函数，一般是**除留余数法**：用素数来取余（经过数学证明得出，用素数取余可以降低哈希碰撞/冲突的可能性）。\n\n常见的哈希函数有：\n- **直接函数法**： `H(key) = f(key) = a · key + b`\n- **数字分析法**：分析数字找出数字规律，利用这些数据来构造冲突纪律低的散列地址。\n- **平方取中法**：取关键字平方后的中间几位作为散列地址。\n- **折叠法**：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。\n- **随机数法**：选择一随机函数，取关键字作为随机函数的种子，生成随机值作为散列地址，通常用于关键字长度不同的场合。\n- **除留余数法**：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。\n\n## 哈希冲突\n\n- **线性探测法**：当出现冲突向后找位置，还有加强版：平方探测法，即向前或者向后以平方数来查找。\n- **链地址法** ：也叫做**拉链法**，在同一个位置用链表将数据连接起来。\n\n:::tip 装载因子\n**装载因子（loadfactor） = 已占用桶（表）的个数 / 桶的总个数**\n\n- 装载因子不能太大也不能太小。\n- 装载因子太大则输入哈希表时，发生哈希碰撞的概率就很大。\n- 装载因子太小则浪费空间。\n- 一般设定的默认值是**0.75**\n- 若装载因子超过设定的值时，一般就要为哈希表进行扩展操作。\n:::\n\n## 哈希函数（Hash Function）\n  - 插入：任意大小的 key，经过哈希函数后放入对应哈希表中的位置，装载因子超过0.75需要先**扩容**。\n  - 输出：数组索引（0 ~ table_size-1），也是经过哈希函数取得对应位置。\n  - 删除：同理，但是删除后的位置**需要放置特殊符**，避免破坏其它的位置的查找。\n  - 扩容：一般哈希表输入数据用的都是除留余数法，扩容后要给每个原来的数除上新的素数才行，因此该操作至少得O(n)。\n\n均摊下来哈希表的各种操作的时间复杂度为O(1)。\n\n### 线性探测哈希表\n\n1. 每个桶存放数据和桶的状态。\n2. 用数组来存放每个桶。\n3. 出现哈希冲突主要使用**线性探测法来解决**。\n\n```C++\n// 定义哈希表状态\nenum HState {\n    IDLE,    // 空闲\n    USING,   // 正在使用\n    DELTE    // 已删除\n};\n\n// 定义哈希表的存储结构\nstruct Bucket {\n    Bucket(int data = 0) : data_(data), state_(IDLE) {}\n    int data_;\n    HState state_;\n};\n\n// 定义哈希表功能函数\nclass HashTable {\npublic:\n    HashTable(int size = 3) : prime_(0), factor_(0.75), size_(0) {\n        for (; prime_ < 10; ++prime_) {\n            if (primeNums_[prime_] >= size)\n                break;\n        }\n        // 越界处理\n        if (prime_ == PRIMESIZE)\n            prime_--;\n        capacity_ = primeNums_[prime_];\n        table_ = new Bucket[capacity_];\n    }\n    ~HashTable() {\n        delete[] table_;\n        table_ = nullptr;\n    }\n\npublic:\n    // 插入元素\n    bool insert(int data) {\n        // 判断是否需要扩展\n        double fac = size_ * 1.0 / capacity_;\n        if (fac > factor_)\n            expand();\n        int i = data % capacity_;\n        do {\n            if (table_[i].state_ != USING) {\n                table_[i].data_ = data;\n                table_[i].state_ = USING;\n                ++size_;\n                return true;\n            }\n            // 更新 i\n            i = (i + 1) % capacity_;\n        } while (i != data % capacity_);\n        return false;\n    }\n    // 删除元素\n    bool del(int data) {\n        int i = find(data);\n        if (i > 0) {\n            --size_;\n            table_[i].state_ = DELTE;\n            return true;\n        } else {\n            return false;\n         }\n    }\n    // 查找\n    int find(int data) {\n        int i = data % capacity_;\n        do {\n            if (table_[i].state_ == IDLE) {\n                cout << \"No data!\" << endl;\n                return -1;\n            } else if (table_[i].state_ == USING &&\n                       table_[i].data_ == data) {\n                return i;\n            } else {\n                i = (i + 1) % capacity_;\n                continue;\n            }\n        } while (i != data % capacity_);\n        cout << \"No data!\" << endl;\n        return -1;\n    }\n\nprivate:\n    void expand() {\n        if (prime_ == PRIMESIZE - 1) {\n            throw \"There is no space to expand!\";\n        }\n        ++prime_;\n        int oldCapacity = capacity_;\n        // 更新容量\n        capacity_ = primeNums_[prime_];\n        Bucket* p = new Bucket[capacity_];\n        for (int i = 0; i < oldCapacity; ++i) {\n            // 若该值有效\n            if (table_[i].state_ == USING) {\n                int j = table_[i].data_ % capacity_;\n                do {\n                    if (p[j].state_ != USING) {\n                        p[j].state_ = USING;\n                        p[j].data_ = table_[i].data_;\n                        break;\n                    }\n                    j = (j + 1) % capacity_;\n                } while (j != table_[i].data_ % capacity_);\n            }\n        }\n        delete [] table_;\n        table_ = p;\n        p = nullptr;\n    }\n\nprivate:\n    Bucket* table_;   // 表指针\n    int size_;        // 哈希表有效数据\n    int capacity_;    // 哈希表容量\n    double factor_;\n\n    static const int PRIMESIZE = 10;\n    static int primeNums_[PRIMESIZE];   // 素数表\n    int prime_;                         // 当前使用的素数下标\n};\n```\n\n### 线性探测哈希表的缺陷：\n- 发生哈希冲突时，靠近O(n)的时间复杂度。\n- 多线程的情况下，只能给全局的表用互斥锁保证哈希表的原子操作，来保证线程安全。\n\n但是！在线性探测哈希表可以使用**分段的锁**，既保证了线程安全，又有了一定的并发量，提高了效率。\n\n:::tip 分段锁（Segmented Lock）\n**分段锁**：\n- 将整个数据结构（如哈希表）划分为多个段（segment），每个段配备一个独立的锁（如 std::mutex）。\n- 每次操作（插入、查找、删除）时，只锁住对应段的锁，而不是整个表。\n- 不同线程只要操作的数据落在不同的段上，就可以并发执行，大大提升并发性能。\n:::\n\n### 链式哈希表\n\n1. 桶是以链表的形式来存储数据和数据状态。\n2. 用数组来存放每个桶，每个桶存放的是 **链表头节点**。\n3. 出现哈希冲突不需要线性探测法。\n4. 但是当桶的链表比较长时，链表搜索花费的时间就大，时间复杂度趋近于O(n)。\n\n如果是用向量 `vector` 和stl的 `list` 以及泛型算法 `::find`  来组合成链式哈希表就简单多了（笑）。\n\n```C++\n// 定义链表节点\nstruct Node {\n    Node(int data = 0) : next_(nullptr), data_(data) {}\n    Node* next_;\n    int data_;\n};\n\n// 定义哈希表功能函数\nclass HashTable {\npublic:\n    HashTable(int size = 3) : prime_(0), factor_(0.75), size_(0) {\n        for (; prime_ < 10; ++prime_) {\n            if (primeNums_[prime_] >= size)\n                break;\n        }\n        // 越界处理\n        if (prime_ == PRIMESIZE)\n            prime_--;\n        capacity_ = primeNums_[prime_];\n        table_ = new Node*[capacity_];\n        // 此时数组里还都是野指针，只给指针分配了空间，没有分配头节点\n        for (int i = 0; i < capacity_; ++i) {\n            table_[i] = new Node;\n        }\n    }\n    ~HashTable() {\n        for (int i = 0; i < capacity_; ++i) {\n            Node* p = table_[i];\n            while (p) {\n                Node* q = p;\n                p = p->next_;\n                delete q;\n            }\n        }\n        delete[] table_;\n        table_ = nullptr;\n    }\n\npublic:\n    // 插入元素，默认不重复\n    double insert(int data) {\n        // 判断是否需要扩展\n        double fac = size_ * 1.0 / capacity_;\n        if (fac > factor_)\n            expand();\n        int i = data % capacity_;\n        // 如果是空桶，则增加占用个数\n        if (!table_[i]->next_)\n            ++size_;\n        // 头插法\n        Node* p = new Node(data);\n        p->next_ = table_[i]->next_;\n        table_[i]->next_ = p;\n        return fac;\n    }\n    // 删除元素\n    bool del(int data) {\n        int i = data % capacity_;\n        Node* p = table_[i];\n        Node* q = p->next_;\n        while (q && q->data_ != data) {\n            p = q;\n            q = p->next_;\n        }\n        if (q) {\n            p->next_ = q->next_;\n            delete q;\n            // 如果刚才删的是最后一个节点，此时变为空桶，size-1\n            if (p == table_[i] && !p->next_)\n                --size_;\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // 查找，返回要删除节点的上一个节点\n    Node* find(int data) {\n        int i = data % capacity_;\n        Node* p = table_[i];\n        Node* q = p->next_;\n        while (q) {\n            if (q->data_ == data) {\n                return p;\n            }\n            p = p->next_;\n            q = p->next_;\n        }\n        return nullptr;\n    }\n\nprivate:\n    void expand() {\n        if (prime_ == PRIMESIZE - 1) {\n            throw \"There is no space to expand!\";\n        }\n        // 清空占用桶的数量\n        size_ = 0;\n        ++ prime_;\n        int oldCapacity = capacity_;\n        // 更新容量\n        capacity_ = primeNums_[prime_];\n        Node** p = new Node*[capacity_];\n        // p中还都是野指针\n        for (int i = 0; i < capacity_; ++i) {\n            p[i] = new Node;\n        }\n        for (int i = 0; i < oldCapacity; ++i) {\n            Node* q = table_[i]->next_;\n            // 此时如果是空桶那就占用个数+1\n            if (!q)\n                ++size_;\n            while (q) {\n                int j = q->data_ % capacity_;   // 新位置\n                Node* k = q;\n                q = q->next_;\n                // 头插更新\n                k->next_ = p[j]->next_;\n                p[j]->next_ = k;\n            }\n            delete table_[i];\n        }\n        delete[] table_;\n        table_ = p;\n        p = nullptr;\n    }\n\nprivate:\n    Node** table_;   // 表指针(表中存储的都是指针，因此是双指针)\n    int size_;       // 哈希表占用桶的个数\n    int capacity_;   // 哈希表容量\n    double factor_;\n\n    static const int PRIMESIZE = 10;\n    static int primeNums_[PRIMESIZE];   // 素数表\n    int prime_;                         // 当前使用的素数下标\n};\n\nint HashTable::primeNums_[PRIMESIZE] = {\n    3, 7, 23, 47, 97, 251, 443, 911, 1471, 42773};\n\n```\n\n#### 优化\n- 优化一：当链表长度大于8/10...，把桶里的链表转化成 **红黑树** （无论是什么操作都是O(logn)）\n- 优化二：为每个桶添加一个 **分段锁** ，来控制当前的桶的链表不能并发操作，但是不同桶的链表可以并发操作。\n\n## 查重应用\n\n使用stl自带的 `unordered_map` 来完成大数据查重。\n> 关于 [unordered_map](https://akorin.icu/posts/gccSimpleLearn#unordered_map)\n\n### 找出重复字符\n\n找出第一个重复或没有重复的字符或者数字，或者统计重复字符或数字的次数。\n\n找出第一个没有重复的字符实现思路：\n```C++\nstring src = \"agfcdfgdrg\";\nunordered_map<int,int> m;\nfor (auto c:src) {\n    m[c]++; //c是键，可以直接使用下标符[]来查找值。\n}\nfor (auto c:src) {\n    if (m[c] == 1) {\n        cout << \"第一个没有重复出现的字符是：\" << c << endl;\n        return;\n    }\n}\ncout << \"所有字符均重复。\" << endl;\n\n```\n\n### 找出重复ip地址\n\n两个文件a和b各自存放了一亿条ip地址或者邮箱地址，找出它们的重复地址并输出出来。限制内存使用100M。\n\n实现思路：\n1. 将a分成10个文件，每个文件有10M条数据，占用内存为：10M*4*2=80M。（地址域也有开销，估算时*2）\n2. 以此将小文件放入哈希表中。\n3. 遍历b的数据与每个小文件哈希表对比，直到找出重复。\n\n\n## 扩展-堆内存管理器\n\n在向量 `vector` 中使用 `swap` 交换两个成员变量时就涉及到堆内存管理器 `allocator`了。\n- 若两个向量是同一个内存管理器 `allocator` 分配的，则 `swap` 方法效率非常高，因为第二个向量的指针直接指向第一个向量开辟的堆内存。\n- 若两个向量的对内存管理器不同（一个是stl自带的，使用 `malloc` `free`管理内存，另一个也许是自行定制的）， **两个容器管理外部堆内存的方式不一样** ，则就不是直接交换成员变量了，而是低效率地遍历所有变量再交换。\n\n> 关于[堆内存管理器](https://akorin.icu/posts/gccSimpleLearn#%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%99%A8-allocator)\n","cover":"https://pic.akorin.icu/20250823154413875.webp","date":"2025-08-23 02:11:08"},{"title":"回溯算法","tags":["算法","二叉树","编程","C++"],"categories":[],"author":"akorin","excerpt":"\n# 回溯算法\n\n回溯算法（Backtracking）是一种通过试探并在失败时回退的搜索算法，常用于解决组合、排列、子集、图遍历、约束满足等问题。它的核心思想是：\n\n1. 选择：尝试某个候选解。\n2. 约束：判断当前选择是否满足条件。\n3. 回溯：若不满足条件，撤销选择（回退一步），继续尝试其他可能。\n\n可以理解为在一棵“状态树”上进行 深度优先搜索（DFS），遇到死胡同时就回到上一步继续探索。\n\n有两种解空间：\n- 子集树\n- 排列数\n\n","link":"/posts/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95","content":"\n# 回溯算法\n\n回溯算法（Backtracking）是一种通过试探并在失败时回退的搜索算法，常用于解决组合、排列、子集、图遍历、约束满足等问题。它的核心思想是：\n\n1. 选择：尝试某个候选解。\n2. 约束：判断当前选择是否满足条件。\n3. 回溯：若不满足条件，撤销选择（回退一步），继续尝试其他可能。\n\n可以理解为在一棵“状态树”上进行 深度优先搜索（DFS），遇到死胡同时就回到上一步继续探索。\n\n有两种解空间：\n- 子集树\n- 排列数\n\n<!-- more -->\n\n## 子集树\n\n在递归过程中，记录每一层的选择，从而记录递归时的路径。\n\n当遍历所有的节点后（包括非叶子节点），时间复杂度应为 $2^n$ ，其中 n 为数组元素的个数。\n\n**可以看作成一个二叉树，往左是选择，往右是不选择**\n\n![图源https://algo.itcharge.cn/07_algorithm/07_04_backtracking_algorithm/#_5-1-%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98-%E5%AD%90%E9%9B%86](https://pic.akorin.icu/20250911200714940.webp)\n\n:::code-group\n```C++ [子集树模板]\nint length = sizeof(arr) / sizeof(arr[0]);\nvoid fun(int arr[], int x[] ,int i) {\n    if (i == length) {\n        // 到达底层\n        \n        // 打印子集树\n          for (int j = 0; j < length; ++k) {\n              if (x[j] == 1) {\n                  cout << arr[j];\n              }\n          }\n        // 也可以直接指定某个子集来完成逻辑\n\n    } else {\n        // 向左\n        x[i] = 1;\n        fun(arr, x, i + 1);\n\n        // 向右\n        x[i] = 0;\n        fun(arr, x, i + 1);\n    }\n}\n```\n```C++ [eg.整数选择问题]\n// 给定一组整数，从里面挑选出一组整数，让选择的整数的和，和剩下的整数的和的差最小\nint arr[10] = {...};\nint length = sizeof(arr) / sizeof(arr[0]);\nint sum = 0;  // 选择的数之和\n// 把所有的数加起来，去掉选择的数后，剩下来的数就是未选择的数之和\nint rsum = std::accumulate(arr, std::end(arr), 0); // 未选择的数之和\nunsigned int min = 0xffffffff; // 最小的差\nint best[length] = {0}; // 记录最佳的序列满足题意\nint x[length] = {0}; // 记录递归遍历过程中，选择的方向。\nvoid fun(int arr[], int i) {\n    if (i == length) {\n        // 遍历完某个路径，尝试更新最小的差值\n        int res = abs(sum - rsum);\n        if (res < min) {\n            min = res;\n        }\n        for (int j = 0; j < length; ++j) {\n            best[j] = x[j]; // 记录当前最佳选择的数\n        }\n    } else {\n        // 向左\n        x[i] = 1;\n        sum += arr[i];\n        rsum -= arr[i];\n        fun(arr, i + 1); // 选择i节点\n\n        // 向右\n        x[i] = 0;\n        sum -=  arr[i];\n        rsum += arr[i];\n        fun(arr, i + 1); // 不选择i节点\n    }\n}\n\nint main() {\n    ... \n    fun(arr, 0);\n    for (int i = 0; i < length; ++i) {\n        if (best[i] == 1) {\n            // 打印最佳选择的数\n            cout << arr[i];\n        }\n    }\n    return 0;\n}\n```\n:::\n\n### 子集树剪枝操作\n\n子集树遍历过程中，遍历每一个叶子节点会导致效率不高，因此在遍历过程中可以判定是否需要继续深度遍历。\n\n#### 2N整数选择问题\n\n2N整数选择问题：给定2n个整数，从中挑选n个整数，让选择的整数和与剩下的整数和之差最小\n\n:::code-group\n```C++ [2N整数选择问题]\n// 2N整数选择问题：给定2n个整数，从中挑选n个整数，让选择的整数和与剩下的整数和之差最小\n\n// 用向量存取临时数据要方便一点，就不用x[i]来判定是往左还是往右了\nstd::vector<int> arr[10] = {...};\nstd::vector<int> x[10] = {0};\nstd::vector<int> best[10] = {0};\nint length = arr.size();\n\nint leftcnt = length; // 记录未处理数字的个数\n\nint sum = 0;\nint rsum = std::accumulate(arr.begin(), arr.end(), 0);\n\nvoid fun(int i) {\n\n    if (i == length) {\n        // 剪枝：到达叶子节点时选择的数还没到一半就继续遍历\n        if (x.size() != length / 2) {   // [!code ++]\n            return; // [!code ++]\n        }   // [!code ++]\n\n        int res = abs(sum - rsum);\n        if (res < min) {\n            min = res;\n            best = x;\n        }\n    } else {\n        leftcnt--; // [!code ++]\n        // 剪枝：只有选择的个数小于一半时才去选择，多选择的就没必要再遍历了\n        if (x.size() < length / 2) {     // [!code ++]\n            x.push_back(arr[i]);\n            sum += arr[i];\n            rsum -= arr[i];\n            fun(i + 1); // 遍历左孩子，记录当前的值表示选择\n\n            x.pop_back();\n            sum -= arr[i];\n            rsum += arr[i];\n        }    // [!code ++]\n        // 右树枝也可以剪枝：已选择的数字个数+未来能选择的所有数字个数(i+1,i+2...n)>=n个元素\n        if (x.size() + leftcnt >= length / 2) {\n            fun(i + 1); // 遍历右孩子，不要当前的数\n        }\n        // 当前i节点处理完成，回溯到父节点\n        leftcnt++; // [!code ++]\n    }\n}\n\n```\n:::\n\n#### 挑选数字问题\n\n在数组中挑选一系列的数字，使它们的和等于指定的数。\n\n:::code-group\n```C++ [选数字问题]\n// 在数组中挑选一系列的数字，使它们的和等于指定的数\n\nstd::vector<int> arr[10] = {...};\nstd::vector<int> x[10] = {0};\nstd::vector<int> best[10] = {0};\nint length = arr.size();\n\nint leftcnt = length; // 记录未处理数字的个数\n\nint sum = 0;\nint rsum = std::accumulate(arr.begin(), arr.end(), 0); // 未处理的数之和\nint num = ...;\n\nvoid func(int i) {\n    if (i == length) {\n        if (sum == num) {\n            best = x;\n            for (auto it : best) {\n                std::cout << it << \" \";\n            }\n            std::cout << std::endl;\n        }\n    } else {\n        rsum -= arr[i];  // [!code ++] 未处理的数之和\n        if (sum + arr[i] <= num) {\n            sum += arr[i];\n            x.push_back(arr[i]);\n            func(i + 1);\n            // 不选择当前的数\n            sum -= arr[i];\n            x.pop_back();\n        }\n        // 剪右树枝\n        if (sum + rsum >= num) { // [!code ++] \n            func(i + 1);\n        } // [!code ++] \n        // 此时回溯到父节点，处理的数加回去变未处理\n        rsum += arr[i]; // [!code ++] \n    }\n}\n```\n```C++ [更高效的算法]\nvoid func(int i, int num) {\n    if (num == 0) {   // [!code ++]\n        std::cout << \"找到可凑出的数\" << std::endl;\n        for (auto v : best) {\n            std::cout << v << \" \";\n        }\n        std::cout << std::endl;\n    } else {\n        // 从当前节点开始，把剩余元素的孩子节点生成\n        // 不用再重复的遍历前面已遍历过的元素\n        for (int j = i; j < length; ++j) {  // [!code ++] \n            if (arr[j] <= num) {  // [!code ++]  当前要存的数小于要接近的数才行\n                best.push_back(arr[j]);  // [!code ++] \n                func(j + 1, num - arr[j]);   // [!code ++] \n                // 下面这个是可以重复选择同样的数，如：4 4 4 3， 4 4 1 2， 4 4 4 4\n                // func(j, num - arr[j]);   // [!code ++] \n                 // [!code ++]  包含当前元素的所有可能遍历结束\n                best.pop_back();  // [!code ++] \n            }  // [!code ++] \n        }  // [!code ++] \n    }\n}\n```\n:::\n\n其中更高效的算法中，巧妙地避免了前面已经处理过的数。包含了前面的数处理过了，后面就没必要再重新处理了，可以节省很多时间。\n\n![](https://pic.akorin.icu/20250911200746555.webp)\n\n![](https://pic.akorin.icu/20250911201313799.webp)\n\n#### 背包问题\n\n背包问题，有n个物品，不同物品不同重量且不同价值，指定某个容量下的最大价值配比。\n\n```C++ \nint w[] = {12, 3, 8, 9, 6};   // 物品重量\nint v[] = {9, 11, 4, 7, 8};   // 物品价值\nconst int len = sizeof(w) / sizeof(w[0]);\nstd::vector<int> sel;                         // 选择的物品\nint c = 20;                                   // 背包容量\nint r = std::accumulate(v, std::end(v), 0);   // 剩余总价值\nint cw = 0;                                   // 已选择物品的重量\nint cv = 0;                                   // 已选择物品的价值\n\nunsigned int bestv = 0;\n\nvoid func(int i) {\n    // 背包问题，有n个物品，不同物品不同重量且不同价值，指定某个容量下的最大价值配比。\n    if (i == len) {\n        // 到达叶子节点\n        if (cv > bestv) {\n            bestv = cv;\n            std::cout << \"此时的价值为： \" << bestv << std::endl;\n            for (auto v : sel) {\n                std::cout << v << \" \";\n            }\n            std::cout << std::endl;\n        }\n    } else {\n        // 左剪枝\n        if (cw + w[i] <= c) {\n            // 选择物品的重量加上即将处理的物品的重量小于背包容量才能选择\n            cw += w[i];\n            cv += v[i];\n            sel.push_back(w[i]);\n            func(i + 1);\n\n            sel.pop_back();\n            // 没有选择该物品\n            cw -= w[i];\n            cv -= v[i];\n        }\n        // 右剪枝\n        if (cv + r > bestv) {\n            // 只有剩余价值加上当前积累价值大于最大价值才值得继续遍历\n            func(i + 1);\n        }\n    }\n}\n```\n\n## 排列树\n\n**从 n 个不同元素中，取出所有元素，按照顺序排列** 的一种树形表示方法。\n\n每一条从 **根节点到叶子节点的路径**，对应一个排列。  \n\n换句话说，排列树就是把所有 **全排列** 的生成过程，形象化为一棵树。\n\n```\n               (root)\n           /     |     \\\n         1       2      3\n       /  \\     / \\    /  \\\n      2    3   1  3   1   2\n     /    /   /  /   /   /\n    3    2  3   2   2   1\n\n```\n\n:::code-group\n```C++ [排列树模板]\nint vec[5] = {1 ,2 ,3 ,4 ,5};\nint len = sizeof(vec) / sizeof(vec[0]);\n\nvoid swap(int arr[], int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\nvoid func(int arr[], int i) {\n    if (i == len) {\n        // 到达叶子节点\n        for (auto v : vec) {\n            std::cout << v << \" \";\n        }\n        std::cout << std::endl;\n    } else {\n        for (int j = i; j < len; ++j) {\n            swap(arr, i, j);\n            func(arr, i + 1);\n            swap(arr, i ,j);\n        }\n    }\n}\n```\n:::\n\n在代码中主要通过两个元素的交换，来实现不同的排列。\n\n### N皇后问题\n\n比较经典的就是8皇后问题：皇后会吃点她直线或斜线上的敌人。\n\n现在棋盘上有8个皇后，要怎么摆才不能让互相她们吃掉。\n\n:::code-group\n```C++ [交换法排列树]\n// 把ar数组的下标当作行，下标对应的元素的值当作列\nint ar[] = {1, 2, 3, 4, 5, 6, 7, 8};\nint len = sizeof(ar) / sizeof(ar[0]);\nint n = 8;\nvoid swap(int i, int j) {\n    int temp = ar[i];\n    ar[i] = ar[j];\n    ar[j] = temp;\n}\n\nbool judge(int i) {\n    // 当前的皇后和前面的皇后进行比较\n    for (int j = 0; j < i; ++j) {\n        // i == j：同行\n        // ar[i] == ar[j]：同列\n        // i - j == ar[i] - ar[j]：同斜线\n        if (i == j || ar[i] == ar[j] ||\n            std::abs(i - j) == std::abs(ar[i] - ar[j])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid func(int i) {\n    // 8皇后\n    if (i == len) {\n        // 叶子节点\n        for (auto v : ar) {\n            std::cout << v << \" \";\n        }\n        std::cout << std::endl;\n    } else {\n        for (int j = i; j < len; ++j) {\n            swap(i, j);\n            if (judge(i)) {\n                func(i + 1);\n            }\n            swap(i, j);\n        }\n    }\n}\n```\n```C++ [穷举法排列树]\nstd::vector<bool> state(len, false);\nstd::vector<int> vec;\nbool judge(int i) {\n    // 当前的皇后和前面的皇后进行比较\n    for (int j = 0; j < i; ++j) {\n        // i == j：同行\n        // vec[i] == vec[j]：同列\n        // i - j == vec[i] - vec[j]：同斜线\n        if (i == j || vec[i] == vec[j] ||\n            std::abs(i - j) == std::abs(vec[i] - vec[j])) {\n            return false;\n        }\n    }\n    return true;\n}\nvoid func(int i) {\n    // 8皇后\n    if (i == len) {\n        // 叶子节点\n        for (auto v : vec) {\n            std::cout << v << \" \";\n        }\n        std::cout << std::endl;\n\n    } else {\n        for (int j = 0; j < len; ++j) {\n            if (!state[j]) {\n                state[j] = true;\n                vec.push_back(ar[j]);\n                if (judge(i)) {\n                    func(i + 1);\n                }\n                vec.pop_back();\n                state[j] = false;\n            }\n        }\n    }\n}\n```\n:::\n\n穷举法获取排列树时，需要记录状态，看是否已经走过。`state[j]` 表示某个候选元素 `ar[j]` 是否已经被使用过（避免重复选择）。\n","cover":"https://pic.akorin.icu/20250911101441807.webp","date":"2025-09-11 10:10:39"},{"title":"基础排序","tags":["笔记","编程","C++"],"categories":["笔记"],"author":"akorin","excerpt":"\n一大堆排序，简要记录中心思想。\n\n","link":"/posts/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F","content":"\n一大堆排序，简要记录中心思想。\n\n<!-- more -->\n\n## 冒泡排序\n\n两个指针一前一后进行比较，前者数较大就两者交换（顺序），每次移动都是两个指针一起移动，这样每一趟都会把当前的较大数移动到后面，移动完毕后再从头开始比较，但是不用管已经排好的数。\n\n![](https://pic.akorin.icu/20250818111128548.webp)\n\n- 平均复杂度O(n^2)，最好情况O(n)\n- 空间复杂度O(1)\n- 稳定算法\n\n```C++\n// O(n) ~ O(n^2)    平均O(n^2)\nvoid BubbleSort(int arr[], int size) {\n    // 最后一趟就一个数不用再处理了\n    for (auto i = 0; i < size - 1; ++i) {\n        // 如果一次交换都没有则该数列已排好不用再操作\n        bool flag = false;\n        // 每一趟都不用再处理排序好的数\n        for (auto j = 0; j < size - 1 - i; ++j) {\n            if (arr[j] > arr[j + 1]) {\n                flag = true;\n                arr[j] += arr[j + 1];\n                arr[j + 1] = arr[j] - arr[j + 1];\n                arr[j] -= arr[j + 1];\n            }\n        }\n        if (!flag) {\n            return;\n        }\n    }\n}\n```\n\n:::info 稳定性\n 稳定性：在原始的数据序列中，**相同元素** 经过排序后，它们的前后顺序并没有改变，就叫做稳定的，否则就是不稳定排序\n:::\n\n## 选择排序\n\n也是双指针，第二个指针与第一个指针的数进行比较，较小的数放前面。与冒泡排序对比，**交换次数少很多**，效率稍微高一点。\n\n选择排序是找到最小的数再交换位置，而不是后者比前者小就交换。如果是后者比前者小就交换，那样交换次数就会很大，最后消耗的时间甚至比冒泡还要长。\n\n\n- 复杂度O(n^2)\n- 空间复杂度O(1)\n- 不稳定算法\n\n```C++\nvoid ChoiceSort(int arr[], int size) {\n    for (auto i = 0; i < size - 1; ++i) {\n        int min = arr[i];\n        int k = i;\n        for (auto j = i + 1; j < size; ++j) {\n            if (min > arr[j]) {\n                min = arr[j];\n                k = j;\n            }\n        }\n        // 避免无用的交换\n        if (k != i) {\n            int temp = arr[k];\n            arr[k] = arr[i];\n            arr[i] = temp;\n        }\n    }\n}\n```\n\n## 插入排序\n\n插入排序认为前面一段序列是有序的，将当前的数插入到前面的有序数列中。\n\n**如果数据趋于有序，那么插入排序是所有排序算法中，效率最高的算法。** 在基础排序算法的效率中， 插入排序 > 冒泡排序&选择排序。\n\n插入排序不仅仅 **没有交换**， 比较次数也少。\n\n- 平均复杂度O(n^1.3)，O(n)~O(n^2)\n- 空间复杂度O(1)\n- 稳定算法\n\n```C++\nvoid InsertSort(int arr[], int size) {\n    for (auto i = 1; i < size; ++i) {\n        int val = arr[i];\n        auto j = i - 1;\n        for (; j >= 0; --j) {\n            if (val >= arr[j])\n                break;\n            arr[j + 1] = arr[j];\n        }\n        arr[j + 1] = val;\n    }\n}\n```\n\n实际上这就是 **数组** 这类有序数据结构的插入算法，对比链表这种数据结构，其插入的效率较低。\n\n## 希尔排序\n\n希尔排序就是对插入排序的优化。希尔排序对数组进行分组插入排序，部分组有序后再分组插入排序，直到间隔为0。希尔排序先全局对数据进行趋于有序的优化。\n\n- 复杂度O(n)~O(n^2)\n- 空间复杂度O(1)\n- 稳定算法\n\n```C++\n// 希尔排序 - 只需要记住插入排序就行了\nvoid ShellSort(int arr[], int size) {\n    for (int gap = size / 2; gap > 0; gap /= 2) {\n        // 这里++i不是i+=gap是为了遍历分了之后的所有组\n        for (auto i = gap; i < size; ++i) {\n            int val = arr[i];\n            auto j = i - gap;\n            for (; j >= 0; j -= gap) {\n                if (val >= arr[j])\n                    break;\n                arr[j + gap] = arr[j];\n            }\n            arr[j + gap] = val;\n        }\n    }\n    \n}\n```\n\n写希尔排序之前，先写好插入排序，再在这外层套一个间隔，内部排序改成对应间隔，不用死记硬背希尔排序。\n\n## 四种基础排序性能对比：\n使用十万个数据的数组，分别使用冒泡排序、选择排序、插入排序和希尔排序，并计算所用时间。\n| 算法类型 | 时间 |\n| -------- | ---- |\n| 冒泡排序 |21.0031s|\n| 选择排序 |2.71733s|\n| 插入排序 |2.33287s|\n| 希尔排序 |0.016249s|\n","cover":"https://pic.akorin.icu/20250818110658665.webp","date":"2025-08-18 00:00:00"},{"title":"大数据topk问题","tags":["算法","大数据","编程","C++"],"categories":["算法"],"author":"akorin","excerpt":"\n# 大数据topk\n\n大数据topk问题就是 **求大量数据的前k个最大/最小的数据**。\n\n有两种方法解决：\n- 大小根堆\n- 快排分割\n\n","link":"/posts/%E5%A4%A7%E6%95%B0%E6%8D%AEtopk%E9%97%AE%E9%A2%98","content":"\n# 大数据topk\n\n大数据topk问题就是 **求大量数据的前k个最大/最小的数据**。\n\n有两种方法解决：\n- 大小根堆\n- 快排分割\n\n<!-- more -->\n\n## 大小根堆求解\n\n1. 前k个最大数：利用 **大根堆**，不断 **淘汰堆顶元素** ，放入小值。\n2. 前k个最小数：利用 **小根堆** ，不断 **淘汰堆顶元素** ，放入大值。\n\n这种淘汰堆顶元素的算法，其时间复杂度仅为 **O(n)** ，如果是直接构建小根堆、大根堆取前k个元素，那样消耗的复杂度就是 **O(nlogn)** 了。\n\n大小根堆可以直接使用stl的 `priority_queue` 优先级队列来构建。\n- 利用优先级队列，先把前k个元素构建成一个大根堆/小根堆。\n- 遍历后面的数据与堆顶元素比较。\n\n:::code-group topk问题\n```C++ [大根堆求前k个最小值]\nvector<int> vec;\n// 生成1000个10000以内的随机数\nsrand(time(NULL));\nfor (int i = 0; i < 1000; ++i) {\n    vec.push_back(rand % 10000);\n}\n\n// 也可以直接写成 priority_queue<int> maxheap;\n// 使用的容器默认是 vector，比较函数默认是 less\npriority_queue<int, vector<int>, less<int>> maxheap;\n\n// 求前5个最小数\nint k = 5;\n\n// 前k个元素构建一个大根堆\nfor (int i = 0; i < k; ++i) {\n    maxheap.push(vec[i]);\n}\n\n// 遍历剩余元素，若堆顶大于当前数据就先出堆顶，再放进来\nfor (int i = k; i < vec.size(); ++i) {\n    if (maxheap.top() > vec[i]) {\n        maxheap.pop();\n        maxheap.push(vec[i]);\n    }\n}\n\n// 打印剩余元素\nwhile(!maxheap.empty()) {\n    cout << maxheap.top() << \" \";\n    maxheap.pop();\n}\ncout << endl;\n```\n\n```C++ [小根堆求前k个最大值]\nvector<int> vec;\n// 生成1000个10000以内的随机数\nsrand(time(NULL));\nfor (int i = 0; i < 1000; ++i) {\n    vec.push_back(rand % 10000);\n}\n\npriority_queue<int, vector<int>, greater<int>> maxheap;\n\n// 求前5个最大数\nint k = 5;\n\n// 前k个元素构建一个小根堆\nfor (int i = 0; i < k; ++i) {\n    maxheap.push(vec[i]);\n}\n\n// 遍历剩余元素，若堆顶小于当前数据就先出堆顶，再放进来\nfor (int i = k; i < vec.size(); ++i) {\n    if (maxheap.top() < vec[i]) {\n        maxheap.pop();\n        maxheap.push(vec[i]);\n    }\n}\n\n// 打印剩余元素\nwhile(!maxheap.empty()) {\n    cout << maxheap.top() << \" \";\n    maxheap.pop();\n}\ncout << endl;\n```\n:::\n\n还有一种问题是 **topk问题** 和 **查重** 结合起来，**查找重复次数前k个的数** 。既然有查重，就不可避免使用哈希表 `unordered_map`\n\n```C++\nvector<int> vec;\n// 生成1000个10000以内的随机数\nsrand(time(NULL));\nfor (int i = 0; i < 1000; ++i) {\n    vec.push_back(rand % 10000);\n}\n\n// 键值都是 int 类型\nunordered_map<int, int> map;\n\n// 对应元素的值加1\nfor (key : vec) {\n    ++map[vec[key]];\n}\n\n// 前k个重复次数最小的数，构建小根堆\n// 构建大根堆/小根堆时，要比较哈希表的值，\n// 但是要放入的是哈希表的键\n// 因此要同时放入 键-值 对\n// 因此使用 pair\n// 使用 pair 类型就要定制 priority_queue\npriority_queue<\n    pair<int,int>,\n    vector<pair<int,int>>,\n    function<bool(pair<int,int>&, pair<int, int>&)>\n> minheap([](pair<int,int>& a, pair<int,int>& b) -> bool {\n    return a.second > b.second;\n});\nint k = 5;\nauto it = map.begin();  // map迭代器返回的是 pair 类型\nfor (int i = 0; i < k; ++i, ++it) {\n    minheap.push(*it);\n}\nfor (; it != map.end(); ++it) {\n    if (minheap.top().second() < it->second) {\n        minheap.pop();\n        minheap.push(*it);\n    }\n}\nwhile (!minheap.empty()){\n    cout << minheap.top().first() << \" \";\n    minheap.pop();\n}\ncout << endl;\n```\n\n:::info lambda表达式\n`[capture list] (parameter list) -> return type { function body }`\n:::\n\n## 快排分割求解\n\n分割到前 `k` 个数组取出来即可：因为 **基准数前面的数都小于它，基准数后面的数都大于它。** 因此找出前 `k` 个最大/最小数，就只需要找到位置是 `k-1` 的基准数的位置（基准数也是前 `k` 个数），并返回前 `k` 个数的子数组。\n\n操作的平均时间复杂度也是O(n)。\n- 获取分割后的位置 `pos` ，与 `k-1` 进行比较。\n- 若 `pos` > `k-1` ，说明在左边数列中找。\n- 若 `pos` < `k-1` ，说明在右边数列中找。\n\n```C++\n// 分割一次\nint Partation(int arr[], int begin, int end) {\n    int val = arr[begin];\n    int left = begin;\n    int right = end;\n    while (left < right) {\n        // while中要判断左右指针的位置，防止右指针越过左指针\n        // 使得右边数组越多val位置遍历到左边数组去了\n        while (left < right && arr[right]> val) {\n            --right;\n        }\n        if (left < right) {\n            arr[left] = arr[right];\n            ++left;\n        } else {\n            break;\n        }\n        while (left < right && arr[left] < val) {\n            ++left;\n        }\n        if (left < right) {\n            arr[right] = arr[left];\n            --right;\n        } else {\n            break;\n        }\n    }\n    arr[left] = val;\n    return left;\n}\n\nvoid SelectTopk(int arr[], int begin, int end, int k) {\n\n    int pos = Partation(arr, begin, end);\n    if (pos == k - 1) {\n        return;\n    } else if (pos > k - 1)\n        SelectTopk(arr, begin, pos - 1, k);\n    else\n        SelectTopk(arr, pos + 1, end, k);\n}\n```\n\n要注意快排分割中左右指针循环条件，**不要让左右指针越界** 。\n","cover":"https://pic.akorin.icu/20250826110602265.webp","date":"2025-08-26 11:02:37"},{"title":"大数据查重","tags":["算法","大数据","编程","C++"],"categories":["算法"],"author":"akorin","excerpt":"# 大数据查重\n\n这里的大数据不是java那种大数据分析，而是数据量很庞大的数据。\n\n这种大数据查重有几种算法：\n- 哈希表查重\n- 位图算法\n- 布隆过滤器\n\n类似问题有：一亿个数据，哪些元素重复了，谁是第一个重复的，谁是第一个不重复的……且内存限制100M。\n","link":"/posts/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9F%A5%E9%87%8D","content":"# 大数据查重\n\n这里的大数据不是java那种大数据分析，而是数据量很庞大的数据。\n\n这种大数据查重有几种算法：\n- 哈希表查重\n- 位图算法\n- 布隆过滤器\n\n类似问题有：一亿个数据，哪些元素重复了，谁是第一个重复的，谁是第一个不重复的……且内存限制100M。\n<!-- more -->\n\n## 哈希表查重\n<!--@include: ./哈希表.md{364,395}-->\n\n## 位图算法(bitmap)\n\n每一位对应每条数据。如15对应 **1**000 0000 0000 0000的1。因为是二进制，**它的空间占用率很低**。\n\n对于一亿个int类型元素（100M个数据），则占用 100000000/32 * 4 = **12.5M的内存**。\n\n1. 需要知道元素序列的最大值，根据最大值定义bitmap位图数组。\n2. 直到了最大值max，则通过 `/` 计算位图数组大小。定义位图数组：\n    ```C++\n    char bitmap[max / 8 + 1];\n    ```\n    其中 `8` 为数据类型为 `char` 型**占用的比特数**。若数据类型是 `int` 型，则需要改成 `32`。\n3. 若要查找的某个数为 `n`，通过 `/` 计算数据在第几个比特，通过 `%` 计算数据在对应比特的位置。\n    ```C++\n    int index = n / 8;\n    int offset = n % 8;\n    ```\n4. 读取该位为 `0` ，说明数据未出现过，若为 `1` ，说明数据出现过。\n    ```C++\n    bool b = bitmap[index] & (1 << offset); // 获取对应位的值\n    ```\n\n找出所有重复数据：\n```C++\nvector<int> vec{7,18,12,6,256,1,5};\nint max = vec[0];\nfor(auto i:vec) {\n    if(i > max)\n        max = i;\n}\n// 初始化数组全为0\nint *bitmap = new int[max / 32 + 1]();\n// 智能指针管理内存，就不用自己释放了\nunique_ptr<int> ptr(bitmap);\n// 找第一个重复的数字\nfor (auto key:vec) {\n    int index = key / 32;\n    int offset = key % 32;\n    if (!bitmap[index] & (1 << offset)) {\n        // 第一次遇到这个数\n        bitmap[index] |= (1 << offset);\n    } else {\n        // 遇到重复的了，打印出来\n        cout << \"重复数据：\" << i << endl;\n    }\n}\n```\n\n还可以改成查找 **第一个不重复** 的数据，那么：\n1. 记录数组所有数据。\n2. 用 **两个bit** 来记录每个数的状态，可以用01表示记录一次，11表示记录了多次。\n\n### 缺陷\n\n当有数组：`[1,3,1000000000]` ，这样的话就会使得这个 `bitmap` 占用 `1000000000/32 * 4 = 125MB`的空间。\n\n而此时用哈希表，只占用 `3 * 4 * 2 = 24B` 的空间。\n\n位图算法比较好的应用场景是 **最大值** 和数组的大小差不多大。\n\n:::info\n- `int` 最大有20亿\n- `unsigned int` 最大有40亿\n:::\n\n## 布隆过滤器(Bloom Filter)\n\n布隆过滤器是一个高级的位图算法，相当于**哈希表+位图**，也就是**二进制版本的哈希表** ，效率高而且占用也低，但是又与哈希表有很大不同，**布隆过滤器要计算多个哈希** 。\n\n### 使用场景\n\n- 提示过滤一些非法的网站、或者钓鱼网站。\n\n- redis缓存中的应用，把热点数据放入redis中。\n\n\n### 布隆过滤器注意事项\n\n经过 **k个哈希函数计算** ，得到bitmap位数组里面的一组位的序号。\n- **增加元素**： 把得到的 **所有序号对应位置置为1** 。\n- **搜索一个元素**： 查看对应位是否为1，若为1则返回true，否则返回false。\n- **不支持删除！** ，若删除后且寻找下一个数发生“冲突”时，就不能正确检索到下一个正确的位。\n- 布隆过滤器可能会 **共用一些位** ，即与其它数经过k个哈希函数算下来的位相同了。\n- 若布隆过滤器查询一个key经过k个哈希函数处理后，对应的位都是1， **不能说明这个位存在！** 因此布隆过滤器可能会产生 **误判！**\n- 若博隆过滤器查询一个key经过k个哈希函数处理后，得到对应的位为0，那么这个数 **一定不在** 。\n- 综上，如果布隆过滤器太小，误判率就会很高。\n\n### 布隆过滤器算法思想\n\n1. 将元素计算经过k个哈希函数并取模，得到一系列的位数。\n2. 将这些位在对应的布隆bit位上置为1。\n3. 查找时只有对应的所有位都为1才算做找到。\n4. 由于经过布隆过滤器计算发现不存在，那么只要计算出来的哈希值在布隆过滤器中没有，那么该数就一定不存在！\n5. 记录和查询的时间复杂度均为 O(1)\n\n::: code-group\n```C++ [布隆过滤器代码实现]\nclass BloomFilter {\npublic:\n    // 取个素数\n    BloomFilter(int size = 1471) : bitSize_(size) {\n        // int 是32位\n        bitMap_.resize(bitSize_ / 32 + 1);\n    }\n\npublic:\n    // 添加函数\n    void setBit(const char* str) {\n        // 先计算哈希函数的值\n        int idx1 = hash1(str) % bitSize_;\n        int idx2 = hash2(str) % bitSize_;\n        int idx3 = hash3(str) % bitSize_;\n\n        // 把相应的idx1 idx2 idx3对应的位全部置1\n\n        int index = idx1 / 32;\n        int offset = idx1 % 32;\n        bitMap_[index] |= (1 << offset);\n        index = idx2 / 32;\n        offset = idx2 % 32;\n        bitMap_[index] |= (1 << offset);\n        index = idx3 / 32;\n        offset = idx3 % 32;\n        bitMap_[index] |= (1 << offset);\n    }\n\n    bool getBit(const char* str) {\n        // 先计算哈希函数的值\n        int idx1 = hash1(str) % bitSize_;\n        int idx2 = hash2(str) % bitSize_;\n        int idx3 = hash3(str) % bitSize_;\n\n        int index = idx1 / 32;\n        int offset = idx1 % 32;\n        if (!(bitMap_[index] & (1 << offset))) {\n            return false;\n        }\n        index = idx2 / 32;\n        offset = idx2 % 32;\n        if (!(bitMap_[index] & (1 << offset))) {\n            return false;\n        }\n        index = idx3 / 32;\n        offset = idx3 % 32;\n        if (!(bitMap_[index] & (1 << offset))) {\n            return false;\n        }\n\n        // 只有三个位置都是1才能确定存在\n        return true;\n    }\nprivate:\n    int bitSize_;\n    vector<int> bitMap_;\n};\n\n// 黑名单\nclass BlackList {\npublic:\n    BlackList(){}\n    void add(string url) {\n        blockList_.setBit(url.c_str());\n    }\n    bool query(string url) {\n        return blockList_.getBit(url.c_str());\n    }\n\nprivate:\n    BloomFilter blockList_;\n};\n```\n```C++ [使用的哈希函数]\n// 哈希函数1：使用 std::hash\ninline size_t hash1(const std::string& key) {\n    return std::hash<std::string>{}(key);\n}\n\n// 哈希函数2：DJB哈希\ninline size_t hash2(const std::string& key) {\n    size_t hash = 5381;\n    for (char c : key) {\n        hash = ((hash << 5) + hash) + c;   // hash * 33 + c\n    }\n    return hash;\n}\n\n// 哈希函数3：SDBM哈希\ninline size_t hash3(const std::string& key) {\n    size_t hash = 0;\n    for (char c : key) {\n        hash = c + (hash << 6) + (hash << 16) - hash;\n    }\n    return hash;\n}\n\n// 哈希函数4：BKDR哈希\ninline size_t hash4(const std::string& key) {\n    size_t seed = 131;   // 31, 131, 1313, 13131, 131313, etc.\n    size_t hash = 0;\n    for (char c : key) {\n        hash = hash * seed + c;\n    }\n    return hash;\n}\n\n// 哈希函数5：AP哈希\ninline size_t hash5(const std::string& key) {\n    size_t hash = 0;\n    for (size_t i = 0; i < key.size(); ++i) {\n        if (i % 2 == 0) {\n            hash ^= ((hash << 7) ^ key[i] ^ (hash >> 3));\n        } else {\n            hash ^= (~((hash << 11) ^ key[i] ^ (hash >> 5)));\n        }\n    }\n    return hash;\n}\n```\n:::\n\n## 扩展\n\n### 误判率公式\n布隆过滤器的误判率公式为：\n$$\nP = \\left(1 - e^{-\\frac{kn}{m}}\\right)^k\n$$\n其中：\n- $P$：误判率\n- $k$：哈希函数的数量\n- $n$：要存储的元素数量\n- $m$：位数组的长度\n\n### 布隆过滤器的大小\n为了在给定的误判率下确定布隆过滤器的大小（位数组长度 $m$），公式为：\n$$\nm = -\\frac{n \\cdot \\ln P}{(\\ln 2)^2}\n$$\n其中：\n- $P$ 是目标误判率（例如 $P = 0.01$ 表示 1% 的误判率）。\n- $n$ 是要存储的元素数量。\n\n### 哈希函数的最佳数量\n最佳的哈希函数数量 $k$ 可以通过以下公式计算：\n$$\nk = \\frac{m}{n} \\cdot \\ln 2\n$$\n其中：\n- $m$ 是位数组的长度。\n- $n$ 是要存储的元素数量。\n\n### 示例\n假设：\n- 要存储的元素数量 $n = 1,000,000$。\n- 目标误判率 $P = 0.01$（1%）。\n\n#### 计算位数组的长度：\n$$\nm = -\\frac{1,000,000 \\cdot \\ln 0.01}{(\\ln 2)^2} \\approx 9,585,058 \\text{ 位}\n$$\n即需要约 $9.6 \\, \\text{MB}$ 的位数组。\n\n#### 计算最佳哈希函数数量：\n$$\nk = \\frac{m}{n} \\cdot \\ln 2 \\approx 6.64\n$$\n即需要 $6$ 到 $7$ 个哈希函数。\n","cover":"https://pic.akorin.icu/20250825163634255.webp","date":"2025-08-25 14:50:54"},{"title":"数字信号处理简记","tags":["笔记","数字信号处理","速通","matlab"],"categories":["笔记"],"author":"akorin","excerpt":"\n主要记录数字信号处理Matlab代码及相关知识\n\n:::warning\n\n默认已学习完信号与系统\n\n:::\n","link":"/posts/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86","content":"\n主要记录数字信号处理Matlab代码及相关知识\n\n:::warning\n\n默认已学习完信号与系统\n\n:::\n<!-- more -->\n\n# 数字信号处理简记\n----\n\n## 0.预备知识\n### 0.1 数字信号处理的过程\n\n<center>\n\n```mermaid\n\nstateDiagram\n  [*] --> 前置滤波器:$$x_a(t)$$\n  前置滤波器 --> A/D变换器\n  A/D变换器 --> 数字信号处理器:$$x(n)$$\n  数字信号处理器 --> D/A变换器:$$y(n)$$\n  D/A变换器 --> 模拟滤波器\n  模拟滤波器 --> [*]:$$y_a(t)$$\n\n```\n</center>\n\n### 0.2 信号的周期\n\n- 离散信号：周期必须为整数，并且当且仅当两个周期信号的周期之比为有理数时，相加之和的信号才为周期信号，此时的和信号周期为它们的最小公倍数\n- 连续信号：周期可以是整数、无理数、有理数，且当且仅当两个周期信号的周期之比为有理数时，它们的和信号才是周期信号，且和信号周期为它们的最小公倍数\n\n如 $\\sin(n)$，由于$N=\\frac{2\\pi}{n} \\neq R$ 不是周期信号\n$\\sin(\\pi n)$，由于$N=\\frac{2\\pi}{n\\pi}=R$ 是周期信号\n\n### 0.3 偶信号和奇信号\n\n任意信号都可以分解成偶信号和奇信号之和\n\n- 奇信号($Od\\{x[n]\\}$) $=\\frac{1}{2}x[n]-x[-n]$\n- 偶信号($Ev\\{x[n]\\}$) $=\\frac{1}{2}x[n]+x[-n]$\n\n### 0.4 序列的基本运算\n\n- 移位  $x(n\\pm m)$\n- 翻褶  $x(-n)$\n- 和  $x(n)+y(n)$\n- 积  $x(n)\\bullet y(n)$\n- 累加  $y(n)=\\sum\\limits_{k=-\\infty}^\\infty x(k)$\n- 差分运算  $\\triangle x(n)=x(n+1)-x(n) \\\\ \\triangle x(n)=x (n)-x(n-1)$\n\n\n### 0.5 序列的能量和功率\n\n- 能量：$E_\\infty=\\lim\\limits_{N \\to \\infty}\\sum\\limits_{n = -N}^\\infty|x[n]|^2=\\sum\\limits_{n = -\\infty}^\\infty|x[n]|^2$\n- 功率：$P_\\infty=\\lim\\limits_{N \\to \\infty}\\frac{1}{2N+1}\\sum\\limits_{n = -N}^\\infty|x[n]|^2$\n\n---\n\n- 能量信号：能量有限，功率为0\n- 功率信号：功率有限，能量数值无界\n- 非功非能信号：不满足上述两个条件的信号\n\n:::warning\n\n因此说一个序列要么是功率信号要么是能量信号是错误的\n\n:::\n\n### 0.6 离散时间(傅里叶变换DTFT)\n\n$X(e^{j\\omega})=DTFT[x(n)]=\\sum\\limits_{n=-\\infty}^\\infty x(n)e^{-j\\omega n}$\n\n即将$z$换成$e^{j\\omega}$\n\n:::tip Tips\n\n时域周期->频域离散\n\n时域离散->频域周期\n\n时域非周期->频域连续\n\n时域连续->频域非周期\n\n:::\n\n可以看出 $e^{j\\omega n}$ 是以 $2\\pi$ 为周期的正交周期函数\n\n反变换：IDTFT\n\n## 1.离散傅里叶变换(DFT)\n### 1.1 周期序列的傅里叶级数对——离散傅里叶级数(DFS)\n\n$$\n\n\\tilde{X}(k)=\\sum\\limits_{n=0}^{N-1}\\tilde{x}(n)e^{-j\\frac{2\\pi}{N}nk}\n\n$$\n\n> IDFS:\n\n$$\n\n\\tilde{x}(n)=\\frac{1}{N}\\sum\\limits_{k=0}^{N-1}\\tilde{X}(k)e^{j\\frac{2\\pi}{N}nk}\n\n$$\n\n其中  $e^{j\\frac{2\\pi}{N}nk}$ 称为旋转因子，$\\tilde{x}$ 上的波浪线代表其为周期函数\n\n在数字信号处理中一般使用符号 $W_N=e^{j\\frac{2\\pi}{N}}$，其中N为离散序列的周期\n故有：\n\n$$\n\nW_N^k=e^{j\\frac{2\\pi}{N}k}\n\n$$\n$$\n\nW_N^{nk}=e^{j\\frac{2\\pi}{N}nk}\n\n$$\n\n$$\n\\cdots\n$$\n\n> $W_N$ 的性质：\n> - 共轭对称性：$W_N^n=(W_N^{-n})^*$\n> > 在复变中，指数型复数取共轭即在 $j$ 前加负号\n> - 周期性：$W_N^n=W_N^{n+iN}$\n> - 可约性：$W_N^{in}=W_{N/i}^{n}$ , $W_{Ni}^{in}=W_N^n$\n> - 正交性：\n$$\n\\frac{1}{N}\\sum\\limits_{k=0}^{N-1}W_N^{nk}(W_N^{mk})^*=\\frac{1}{N}\\sum\\limits_{k=0}^{N-1}W_N^{(n-m)k}=\\begin{cases}\n    1\\quad n-m=iN\\\\\n    0\\quad n-m\\neq iN\n\\end{cases}\n$$\n\n### 1.2 DFS与DTFT的关系\n\n$\\tilde{X}(k)$ 这一周期序列可以看作是 $\\tilde{x}(n)$ 的一个周期 $x(n)$ 的z变换 $X(z)$ 在z平面单位圆上按等间隔角 $\\frac{2\\pi}{N}$ 抽样得到，或是 $x(n)$ 的傅里叶变换 $X(e^{j\\omega})$ 在 $[0,2\\pi)$ 上的N点等间隔采样，抽样间隔为 $\\frac{2\\pi}{N}$\n\n$$\n\n\\tilde{X}(k)=X(z)|_{z=e^{j\\frac{2\\pi}{N}k}}\n\n$$\n\n$$\n\n\\tilde{X}(k)=X(e^{j\\omega})|_{\\omega=\\frac{2\\pi}{N}k}\n\n$$\n\n省流就是在z平面或者在频谱上进行抽样\n\ne.g：计算 1 1 1 1 1 的5点DFS：\n\n$$\n\\tilde{X}(k) = \\sum_{n=0}^{N-1} \\tilde{x}(n) e^{-j \\frac{2\\pi}{N} nk}\n$$\n$$\n\\tilde{X}(0) = \\sum_{n=0}^{4} \\tilde{x}(n) e^{-j \\frac{2\\pi}{5} n \\cdot 0} = \\sum_{n=0}^{4} 1 \\cdot 1 = 5\n$$\n\n$$\n \\tilde{X}(1) = \\sum_{n=0}^{4} \\tilde{x}(n) e^{-j \\frac{2\\pi}{5} n \\cdot 1} = \\sum_{n=0}^{4} e^{-j \\frac{2\\pi}{5} n}\n$$\n\n$$\n \\tilde{X}(1) = 1 + e^{-j \\frac{2\\pi}{5}} + e^{-j \\frac{4\\pi}{5}} + e^{-j \\frac{6\\pi}{5}} + e^{-j \\frac{8\\pi}{5}} = 0\n$$\n（等比数列的求和公式）\n\n$$\n \\tilde{X}(2)=\\cdots \\\\\n \\tilde{X}(3)=\\cdots \\\\\n \\cdots\n$$\n\n最后可得结果：5 0 0 0 0\n\n### 1.3 离散傅里叶变换DFT\n\n","cover":"https://pic.akorin.icu/5jxcqhea.png","date":"2025-02-19 00:00:00"},{"title":"数字信号处理Matlab编程","tags":["笔记","数字信号处理","matlab"],"categories":["笔记"],"author":"akorin","excerpt":"\n记录数字信号处理有关的Matlab代码\n\n","link":"/posts/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86Matlab","content":"\n记录数字信号处理有关的Matlab代码\n\n<!-- more -->\n\n# 数字信号处理Matlab\n\n---\n\n## 数字滤波器的设计方法\n\n:::warning\n\n有关数字滤波的函数输入都是归一化的频率而不是角频率，有关模拟滤波的函数输入都是角频率\n\n:::\n\n有两种数字滤波器：\n- iir   无限长冲激响应滤波器\n- fir   有限长冲激响应滤波器\n\niir 的设计方法：\n- 冲激响应不变法\n  - 两种模拟滤波器：巴特沃斯滤波器、切比雪夫滤波器\n  - 不能设计高通和带阻滤波器\n- 双线性变换法\n\nfir 的设计方法：\n- 窗函数法\n  - 须确保窗长度为奇数，即确保阶数为偶数\n- 频率取样法\n\n:::tip 带通滤波器的中心频率计算\n带通滤波器下限频率和上限频率的几何平均值\n$$\n\\omega_0=\\sqrt{\\omega_{p_1}\\omega_{p_2}}\n$$\n:::\n\n:::tip 带通滤波器的上下截止频率计算\n近似为阻带截止频率和通带截止频率和的一半\n$$\n\\omega_c=\\frac{\\omega_s+\\omega_p}{2}\n$$\n:::\n\n\n### 所需的函数\n\n#### `buttord`\n\n生成对应标准型巴特沃斯的阶数和截止频率\n\n> 语法：\n- `[n,Wn] = buttord(Wp,Ws,Rp,Rs)`\n- `[n,Wn] = buttord(Wp,Ws,Rp,Rs,'s')`\n- `[n,Wn] = buttord(Wp,Ws,Rp,Rs,'z')`\n\n> 参数：\n- Wp: 通带截止频率，模式为数字滤波器时，输入需归一化；模式为模拟滤波器时，输入单位是rad/s\n- Ws: 阻带截止频率，模式为数字滤波器时，输入需归一化；模式为模拟滤波器时，输入单位是rad/s\n- Rp: 通带衰减\n- Rs: 阻带衰减\n- 's': 设定为模拟类型的滤波器，缺省则默认为数字滤波器\n- 'z': 设定为数字类型的滤波器，缺省则默认为数字滤波器\n\n> 返回值：\n- n:  返回巴特沃斯的最低阶数\n- Wn: 返回截止频率的标量（-3dB位置）\n\n\n:::warning 归一化\n输入范围为0~1，其中1对应 $\\pi$ 弧度/采样点，即最大频率或最小采样频率/2（奈奎斯特频率）\n\n归一化频率计算公式：\n$$\nf_{norm}=\\frac{f}{\\frac{fs}{2}}=\\frac{f}{f_{Nyquist}}\n$$\n归一化的单位是Hz/样本，直接乘上 $\\pi$ 转化成弧度则为：rad/样本，即\n$$\n\\omega = f_{norm} \\times \\pi\n$$\n本质上是一个比例，不是物理上确切的单位\n:::\n\n:::tip 归一化频率转化为原始频率\n对于f 频率来说：\n$$\nf=f_{norm} \\times \\frac{fs}{2}\n$$\n对于 $\\omega$ 角频率来说：\n$$\n\\omega = 2\\pi f= 2\\pi\\times f_{norm}\\times \\frac{f_s}{2} =2\\pi \\times  \\frac{\\omega_{norm}}{\\pi} \\times \\frac{f_s}{2}=\\omega_{norm} \\times f_s\n$$\n:::\n\n#### `buttap`\n\n> 语法：\n- `[z,p,k] = buttap(n)`\n\n> 参数：\n- n:  巴特沃斯滤波器阶数\n\n> 返回值：\n- z:  模拟滤波器的极点\n- p:  模拟滤波器的零点\n- k:  模拟滤波器的增益\n\n\n#### `zp2tf`\n\n将零极点增益参数转化为传递函数的形式\n\n> 语法：\n- `[b,a] = zp2tf(z,p,k)`\n\n> 参数：\n- z:  模拟滤波器的极点\n- p:  模拟滤波器的零点\n- k:  模拟滤波器的增益\n\n> 返回值：\n- b:  传递函数分子的系数\n- a:  传递函数分母的系数\n\n#### `freqs`\n\n求出模拟滤波器的频率响应\n\n> 语法：\n- `h = freqs(b,a,w)`\n- `[h,wout] = freqs(b,a,n)`\n- `freqs(___)`\n\n> 参数：\n- b:  传递函数分子的系数\n- a:  传递函数分母的系数\n- w（可选）:  角频率w处计算复频率响应\n- n（可选）:  使用n个频率点计算h并在wout中返回对应角频率，缺省默认是200\n\n> 返回值：\n- h:  返回由b和a指定的模拟滤波器在角频率w处计算得到的复频率响应\n- wout: 返回使用n个频率点计算h得到的角频率\n- freqs(___): 不带返回值参量，直接在窗口中以角频率的函数形式绘制幅频响应曲线和相频响应曲线\n\n\n#### `freqz`\n\n求出模拟滤波器的频率响应\n\n> 语法：\n- `h = freqz(b,a,w)`\n- `[h,w] = freqz(b,a,n)`\n- `[h,w] = freqz(b,a,n,fs)`\n- `[h,w] = freqz(b,a,n,\"whole\")`\n- `[h,w] = freqz(b,a,n,\"whole\",fs)`\n- `freqz(___)`\n\n> 参数：\n- b:  传递函数分子的系数\n- a:  传递函数分母的系数\n- w（可选）:  **归一化**的角频率w处计算复频率响应\n- n（可选）:  使用n个频率点计算h并在wout中返回对应角频率，缺省默认是200\n- \"whole\"（可选）: 返回整个单位圆n个采样点的频率响应，即返回(0~2 $\\pi$ 的采样点，缺省时返回的是0~ $\\pi$ 的采样点)\n\n> 返回值：\n- h:  返回由b和a指定的模拟滤波器在角频率w处计算得到的复频率响应\n- wout: 返回使用n个频率点计算h得到的角频率\n- freqs(___): 不带返回值参量，直接在窗口中以角频率的函数形式绘制幅频响应曲线和相频响应曲线\n\n\n#### `lp2lp`\n标准的巴特沃斯模拟低通滤波器原型转换为具有指定截止频率的模拟低通滤波器。通过zp2tf生成的标准巴特沃斯低通滤波器的截止频率通常是1rad/s，因此需要转换成所需要的\n\n> 语法：\n- `[bt,at] = lp2lp(b,a,Wo)`\n- `[At,Bt,Ct,Dt] = lp2lp(A,B,C,D,Wo)`\n\n> 参数：\n- b: 转换前的传递函数分母的系数\n- a: 转换前的传递函数分子的系数\n- wo: 新的滤波器截止频率\n\n> 返回值：\n- bt: 转换后的新的传递函数分母的系数\n- at: 转换后的新的传递函数分子的系数\n\n#### `lp2hp`\n\n转换成特定截止频率的高通滤波器\n\n#### `lp2bp`\n转换成特定截止频率的带通滤波器\n\n\n> 语法：\n- `[B1,A1]=lp2bp(num1, den1, Wo, bw)`\n\n> 参数：\n- Wo: 带宽的中心频率\n  - 一般是几何平均\n\n:::warning\n与fir带通数字滤波器相比，lp2bp的Wo传输的值是通带的中心频率，而fir1中的Wn传输的是上下通带的截止频率\n:::\n\n#### `lp2bs`\n\n转换成特定截止频率的带阻滤波器\n\n> 语法：\n- `[bt,at] = lp2bs(b,a,Wo,Bw)`\n\n> 参数：\n- Wo: 阻带的中心频率\n  - 一般是几何平均\n\n#### `impinvar`\n\n脉冲响应不变法将模拟滤波器转换为数字滤波器\n\n> 语法：\n- `[bz,az] = impinvar(b,a,fs)`\n\n> 参数：\n- b: 模拟滤波器传递函数的分母\n- a: 模拟滤波器传递函数的分子\n- fs: 采样频率\n\n> 返回值：\n- bz: 数字滤波器传递函数的分母\n- az: 数字滤波器传递函数的分子\n\n#### `bilinear`\n\n双线性变换法将模拟滤波器转换为数字滤波器\n\n> 语法：\n- `[zd,pd,kd] = bilinear(z,p,k,fs)`\n- `[numd,dend] = bilinear(num,den,fs)`\n\n> 参数：\n- z:  模拟滤波器的极点\n- p:  模拟滤波器的零点\n- k:  模拟滤波器的增益\n- fs: 采样频率\n- num:  模拟滤波器传递函数分母\n- den:  模拟滤波器传递函数分子\n\n> 返回值：\n- zd: 数字域的极点\n- pd: 数字域的零点\n- kd: 数字域的增益\n- numd: z域传递函数分母\n- dend: z域传递函数分子\n#### `cheb1ord`\n\n生成对应的标准型I型切比雪夫滤波器\n\n> 语法：\n- `[n,Wn] = cheb1ord(Wp,Ws,Rp,Rs)`\n- `[n,Wn] = cheb1ord(Wp,Ws,Rp,Rs,'s')`\n- `[n,Wn] = cheb1ord(Wp,Ws,Rp,Rs,'z')`\n\n> 参数：\n- Wp: 通带截止频率，模式为数字滤波器时，输入需归一化；模式为模拟滤波器时，输入单位是rad/s\n- Ws: 阻带截止频率，模式为数字滤波器时，输入需归一化；模式为模拟滤波器时，输入单位是rad/s\n- Rp: 通带衰减\n- Rs: 阻带衰减\n- 's': 设定为模拟类型的滤波器，缺省则默认为数字滤波器\n- 'z': 设定为数字类型的滤波器，缺省则默认为数字滤波器\n\n> 返回值：\n- n:  对应切比雪夫滤波器的阶数\n- Wn: 对应的截止频率\n\n#### `ceil`\n\n> 语法：\n- `Y = ceil(X)`\n\n> 参数：\n- X: 元素值，也可以是数组\n\n> 返回值：\n- Y: X的四舍五入值，或者数组里的每个元素四舍五入后的值\n\n:::warning\n窗的长度=fir滤波器的阶数+1\n:::\n\n#### `triang`\n\n三角窗\n\n#### `blackman`\n\n布莱克曼窗\n\n#### `hamming`\n\n海明窗\n\n#### `fir1`\n\n基于窗函数的 FIR 滤波器设计\n\n> 语法：\n- `b = fir1(n,Wn)`\n- `b = fir1(n,Wn,ftype)`\n- `b = fir1(___,window)`\n\n> 参数：\n- n:  fir滤波器的阶数。对于**高通**和**带阻**滤波器，fir1 始终使用偶数阶滤波器。此时阶数必须是偶数，因为奇数阶对称 FIR 滤波器在奈奎斯特频率下必须具有零增益。如果为高通或带阻滤波器指定奇数 n，则 fir1 将 n 增加 1。\n- Wn: 通带截止频率\n- ftype:  滤波器类型，缺省默认为低通滤波器\n  - 'high'\n  - 'low'\n  - 'bandpass'\n  - 'stop'\n- window: 窗函数类型，缺省默认为汉明窗\n\n#### `mod`\n\n> 语法：\n- `b = mod(a,m)`\n\n> 参数：\n- a:  被除数\n- m:  除数\n\n> 返回值：\n- b:  余数\n\n### 数字滤波器设计\n\n:::details 完整代码\n\n:::code-group\n\n<<< @/code/matlab/digitalSignalProcessing/iir_bp.m{matlab}[iir带通设计]\n<<< @/code/matlab/digitalSignalProcessing/fir_bs.m{matlab}[fir带阻设计]\n<<< @/code/matlab/digitalSignalProcessing/bs.m{matlab}[fir、iir带阻设计]\n\n:::\n\n<div class=\"flex flex-col\">\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![](https://pic.akorin.icu/20250306165711447.png)\n\n![](https://pic.akorin.icu/20250306165728680.png)\n\n</div>\n</div>\n\n<div class=\"flex flex-col\">\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![](https://pic.akorin.icu/20250306165837959.png)\n\n![](https://pic.akorin.icu/20250306165846804.png)\n\n</div>\n</div>\n\n![](https://pic.akorin.icu/20250306165536593.png)\n\n## 生成各种信号的设计方法\n\n:::warning\n\n需要注意每个生成波形的函数的输入都是角频率乘时间即输入都是 $\\omega\\times t$\n\n:::\n\n### 所需函数\n\n#### `rand`\n\n返回一个在区间 (0,1) 内均匀分布的随机数\n\n> 语法：\n- `x=rand(n)`\n- `x=rand(a,n)`\n\n> 参数：\n- a:  序列矩阵的维度\n- n:  序列矩阵长度，当a缺省时生成nxn的随机数矩阵\n\n> 返回值：\n- x:  输出的序列\n\n#### `randn`\n\n返回一个从标准正态分布中得到的随机标量，均值为0方差为1\n\n> 语法：\n- `x=randn(n)`\n- `x=randn(a,n)`\n\n> 参数：\n- a:  序列矩阵的维度\n- n:  序列矩阵长度，当a缺省时生成nxn的随机数矩阵\n\n> 返回值：\n- x:  输出的序列\n\n#### `rectpuls`\n\n生成方波信号\n\n> 语法：\n- `y = rectpuls(t0,w)`\n\n> 参数：\n- t0: 方波中心点\n- w:  宽度\n\n#### `square`\n\n生成周期方波信号\n\n> 语法：\n- `x = square(w*t,duty)`\n\n> 参数：\n- w*t:  w为方波信号的角速度，对应的周期为 $T=\\frac{2\\pi}{\\omega}$ ，t为时间参数（一维向量）\n- duty: 方波信号的周期\n\n> 返回值：\n- x:  对应时间参数t的一系列幅值，幅值范围为-1~1\n\n#### `sawtooth`\n\n生成锯齿波信号\n\n> 语法：\n- `x = sawtooth(w*t,xmax)`\n\n> 参数：\n- xmax: 峰值位置范围0~1，当设置为0.5时，生成标准三角波，缺省时，xmax默认为1\n\n### 生成常用波形\n\n:::details 完整代码\n\n:::code-group\n\n<<< @/code/matlab/digitalSignalProcessing/impulse_t.m{matlab}[阶跃响应]\n<<< @/code/matlab/digitalSignalProcessing/square_duty.m{matlab}[方波设计]\n<<< @/code/matlab/digitalSignalProcessing/sawtooth_t.m{matlab}[锯齿波/三角波设计]\n\n:::\n\n![](https://pic.akorin.icu/20250306191320790.png)\n\n<div class=\"flex flex-col\">\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![](https://pic.akorin.icu/20250306191224974.png)\n\n![](https://pic.akorin.icu/20250306191232702.png)\n\n</div>\n</div>\n\n<div class=\"flex flex-col\">\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![](https://pic.akorin.icu/20250306191351382.png)\n\n![](https://pic.akorin.icu/20250306191358180.png)\n\n</div>\n</div>\n\n\n\n\n## 求解各种系统函数的阶跃响应、冲激响应\n### 所需函数\n\n#### `impulse`\n\n求解连续系统的冲激响应\n\n> 语法：\n- `impulse(sys)`\n- `impulse(sys,Tfinal)`\n- `impulse(sys,t)`\n- `y = impulse(sys)`\n- `[y,t] = impulse(sys)`\n\n> 参数：\n- sys:  tf函数生成的系统，也可以将分母系数b、分子系数a填入其中\n- Tfinal: 求解0到Tfinal这段时间内的冲激响应\n- t:  求解t这段设定的时间向量内的冲激响应\n\n> 返回值：\n- y:  求解冲激响应的结果\n- t:  求解的结果对应的时间点\n-\n#### `dimpulse`\n\n求解离散系统的冲激响应\n\n> 语法：\n- `dimpulse(sys)`\n- `dimpulse(sys,Tfinal)`\n- `dimpulse(sys,t)`\n- `y = dimpulse(sys)`\n\n> 参数：\n- sys:  tf函数生成的系统，也可以将分母系数b、分子系数a填入其中\n- Tfinal: 求解0到Tfinal这段时间内的冲激响应\n- t:  求解t这段设定的时间向量内的冲激响应\n\n> 返回值：\n- y:  求解冲激响应的结果\n- t:  求解的结果对应的时间点\n\n#### `impz`\n\n求解数字滤波器系统的冲激响应\n\n#### `step`\n\n求解连续时间系统阶跃响应\n\n> 语法：\n- `step(sys)`\n- `step(sys,Tfinal)`\n- `step(sys,t)`\n- `y = step(sys,t)`\n- `[y,t] = step(sys)`\n\n> 参数：\n- sys:  tf函数生成的系统，也可以将分母系数b、分子系数a填入其中\n- Tfinal: 求解0到Tfinal这段时间内的阶跃响应\n- t:  求解t这段设定的时间向量内的阶跃响应\n\n> 返回值：\n- y:  求解阶跃响应的结果\n- t:  求解的结果对应的时间点\n\n#### `dstep`\n\n求解离散时间系统的阶跃响应\n\n> 语法：\n- `[Y,X] = dstep(b,a)`\n- `[Y,X] = dstep(b,a,t)`\n\n#### `lsim`\n\n求解连续时间系统的全响应\n\n> 语法：\n- `y = step(sys,t)`\n- `y = step(b,a,t)`\n- `[y,t] = step(sys)`\n- `[y,t] = step(b,a)`\n\n> 参数：\n- sys:  tf的连续系统\n- t:    时间范围\n- b:    系统函数的分子\n- a:    系统函数的分母\n\n#### `dlsim`\n\n求解离散时间系统的全响应\n\n> 语法：\n- `[Y,X] = dlsim(b,a,x)`\n- `Y = dlsim(b,a,x)`\n\n\n### 求出冲激响应和阶跃响应以及全响应\n（连续系统）求该系统的冲激响应、阶跃响应以及输入为方波的全响应\n$$\nH(s)=\\frac{1}{LCs^2+RCs+1}\n$$\n\n（离散系统）已知一个IIR数字低通滤波器的系统函数为\n\n$$\nH(z)=\\frac{0.1321+0.3963z^{-1}+0.3963z^{-2}+0.1321z^{-3}}{1-0.34319z^{-1}+0.60439z^{-2}-0.20407^{-3}}\n$$\n\n\n:::details 完整代码\n:::code-group\n\n<<< @/code/matlab/digitalSignalProcessing/impulse_step.m{matlab}[连续系统]\n<<< @/code/matlab/digitalSignalProcessing/impz_dlsim.m{matlab}[离散系统]\n\n\n\n:::\n\n<div class=\"flex flex-col\">\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![](https://pic.akorin.icu/20250306191115726.png)\n\n![](https://pic.akorin.icu/20250306191125325.png)\n\n![](https://pic.akorin.icu/20250307154416448.png)\n\n</div>\n</div>\n\n![](https://pic.akorin.icu/20250307160823893.png)\n\n## 转换系统函数的类型\n### 所需函数\n\n#### `tf2sos`\n\n将直接型滤波器转化成级联型\n\n> 语法：\n- `[sos,g] = tf2sos(b,a)`\n\n> 参数：\n- b:  传递函数的分母\n- a:  传递函数的分子\n\n> 返回值：\n- sos:  级联型的传递函数形式\n- g:  增益\n\n\n#### `residue`\n\n连续域的分式展开（部分分式分解）\n\n> 语法：\n- `[r,p,k] = residue(b,a)`\n\n> 参数：\n- b:  传递函数分母\n- a:  传递函数分子\n\n> 返回值\n- r:  新的并联型传递函数的一系列分子\n- p:  传递函数的一系列极点\n- k:  传递函数的冲激项\n\n#### `residuez`\n\nz域的部分分式展开（部分分式分解）\n\n> 语法：\n- `[r,p,k] = residuez(b,a)`\n\n> 参数：\n- b:  传递函数分母\n- a:  传递函数分子\n\n> 返回值\n- r:  新的并联型传递函数的一系列分子\n- p:  传递函数的一系列极点\n- k:  传递函数的冲激项\n\n### 将直接型系统函数转换成级联型和并联型\n\n$$\nH(s)=\\frac{s^4-2s^3+30s^2+14s+5}{5s^4+4s^3+4s^2-2s-1}\n$$\n\n<<< @/code/matlab/digitalSignalProcessing/res_sos.m{matlab}[转换]\n\n\n<div class=\"flex flex-col\">\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![](https://pic.akorin.icu/20250307193448574.png)\n\n![](https://pic.akorin.icu/20250307193512079.png)\n\n</div>\n</div>\n\n根据上图的两个结果可得：\n$$\nH(s)=0.2\\frac{s^2-2.4647s+30.9839}{s^2-0.1964s-0.1714} \\cdot \\frac{s^2+0.4647s+0.1614}{s^2+0.9964s+1.1671}\n$$\n\n$$\nH(s)=\\frac{s+1.0378+1.9180j}{s+0.4982-0.9586j}+\\frac{s+1.0378-1.9180j}{j+0.4982+0.9586j}+\n$$\n$$\n\\frac{s-2.4360}{s-0.5237}+\\frac{s+0.9240}{s+0.3272}+0.2\n$$\n## 求解频谱\n### 傅里叶变换和反变换\n\n在matlab中求某变量的积分，可以用到矩阵乘法\n\n有一非周期方波信号x(t)的脉冲宽度为1ms，信号持续时间为2ms，在0~2ms区间外信号为0。试求其含有20次谐波的信号的频谱特性。求其逆变换并与原时间信号的波形进行比较。\n\n:::details 完整代码\n\n<<< @/code/matlab/digitalSignalProcessing/fuliye.m{matlab}[傅里叶变化]\n\n:::\n\n![](https://pic.akorin.icu/20250307182242524.png)\n\n```matlab\nf=-20/2e-3:40/2e-3/N:20/2e-3;   % 20次谐波的频谱范围\n```\n这里是计算出20次谐波的频谱范围，取N次谐波内的频谱公式为：\n$-N\\times\\frac{1}{T}$ ~ $N\\times\\frac{1}{T}$\n\n其中T为信号的有效时间范围\n\n```matlab\nX=x*exp(-j*t'*w)*dt;            % 傅里叶变换\n```\n```matlab\ny=1/pi*X*exp(j*w'*t)*dw;        % 逆傅里叶变换\n```\n这两步都实现了积分\n```matlab\nt'*w\n```\n这个操作是将t进行转置后与w矩阵相乘，最后得到(n+1)x(n+1)的矩阵，（n+1是因为首尾的点都算进去没有减掉）。这个矩阵可以看作是每个频域点上对应的所有时间对应值的集合，前面的x是1x(n+1)的矩阵，相乘之后得到的结果就是每个频域点上所有时间对应值之和，相当于计算了积分（matlab是离散点计算本质还是求和）\n\n通过这个原理可以解决所有含有积分符号的公式\n\n\n### 计算两个序列的互相关\n\n互相关函数:\n$$\nr_{xy}(m)=\\sum\\limits^\\infty_{n=-\\infty}x(n)y(n-m)\n$$\n\n在matlab中可以先把两个序列分别用fft函数求其频谱，在频域下前一个序列的共轭与另一个序列相乘，得到的结果再ifft后循环移位可得到它们的结果\n\n:::details 完整代码\n\n<<< @/code/matlab/digitalSignalProcessing/fft_rr.m{matlab}[求两个不同序列的互相关]\n\n:::\n\n![](https://pic.akorin.icu/20250327212742259.png)\n","cover":"https://pic.akorin.icu/封面4.png","date":"2025-03-03 00:00:00"},{"title":"栈与队列","tags":["学习","编程","C++"],"categories":["笔记"],"author":"akorin","excerpt":"\n> 栈与队列需要依赖数组或者链表，且都不是一个单独的数据结构。\n\n","link":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97","content":"\n> 栈与队列需要依赖数组或者链表，且都不是一个单独的数据结构。\n\n<!-- more -->\n\n**栈** 和 **队列** 本质上是抽象数据结构（ADT, Abstract Data Type），它们定义的是操作规则，而不是具体的存储方式。\n\n## 栈\n\n- 允许插入、删除的一端称为栈顶（`top`）。\n- 另一端称为栈底（`bottom`），固定不动。\n\n> 特点： 先进后出、后进先出(LIFO\\FILO)，像个弹夹。\n\n### 顺序栈\n\n顺序栈是依赖于数组实现。\n- 栈顶指针 `top` 用于记录当前栈顶元素的位置。\n- 栈底位置固定，一般为数组下标 0。\n- 当 `top == -1`（或 0 元素不存在）时，栈为空。\n- 当 `top` 指向数组最后一个位置时，栈满（需要扩容或报错）。\n\n#### 基本操作\n\n1. 初始化：申请固定大小的数组空间，并将 `top` 置为 -1（空栈）。\n2. 入栈（Push）：判断栈是否已满，若未满，`top++` 后在 `top` 位置插入新元素。\n3. 出栈（Pop）：判断栈是否为空，若不为空，取出 `top` 位置的元素然后`top--` 。\n4. 栈满 ： `top == sizeof(arr)/sizeof(arr[0])`\n5. 取栈顶元素（GetTop）：直接访问 `top` 位置的元素，不修改 `top`。\n\n#### 出栈数据的规律\n\n例如 `[1,2,3,4,5]` 入栈，此时如下情况的出栈都是有可能的：\n- `5 4 3 2 1`\n- `4 3 5 2 1`\n\n但是 `4 3 1 5 2`是不可能的，因为 `1` 不可能直接越过 `2` 就出栈了。\n\n### 链式栈\n\n顾名思义就是用链表实现的栈结构，同样可以定义 `Node` 类型的指针 `top` 作为栈顶指针。\n- 栈顶指针 `top` 用于记录当前栈顶元素的位置。\n- 当 `top == nullptr`（或 0 元素不存在）时，栈为空。\n- 当 `top` 指向数组最后一个位置时，栈满（需要扩容或报错）\n\n#### 基本操作\n\n1. 初始化：申请固定大小的数组空间，并将 `top` 置为 `nullptr`（空栈）。\n2. 入栈（Push）：利用头插法入栈。令 `top = new Node`，然后 `top->next = head->next; head_->next = top;`。\n3. 出栈（Pop）：判断栈是否为空，若不为空，即删除 `top` 位置的元素然后`head->next = top->next; delete top; top = head->next` 。\n4. 栈满 ： 链式指针不存在判断栈满，除非系统分配不了堆内存。\n5. 访问栈顶元素（GetTop）：直接返回 `top->data` 。\n\n## 队列\n\n队列（Queue）是一种 **先进先出（FIFO, First In First Out）**的数据结构，可以类比为排队买票：先来的人先走，后到的人只能排在队尾等候。\n\n### 环形队列\n\n- `front` : 队头\n- `rear` : 队尾\n\n#### 基本操作\n\n1. 入队 ：只能在队尾（rear）插入元素， `rear = (rear + 1) % size;`\n2. 出队 ：只能在队头（front）删除元素， `front = (front + 1) % size;`\n3. 顺序是固定的，不能随机访问中间元素（不像数组/向量那样支持 []）\n","cover":"https://pic.akorin.icu/20250814101334375.webp","date":"2025-08-14 00:00:00"},{"title":"红黑树","tags":["算法","二叉树","红黑树","编程","C++"],"categories":["算法"],"author":"akorin","excerpt":"\n# 红黑树\n\n红黑树不是一颗平衡树，节点到左右子树的高度差， **长的不超过短的2倍。** 比AVL旋转的次数要少很多。\n\n红黑树通过给节点增加**颜色属性（红/黑）**并遵循一组规则，保证树的高度始终接近 O(log n)，从而在最坏情况下也能高效完成查找、插入和删除操作。\n\n如果主要使用查询操作，那就还是AVL树的效率更高一点。但是如果插入、删除、查询都很频繁，这个时候使用红黑树就比较好了。\n\n> 由于红黑树要频繁访问祖父节点和舅舅节点，主流都采用非递归的形式。\n\n","link":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"\n# 红黑树\n\n红黑树不是一颗平衡树，节点到左右子树的高度差， **长的不超过短的2倍。** 比AVL旋转的次数要少很多。\n\n红黑树通过给节点增加**颜色属性（红/黑）**并遵循一组规则，保证树的高度始终接近 O(log n)，从而在最坏情况下也能高效完成查找、插入和删除操作。\n\n如果主要使用查询操作，那就还是AVL树的效率更高一点。但是如果插入、删除、查询都很频繁，这个时候使用红黑树就比较好了。\n\n> 由于红黑树要频繁访问祖父节点和舅舅节点，主流都采用非递归的形式。\n\n<!-- more -->\n\n## 红黑树的规则\n\n红黑树必须满足以下 5 条性质：\n\n1. 每个节点要么是红色，要么是黑色；\n2. 根节点 **必须** 是黑色；\n3. 所有叶子节点的孩子都是NULL，NULL是黑色；\n4. 如果一个节点是红色的，那么它的子节点必须是黑色的（不能有两个连续的红色节点）；\n5. 对于任意节点，从该节点到所有叶子节点的路径上，黑色节点数相同（黑高一致）。\n\n这些规则保证了树不会出现太长的链状结构，从而接近平衡。  \n根据规则4、5，当插入节点（红节点）与虽规则4冲突时，其必有一个\n\n在这5条规则下，假如有两条路径，一条全是黑节点，另一条是红节点和黑节点相间。此时，最长的一条是最短的一条的两倍。\n\n基于这5条规则也可得出：\n\n1.  **红黑树上，节点的左右子树高度差最多不能超过同一路径上的黑色节点数的一倍，也就是说最长路径不会超过最短路径的两倍。**\n2.  要出现只有一棵子树的情况，只有 **一黑一红时** 才会出现。如果 **一黑一红** 的子树添加黑节点，则不满足规则5，如果添加红节点，则不满足规则4。\n3.  红节点 **要么没有孩子要么必定有两个黑孩子** ，不会出现只有一个黑孩子的情况。\n4.  **黑节点必定有一个兄弟。**\n\n### 红黑树的定义\n\n:::code-group\n\n```C++ [节点定义]\nstruct Node {\n    Node(T data = T(), Node* parent = nullptr, Node* left = nullptr,\n          Node* right = nullptr, Color color = Black) :\n        data_(data),\n        left_(left),\n        right_(right),\n        parent_(parent),\n        color_(color) {}\n    T data_;\n    Node* left_;\n    Node* right_;\n    Node* parent_;\n    Color color_;\n};\n```\n\n```C++ [类定义和颜色定义]\n\nenum Color { Black, Red };\n\ntemplate<typename T>\nclass RBTree {\nprivate:\n    struct Node;\n\npublic:\n    RBTree() : root_(nullptr) {}\n    ...\n}\n\n```\n\n:::\n\n### 辅助接口\n\n```C++\n\n// 获取节点颜色\nColor getColor(Node* node) {\n    return node ? node->color_ : Black;\n}\n// 设置节点颜色\nvoid setColor(Node* node, Color color) {\n    node->color_ = color;\n}\n// 返回节点的左孩子\nNode* getLeft(Node* node) {\n    return node->left_;\n}\n// 返回节点的右孩子\nNode* getRight(Node* node) {\n    return node->right_;\n}\n// 返回节点的父亲\nNode* getParent(Node* node) {\n    return node->parent_;\n}\n```\n\n## 红黑树的旋转\n\n1. 和AVL树的旋转操作类似，但是红黑树的节点增添了一个父节点指针， **因此旋转过程中需要更新父节点地址。**\n2. 由于是非递归代码，需要记录好要旋转节点的父节点和孩子。\n3. 若父节点为 `nullptr` ，说明是根节点在旋转，因此需要更新 `root_` 根节点指针。\n4. 判断当前节点 `node` 是父节点的哪个孩子，更新父节点的孩子为 `child_` 。\n5. 开始旋转，更新 `child_` 孩子（若存在）的父节点为 `node`，并挂在 `node` 上。\n6. 将 `node` 挂在 `child_` 上并更新其父节点指针为 `child_` 。\n\n:::code-group\n\n```C++ [左旋转]\n// 左旋转\nvoid leftRotate(Node* node) {\n    if (!node)\n        return;\n    Node* child = node->right_;\n    if (!child)\n        return;\n    Node* parent = node->parent_;\n    if (!parent) {\n        // 头节点在旋转\n        root_ = child;\n    } else if (parent->left_ == node) {\n        parent->left_ = child;\n    } else {\n        parent->right_ = child;\n    }\n    child->parent_ = parent;\n\n    node->right_ = child->left_;\n    if (node->right_) {\n        // 避免是nullptr\n        node->right_->parent_ = node;\n    }\n    child->left_ = node;\n    node->parent_ = child;\n}\n```\n\n```C++ [右旋转]\n// 右旋转\nvoid rightRotate(Node* node) {\n    if (!node)\n        return;\n    Node* child = node->left_;\n    if (!child)\n        return;\n    Node* parent = node->parent_;\n    if (!parent) {\n        // 头节点在旋转\n        root_ = child;\n    } else if (parent->left_ == node) {\n        parent->left_ = child;\n    } else {\n        parent->right_ = child;\n    }\n    child->parent_ = parent;\n\n    node->left_ = child->right_;\n    if (node->left_) {\n        // 避免是nullptr\n        node->left_->parent_ = node;\n    }\n    child->right_ = node;\n    node->parent_ = child;\n}\n```\n\n:::\n\n## 红黑树的插入\n\n1. 常规 BST 插入定位\n   - 若树为空：创建节点并染成黑色（根必须黑）。插入结束。\n   - 否则：创建新节点，初始颜色设为红色（这是关键：用红色先不影响黑高）。\n2. 如果新节点的父亲是黑色：不违反任何性质（允许黑-红，允许黑-黑），插入完成。\n3. 如果父亲是红色：出现“红红冲突”（违反性质 4），需要修复。设：\n   - `p` = parent（红）\n   - `g` = grandparent（必为黑，否则上一轮已修）\n   - `u` = uncle（g 的另一个孩子，可能为空，空视为黑）\n4. 分三大类（经典 while 循环中的三个 Case，左右对称）：\n   - **Case 1**（叔叔 u 是红）\n     - 将父亲 p 和叔叔 u 染黑\n     - 将祖父 g 染红\n     - 将“当前节点”上移为 g，继续循环（因为 g 变红后可能与其父再形成红红）\n   - **Case 2**（叔叔 u 是黑，且当前节点是“内侧”——形成“折线”）:变色后，需要维持原来黑色节点个数不变。\n     - 先对父亲做一次旋转（把折线转成直线）\n     - 交换当前节点与父亲角色（当前节点重新指向父亲，进入 Case 3）\n   - **Case 3**（叔叔 u 是黑，且当前节点是“外侧”——形成“直线”）：变色后，需要维持原来黑色节点个数不变。\n     - 将父亲 p 染黑，祖父 g 染红\n     - 对祖父 g 做一次旋转（把祖父下沉）\n     - 该冲突解决，跳出循环\n5. 结束后强制把根染成黑色（可能因上移步骤使根被染红）。\n6. 插入完成。\n\n:::code-group\n\n```C++ [插入函数]\n// 插入\nvoid insert(const T& val) {\n    if (!root_) {\n        // 性质三：根节点必须为黑色\n        root_ = new Node(val);   // 默认black\n        return;\n    }\n    // 树不为空\n    Node* parent = nullptr;\n    Node* cur = root_;\n    while (cur) {\n        if (val < cur->data_) {\n            parent = cur;\n            cur = cur->left_;\n        } else if (val > cur->data_) {\n            parent = cur;\n            cur = cur->right_;\n        } else {\n            // 不插重复值\n            return;\n        }\n    }\n    // 此时cur == nullptr\n    Node* node = new Node(val, parent, nullptr, nullptr, Red);\n    if (val < parent->data_) {\n        parent->left_ = node;\n    } else {\n        parent->right_ = node;\n    }\n\n    if (parent->color_ == Red) {\n        // 当父节点也是红节点，此时需要进行调整\n        fixAfterInsert(node);\n    }\n    // 父节点是黑节点就不管了\n}\n```\n\n```C++ [调整函数]\n// 红黑树插入调整操作\nvoid fixAfterInsert(Node* node) {\n    while (node != root_ && node->parent_->color_ == Red) {\n        // 获取三个需要操作节点的指针\n        Node* parent = node->parent_;\n        Node* ancestor = parent->parent_;\n        if (ancestor->left_ == parent) {\n            // node在左子树，uncle在右子树\n            Node* uncle = ancestor->right_;\n            // 情况1，如果叔叔不存在那么也归属到情况2/3中\n            if (getColor(uncle) == Red) {\n                parent->color_ = Black;\n                ancestor->color_ = Red;\n                uncle->color_ = Black;\n                node = ancestor;\n            } else {\n                // 情况2/3，先处理情况3，情况3转换成情况2\n                if (node == parent->right_) {\n                    node = parent;\n                    // 使node指针始终指向parent的孩子节点\n                    // 否则旋转后指针会移动，parent和node指针会互换位置\n                    leftRotate(node);\n                    parent = node->parent_;\n                }\n                // 情况2/3处理后，祖先自然是黑节点，不用再调整祖先\n                // 改色需要在情况3旋转之后，否则可能会染错颜色\n                parent->color_ = Black;\n                ancestor->color_ = Red;\n                rightRotate(ancestor);\n                break;\n            }\n        } else {\n            Node* uncle = ancestor->left_;\n            if (getColor(uncle) == Red) {\n                parent->color_ = Black;\n                ancestor->color_ = Red;\n                uncle->color_ = Black;\n                node = ancestor;\n            } else {\n                // 情况2/3，先处理情况3，情况3转换成情况2\n                if (node == parent->left_) {\n                    node = parent;\n                    // 使node指针始终指向parent的孩子节点\n                    // 否则旋转后指针会移动，parent和node指针会互换位置\n                    rightRotate(node);\n                    parent = node->parent_;\n                }\n                // 情况2/3处理后，祖先自然是黑节点，不用再调整祖先\n                // 改色需要在情况3旋转之后，否则可能会染错颜色\n                parent->color_ = Black;\n                ancestor->color_ = Red;\n                leftRotate(ancestor);\n                break;\n            }\n        }\n    }\n    // 强制根节点设置为黑，直接设置为黑就行\n    root_->color_ = Black;\n}\n```\n\n:::\n\n## 红黑树的删除\n\n1. BST 常规查找要删除的键 `val`。\n2. 若目标节点有两个非空孩子：\n   - 找中序后继（或前驱），交换数据（只换值不换指针），然后把删除目标转化成“最多只有一个非空孩子”的节点。\n3. 若目标节点有一个非空孩子或没有：\n   - 将其孩子接到它的父节点上，然后删除该目标节点。\n4. 判断删除的是黑色节点还是红色节点。如果是 **红色** ，则是正常的BST删除，如果是 **黑色** ，则要判断补上来的孩子是什么颜色。\n5. 如果补上来的 **孩子是红色** ，那就 **不用往兄弟节点借黑节点** 了，直接把红孩子染成黑色即可。  \n   如果 **孩子是黑色** ，那就要进入到删除修复中， **看能不能从兄弟节点借黑节点过来，或者将其它分支的黑节点个数都减一。**\n\n### 删除修复（四大类情形）\n\n设当前“需要补黑的位置”为 `cur`，它的父亲为 `p`，兄弟为 `s`（sibling），兄弟的靠外孩子为 `s_far`（相对父亲的外侧），靠内孩子为 `s_near`。\n\n> 约定：空指针颜色视为黑色。\n\n| 情形   | 条件                                   | 操作                                                                                          | 结果 / 下一步                                                                             |\n| ------ | -------------------------------------- | --------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |\n| Case 1 | 兄弟为黑，靠外孩子红                   | 兄弟颜色设为父颜色；父染黑；靠外孩子染黑；围绕父做一次旋转。                                  | 双黑问题解决（跳出循环）。                                                                |\n| Case 2 | 兄弟为黑，靠外孩子黑，靠内孩子红       | 兄弟与靠内孩子交换颜色；围绕兄弟做一次旋转（朝“靠外”方向相反的旋转）；更新兄弟指针。          | 转化为 Case 1。                                                                           |\n| Case 3 | 兄弟为黑 且 兄弟两个孩子都黑（或为空） | 兄弟染红，这样另一颗子树就会少一个黑节点；当前双黑“上移”到父亲：`cur = p`，`p = cur.parent`。 | 可能继续向上，往祖先回溯（双黑冒泡）。 **直至所有分支的黑色节点个数都减一或红祖先染黑。** |\n| Case 4 | 兄弟 `s` 为红                          | 交换父兄颜色；围绕父做一次旋转（让兄弟变成新的父）。                                          | 转化为兄弟为黑的情形，继续循环。                                                          |\n\n最后：如果循环结束时 `cur` 在根但仍为“虚拟双黑”，直接把它视为普通黑（根强制为黑）。\n\n:::tip 双黑节点\n双黑节点可以看作一个标识，表示该节点的子树比其它子树 **少一个黑节点** ，此时要让兄弟子树也少一个黑节点，这样才能局部地让子树满足规则5。然后要回溯到其父节点，让父节点变成 **“双黑节点”** ，再让父节点（如果父节点还是黑节点）的兄弟子树少一个黑节点，这样就能让更大的子树满足规则5。\n:::\n\n> 对于 case2 （LR/RL型）先交换兄弟和兄弟孩子的颜色，再旋转兄弟，变成 case1 的形态。\n> ![](https://pic.akorin.icu/20250905175306490.webp)\n\n在 case1 中：\n\n1. **红孩子染黑**\n   - 避免旋转后出现连续红节点（违反红黑树性质 4）。\n   - 同时，它也在旋转后为路径补上一个黑色，保证黑高平衡。\n   - 其实相当于 **继承了兄弟的颜色** ，保证该子树黑高平衡。\n2. **兄弟染成父亲的颜色**\n   - 这是为了 **继承父节点原本的颜色信息** ，避免上层祖先的黑高被破坏。\n   - 一旦旋转，兄弟会上升取代父节点位置，如果它 **不继承父亲的颜色，就会让祖先那一侧的黑高丢失。**\n3. **父亲染黑** - 父亲下沉（旋转后变成子节点），补充黑节点。- 这等价于把「丢失的黑色」往下补给，让子树的黑高一致。\n   ![](https://pic.akorin.icu/20250905175334343.webp)\n\n在 case4 中， **红兄弟的孩子必为黑节点** ，因此：\n\n1. **兄父颜色交换**\n   - 旋转后保持黑高不变，避免出现 “红红” 情况。\n2. **父节点右旋**\n   - 将兄弟的孩子变成原来父亲的孩子，转换成双黑节点（被删除节点）的兄弟为黑的情况接着处理。\n\n:::code-group\n\n```C++ [删除函数]\n// 自写红黑树删除\nvoid del(const T& val) {\n    // 一般BST删除\n    Node* cur = root_;\n    while (cur) {\n        if (val < cur->data_) {\n            cur = cur->left_;\n        } else if (val > cur->data_) {\n            cur = cur->right_;\n        } else {\n            // 找到\n            break;\n        }\n    }\n    if (!cur) {\n        // 没找到或者树为空\n        cout << \"No data or No tree\" << endl;\n        return;\n    }\n    // 情况三\n    if (cur->left_ && cur->right_) {\n        // 前驱\n        Node* pre = cur->left_;\n        while (pre->right_) {\n            pre = pre->right_;\n        }\n        cur->data_ = pre->data_;\n        cur = pre;   // 统一使用cur指针\n    }\n    // 先处理再删除\n    Color deleteNodeColor = cur->color_;\n    if (deleteNodeColor == Black) {\n        fixBeforeRemove(cur);\n    }\n    // 情况1/2\n    Node* parent = cur->parent_;\n    Node* child = cur->left_ ? cur->left_ : cur->right_;\n    if (child) {\n        child->parent_ = parent;\n    }\n    if (!parent) {\n        // 删除的是根节点，且只有一个子树（一黑一红）\n        root_ = child;\n    } else if (cur == parent->left_) {\n        parent->left_ = child;\n    } else {\n        parent->right_ = child;\n    }\n    // 孩子接上父节点了，删除目标节点\n    delete cur;\n    // 强制染黑根节点\n    if (root_) {\n        root_->color_ = Black;\n    }\n}\n```\n\n```C++ [调整函数]\n// 红黑树删除前调整，node不可能为空\nvoid fixBeforeRemove(Node* node) {\n    // 定义一个辅助判断黑色函数\n    auto isBlack = [](Node* n) -> bool {\n        Color c = n ? n->color_ : Black;\n        return c == Black;\n    };\n    if (node == root_) {\n        return;\n    }\n    Node* parent = node->parent_;\n    if (node == parent->left_) {\n        Node* bro = parent->right_;\n        // 兄弟在右\n        // 情况4：兄弟为红。情况4处理完成后变成黑兄弟的情况。\n        // 黑节点必定存在兄弟，不用判定兄弟是否为空\n        if (bro->color_ == Red) {\n            // 交换兄父颜色\n            parent->color_ = Red;\n            bro->color_ = Black;\n            leftRotate(parent);\n            // 更新兄弟指针，旋转后parent指针没有动，bro指针变成祖父节点\n            bro = parent->right_;\n        }\n        // 情况3：黑兄弟且两个黑孩子。\n        // 黑兄弟有可能有两个黑孩子或没有孩子（两个nullptr）\n        if (isBlack(bro->left_) && isBlack(bro->right_)) {\n            // 兄弟染红\n            bro->color_ = Red;\n            if (parent->color_ == Red) {\n                parent->color_ = Black;\n                // 调整完毕\n            } else {\n                // 回溯父节点\n                fixBeforeRemove(parent);\n            }\n        } else {\n            // 情况1/2\n            if (bro->right_->color_ != Red) {\n                // 情况2：黑兄弟有一个靠内红孩子，靠外是黑孩子\n                // 交换兄孩颜色\n                bro->color_ = Red;\n                bro->left_->color_ = Black;\n                rightRotate(bro);\n                bro = parent->right_;   // 更新兄弟指针\n            }\n            // 情况1：黑兄弟有一个靠外红孩子\n            bro->right_->color_ = bro->color_;\n            bro->color_ = parent->color_;\n            parent->color_ = Black;\n            leftRotate(parent);\n            // 调整完毕\n        }\n    } else {\n        Node* bro = parent->left_;\n        // 兄弟在左\n        // 情况4：兄弟为红。情况4处理完成后变成黑兄弟的情况。\n        // 黑节点必定存在兄弟，不用判定兄弟是否为空\n        if (bro->color_ == Red) {\n            // 交换兄父颜色\n            parent->color_ = Red;\n            bro->color_ = Black;\n            rightRotate(parent);\n            // 更新兄弟指针，旋转后parent指针没有动，bro指针变成祖父节点\n            bro = parent->left_;\n        }\n        // 情况3：黑兄弟且两个黑孩子。\n        // 黑兄弟有可能有两个黑孩子或没有孩子（两个nullptr）\n        if (isBlack(bro->left_) && isBlack(bro->right_)) {\n            // 兄弟染红\n            bro->color_ = Red;\n            if (parent->color_ == Red) {\n                parent->color_ = Black;\n                // 调整完毕\n            } else {\n                // 回溯父节点\n                fixBeforeRemove(parent);\n            }\n        } else {\n            // 情况1/2\n            if (bro->left_->color_ != Red) {\n                // 情况2：黑兄弟有一个靠内红孩子，靠外是黑孩子\n                // 交换兄孩颜色\n                bro->color_ = Red;\n                bro->right_->color_ = Black;\n                leftRotate(bro);\n                bro = parent->left_;   // 更新兄弟指针\n            }\n            // 情况1：黑兄弟有一个靠外红孩子\n            bro->left_->color_ = bro->color_;\n            bro->color_ = parent->color_;\n            parent->color_ = Black;\n            rightRotate(parent);\n            // 调整完毕\n        }\n    }\n}\n```\n:::\n","cover":"https://pic.akorin.icu/20250904212252303.webp","date":"2025-09-03 15:40:41"},{"title":"通信原理简记","tags":["笔记","通信原理"],"categories":["笔记"],"author":"akorin","excerpt":"\n记录通信原理的一些知识，重点记录数字通信系统\n\n","link":"/posts/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86","content":"\n记录通信原理的一些知识，重点记录数字通信系统\n\n<!-- more -->\n# 通信原理简记\n----\n\n## 0.预备知识\n### 0.1 分贝的定义\n\n$$\ndB=\\boldsymbol{10}\\log_{10}x\n$$\n分贝公式中前面的10容易忘记。此外需要牢记“3dB公式”：\n$$\n\\textcolor{red}{\\boldsymbol{3dB=10\\log_{10}2}}\n$$\n\n### 0.2 信噪比\n\n$$\n\\frac{信号功率}{噪声功率}=\\frac{P_s}{N}\n$$\n分贝表示：\n$$\n10\\log_{10}\\frac{信号功率}{噪声功率}=10\\log_{10}\\frac{P_s}{N}\n$$\n\n### 0.3 通信的基本概念\n\n- 通信：利用光电信号传输消息中所包含的信息\n- 通信的目的：在于传输含有信息的消息\n- 信息：消息的内涵（消息中所包含的有效内容）\n- 信息量：和消息内容的不确定有关\n- 消息：信息的物理表现形式。有连续信息（温度、语音）和离散信息（符号文字、计算机数据）\n- 信号：消息的传输载体。比如消息携载在电信号的某个参量（幅度、频率、相位）区别模拟信号和数字信号的关键在于携载信息的信号参量取值是连续的还是离散的\n- 调制信号：调制信号是指需要传输的原始信息信号。它通常是低频信号，也称为基带信号\n- 载波信号：载波是一个高频的正弦波信号，用于承载调制信号。载波的频率通常远高于调制信号的频率。调制时一般都是利用调制信号控制载波信号编程已调信号来传输\n- 已调信号：经调制后的高频载波，也可以叫做频带信号\n- 解调：从已调信号中提取出调制信号的过程，是调制的逆过程，也可以叫做检波\n\n### 0.4 通信系统的模型\n\n#### 0.4.1 一般通信系统\n\n![image.png](https://www.helloimg.com/i/2025/01/28/6797bbeec3f02.png)\n\n- 信源：将消息转化为电信号\n- 发送设备：产生适合在信道中传输的信号（调制）\n- 信道：传输信号的媒介\n- 接收设备：将收到的信号恢复成原始的信号（解调）\n- 信宿（受信者）：将信号转化为原始的消息（如扬声器）\n\n#### 0.4.2 模拟通信系统\n\n![image-2.png](https://www.helloimg.com/i/2025/01/28/6797bbeee4f5a.png)\n\n- 模拟信息源：将模拟消息转化为电信号（基带信号）\n- 调制器：将基带信号转化为带通信号（已调信号）\n- 信道：传输信号的媒介\n- 解调器：将带通信号解调为原始的基带信号\n- 信宿（受信者）：将原始电信号转化为模拟消息\n\n#### 0.4.3 数字通信系统\n\n![image-1.png](https://www.helloimg.com/i/2025/01/28/6797bbeed25fb.png)\n\n- 信源编码：模/数转换，将模拟信号转换为数字信号。将转化的数字信号进行压缩处理，减小冗余，提高信息传输的有效性。\n- 信源译码：信源编码的逆过程。\n- 信道编码：提高信息传输的可靠性，发现或纠正通信过程中产生的误码。信道编码通常需要在信息组中附加特定的码元，称为监督码，利用信息码和监督码的某种代数结构，检测或纠正错误。\n- 数字调制：产生适合在信道中传输的数字已调信号。\n\n### 0.5 通信系统分类\n\n- 按通信业务分类：电报通信系统、电话通信系统……\n- **按调制方式分类**：基带传输系统、带通传输系统（频带传输系统）\n- **按信号特征分类**：模拟通信系统、数字通信系统\n- **按传输媒介分类**：有线通信系统、无线通信系统\n- 按工作波段分类：长波通信、中波通信、短波通信\n- **按信号复用方式分类**：频分复用、时分复用\n\n### 0.6 通信方式\n\n- 单工通信：消息只能单方向传输的工作方式\n- 半双工通信：通信双方都能收发消息，但不能同时收发\n- 全双工通信：通信双方可同时进行收发消息的工作方式\n\n### 0.7 主要的性能指标\n\n- **有效性**：速度\n- **可靠性**：质量\n\n> 模拟系统的度量：\n>\n> - 有效性：有效传输频带宽度\n> - 可靠性：接收端最终输出信噪比\n\n> 数字系统的度量：\n>\n> - 有效性：传输速率和频带利用率\n> - 可靠性：差错率\n\n#### 0.7.1 数字通信系统传有效性\n\n- 码元传输速率R<sub>BN</sub>：定义为单位时间传输码元的数目，单位为波特(Baud)，简称为B（码元/秒，符号/秒）\n\n$$\nR_{BN} = \\frac{1}{T}\n$$\n其中T为码元的持续时间(s)\n\n- 信息传输速率R<sub>b</sub>：定义为单位时间传输的平均信息量或比特数，单位为比特/秒，记为b/s或bps。意味着无论码元是什么进制的最后的结果都要化成**二进制**\n- 不同进制码元速率和二进制码元速率的转换关系：\n\n$$\nR_B = R_{BN} \\times \\log_2N\n$$\n其中N为码元的进制数\n\n- 码元速率和信息速率的关系：\n\n$$\nR_b = R_{BN} \\times H\n$$\n其中H为信息熵（算术平均信息量，这里不过多赘述）\n\n- 频带利用率：定义为单位带宽(1Hz)内的传输速率\n\n$$\n\\eta=\\frac{R_{BN}}{B}\\space\\space\\space\\space\\space\\space\\space\\space(B/Hz)\n$$\n或\n$$\n\\eta=\\frac{R_b}{B}\n\\space\\space\\space\\space\\space\\space\\space\\space(b/s\\cdot{Hz})\n$$\n\n#### 0.7.2 数字通信系统可靠性\n\n- 误码率：\n\n$$\nP_e = \\frac{错误码元数}{传输总码元数}\n$$\n\n- 误信率：\n\n$$\nP_b = \\frac{错误比特数}{传输总比特数}\n$$\n在二进制中有:\n$$\nP_b = P_e\n$$\n\n### 0.8 噪声\n\n噪声是指在接收机中出现的任何不需要的电压或电流信号。噪声会引起模拟信号的失真，或数字信号的误码，**降低了通信系统的可靠性**\n\n#### 0.8.1 噪声的分类\n>\n> 按照噪声对信号的作用方式：\n>\n> - 加性噪声：叠加在信号上，大多数噪声都是加性噪声\n> - 乘性噪声：主要来自信道对信号的影响，当信道特性不理想时，需要通过对信道特性的补偿（均衡）去改善\n\n> 按照噪声的性质：\n>\n> - 脉冲噪声\n> - 单频噪声\n> - 起伏噪声：影响通信系统可靠性的主要因素\n\n#### 0.8.2 白噪声\n\n- 定义：功率谱密度为常数的噪声\n- 特性：统计特性服从高斯分布（一维高斯分布又称为正态分布），且均值为0。功率谱密度在很宽的范围内为常数，近似为白噪声。因此**起伏噪声**又称为**白噪声**\n\n## 1.通信信号分析\n\n### 1.1确知信号分析方法\n\n#### 1.1.1通信信号的分类方法\n\n- 模拟信号和数字信号：信号再时间和幅度上连续或离散的特点分类\n- 确知信号和随机信号：从信号是否可以用明确的表达式表示出来分类，确知信号又可以分为周期信号和非周期信号\n- 有用信号和噪声信号：从信号中是否携带有用信息来分类\n\n> 有意义的通信信号应具有随机性，但是其中也会存在确知信号\n\n#### 1.1.2 信号的基本分析方法\n\n- 时域分析法：直观体现信号波形\n- 频域分析法：利用傅里叶变换进行信号分析，揭示信号内在的频率特性\n\n#### 1.1.3 能量信号与功率信号\n\n- 能量信号：能量数值有界，功率为0\n- 功率信号：能量数值无界，功率数值有界\n\n> **各类信号之间的关系**\n>\n> **随机信号**与**确知的周期信号**是功率信号\n>\n> **确知的非周期信号**既可能是功率信号，也可能是能量信号\n>\n> 功率信号可以是**确知的周期、非周期或随机信号**，能量信号一定是**非周期信号**。在后面的分析中一般默认功率信号是确知周期信号\n\n#### 1.1.4 功率信号的频谱\n\n功率信号默认为确知周期信号，则分析功率信号时分析的是确知周期信号。周期信号频谱的三个特点：\n- 离散型\n- 谐波性\n- 收敛性：信号的能量主要集中在低频分两中（第一零点带宽）\n\n> **信号的频带宽度定义为：**\n>\n> 从零频率开始到需保留的最高频率分量之间的频率范围\n> ![QQ20250129-181523.png](https://www.helloimg.com/i/2025/01/29/6799febba7da3.png)\n> <center style=\"font-size:12px;color:#C0C0C0;text-decoration:underline\">第一零点带宽</center>\n\n#### 1.1.5 能量信号的频谱密度\n\n能量信号通常是非周期信号，非周期信号不能够直接用傅里叶级数表示，一般利用傅里叶变换得到频谱密度来表示。能量信号的频谱密度的特点：\n- 连续型\n- 单位是幅度/频率\n- 每个频率点上的信号幅度是无穷小的\n\n#### 1.1.6 帕斯瓦尔定理\n> **帕斯瓦尔定理**\n>\n> 对于能量信号，在时域中计算的信号总能量等于频域中计算的信号总能量\n> $$\n\\int ^\\infty _{-\\infty}f^2(t)dt=\\frac{1}{2\\pi}\\int ^\\infty _{-\\infty}|F(\\omega)|^2dw\n$$\n>\n> 对于周期性功率信号有\n> $$\nP=\\frac{1}{T}\\int ^\\frac{T}{2} _{-\\frac{T}{2}}f^2(t)dt=\\sum _{n=-\\infty} ^{n=\\infty}|F_n|^2\n> $$\n> 其中F<sub>n</sub>为周期信号的傅里叶频谱系数\n\n#### 1.1.7 希尔伯特变换\n> 希尔伯特变换在通信领域中有广泛的作用，它是信号分析与处理的重要工具\n$$\n\\^{f}(t)=H[f(t)]=\\int ^\\infty _{-\\infty} \\frac{f(\\tau)}{\\pi(t-\\tau)}d\\tau\n$$\n即\n$$\n\\^{f}(t)=H[f(t)]=f(t)\\ast\\frac{1}{\\pi t}\n$$\n在频域中为两个函数的傅里叶变换相乘。后者的傅里叶变换为$-jsgn(f)$，对正频率产生$-\\frac{\\pi}{2}$的相移，对负频率产生$\\frac{\\pi}{2}$的相移\n\n> 因此，希尔伯特变换又称为$\\frac{\\pi}{2}$移相器\n\n### 1.2 随机信号分析方法\n\n#### 1.2.1 随机过程\n\n随机过程可看成是一个由全部可能的实现构成的总体，每个实现都是一个确定的时间函数\n\n> **随机过程的定义**\n>\n> 随机过程是**样本函数的全体**，用$\\xi(t)$表示\n>\n> $\\xi(t)={x_1(t),x_2(t), \\ldots ,x_n(t), \\ldots }$\n> 其中$x_i(t)$是样本函数\n>\n> 或随机过程是依赖于时间参量t变化的**随机变量的全体**\n>\n> $\\xi(t)={X(t_1),X(t_2), \\ldots ,X(t_n), \\ldots }$\n> 其中$X(t_i)$是随机变量\n\n#### 1.2.2 随机过程的数字特征\n\n- 数学期望：随机过程的数学期望是时间t的函数$a^2(t)$可以看成随机过程的**直流功率**\n- 方差：方差$\\sigma^2(t)$可看作随机过程的**交流功率**\n\n> **平均功率**\n>\n> $E[\\xi^2(t)]=a^2(t)+\\sigma^2(t)$\n\n- 自协方差函数B与自相关函数R：当$B(t_1,t_2)=0$时，表示$X(t_1)$与$X(t_2)$**线性不相关**\n\n> 自协方差函数$B(t_1,t_2)$\n>\n> $B(t_1,t_2)=E[\\xi(t_1)\\xi(t_2)]-a(t_1)a(t_2)$\n\n> 自相关函数$R(t_1,t_2)$\n>\n> $R(t_1,t_2)=E[\\xi(t_1)\\xi(t_2)]$\n\n#### 1.2.3 平稳随机过程\n\n> **平稳随机过程**\n>\n> 平稳随机过程指固定时间和位置的概率分布与所有时间和位置的概率分布相同的随机过程。随机过程的平稳性分为严格平稳和广义平稳\n>\n> - 严格平稳：任何n维分布函数或概率函数密度**与时间起点无关**。严格平稳又称为严平稳或**狭义平稳**\n>\n> - 广义平稳：均值与t无关，且为常数，同时自相关函数$R(\\tau)$只与时间间隔$\\tau$有关\n>\n> 平稳随机过程一定满足广义平稳，故**平稳随机过程**的**自相关函数$R(\\tau)$和时间t无关**，只与**时间间隔**$\\tau$**有关**\n\n> **各态历经性**\n>\n> 平稳随机过程的一个样本函数在整个时间轴上的时间平均值可以用来代替其统计平均值\n\n> **自相关函数的性质**\n>\n> - $R(0)=E{\\xi^2(t)}=P$\n> - 是对偶函数\n> - $R(0)\\ge |R(\\tau)|$\n> - $R(\\infty)=a^2$\n> - $R(0)-R(\\infty)=\\sigma^2$\n>\n> 平均功率-直流功率=交流功率\n\n#### 1.2.4 高斯随机过程\n\n> **高斯过程**\n>\n> 高斯过程指任意维分布都服从高斯分布的随机过程\n\n> **高斯过程的性质**\n>\n> - 若高斯过程广义平稳，必将严格平稳\n> - 若高斯过程中的各随机变量之间是互不相关的，则必将统计独立\n\n#### 1.2.5 窄带高斯噪声\n\n> **窄带随机过程满足**\n>\n> 中心频率远小于带宽。窄带过程是一个包络和相位缓慢变化的正弦波\n\n> **白噪声的性质**\n>\n> - 白噪声的功率谱密度：$P_n(\\omega)=\\frac{n_0}{2}$\n> - 白噪声的自相关函数：$R(\\tau)=F^{-1}{P_n(\\omega)}=\\frac{n_0}{2}\\delta(\\tau)$\n\n## 2.模拟调制系统\n### 2.1 引言（模拟+数字）\n#### 2.1.1 调制的主要作用\n\n- 形成带通型信号频谱，使发送到呃频带信号的频谱匹配与信道的带同特性\n- 实现信道的多路复用\n\n::: tip 频分复用(FDM)\n\n将多个基带信号分别搬到不同的载频处，以实现信道的多路复用技术\n\n:::\n\n- 通过采用不同的调制方式可以兼顾通信的有效性和可靠性\n\n#### 2.1.2 调制方式\n\n- 连续波调制（用于雷达）、脉冲波调制\n- 模拟调制、数字调制（以调制信号的种类划分）\n\n### 2.2 幅度调制（模拟）\n\n> **幅度调制（线性调制）**\n>\n> 由调制信号去控制高频载波的**幅度**，使之随调制信号作线性变化的一种调制方式\n\n> **幅度调制的四种类型**\n>\n> - 调幅(AM)\n> - 双边带(DSB)\n> - 单边带(SSB)\n> - 残余边带(VSB)\n\n> **特点**\n>\n> - 已调信号的幅度随基带信号呈正比例变化\n> - 已调信号的频谱是基带信号频谱的**频谱搬移**\n\n### 2.3 AM调制\n\n设**调制信号**表达式为$m(t)=A_m\\cos\\omega_mt$\n\n**载波信号**表达式为$c(t)=A\\cos(\\omega_ct+\\varphi_0)$\n\n为了分析方便一般将$\\varphi_0$设为0，则AM信号的表达式：\n$$\ns_{AM}(t)=[A_0+m(t)]\\cos\\omega_ct\n$$\n\nAM调制器模型：\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/AMtiaozhi.png)\n\nAM调制器波形图：\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/AM波形图.png)\n\nAM调制器信号频谱原理：\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/amtiaozhipinpu.png)\n\n\n#### 2.3.1 AM信号功率\n\n设$\\overline{m(t)}=0$可推出\n\n$P_{AM}=\\frac{A_0^2}{2}+\\frac{\\overline{m^2(t)}}{2}=P_c+P_s$\n\n其中$P_c$为不携带信息的功率，$P_s$为携带信息的功率\n$$\n\\eta_{AM}=\\frac{P_s}{P_{AM}}=\\frac{\\overline{m^2(t)}/2}{[A_0^2+\\overline{m^2(t)}/2]}\n$$\n\n::: warning 注意\n\n当$|m(t)|_{max}=A_0$时，称为AM的临界调制或100%调制，此时$\\overline{m^2(t)}=\\frac{A_0^2}{2}$，$\\eta_{AM}=\\frac{1}{3}$\n:::\n\n#### 2.3.2 AM的包络检波\n\nAM的包络检波器将$\\cos\\omega_ct$滤去，得到$s_d(t)=A_0+m(t)$，再将直流信号$A_0$滤去后即可得到原始调制信号$m(t)$\n\n检波中无需额外提供或提取载波，电路简单\n\n包络检波法是中、小型幅度调制系统的首选解调方法\n\n\n### 2.4 DSB调制\n\n> DSB调制模型\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/dsbtiaozhi.png)\n\n**载波信号**表达式为$S_{DSB}=m(t)\\cos\\omega_ct$\n\n其中$\\overline{m(t)}=0$\n\n> DSB调制波形\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/DSB调制波形.png)\n\n> DSB调制原理\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/DSByuanli.png)\n\nDSB信号节省了载波功率，其调制效率可达100%。DSB信号两个边带中的**任意一个**都包含了调制信号的所有频谱成分\n\n::: warning 注意\n\n对比AM调制的波形，少了两个冲激的波形\n\n:::\n\n> 综上可知DSB的带宽为\n\n$$\nB_{DSB}=2f_H\n$$\n\n#### 2.4.1 DSB解调\n\n使用相干解调器（同步检测）\n\n::: tip 相干解调\n\n用同频同相的载波信号乘以调制信号解调出基带信号的方法\n\n:::\n\n> 相干解调器模型\n> ![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/DSB相干解调其模型.png)\n\n其中$s_m(t)$是调制信号（已调信号），且\n$$\n\ns_m(t)=m(t)\\cos\\omega_ct \\\\\ns_p(t)=m(t)\\cos\\omega_ct\\cos\\omega_ct\n\n$$\n\n经过低通滤波器LPF后可得\n$$\n\ns_d(t)=\\frac{1}{2}m(t)\n\n$$\n\n### 2.5 SSB调制\n\nSSB调制可由两种方式得来：\n- 滤波法：从DSB信号中滤波得到\n- 移相法\n\n#### 2.5.1 滤波法SSB信号\n\n> 滤波法SSB调制模型\n> ![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/滤波法SSB调制模型.png)\n\n而此时SSB有两种调制方式\n- 上边带调制USB：滤除下边带，保留上边带\n- 下边带调制LSB：滤除上边带，保留下边带\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/什么是SSB.png)\n\n此时可得通式：\n$$\ns_{SSB}(t)=\\frac{1}{2}A_m\\cos\\omega_mt\\cos\\omega_ct\\mp\\frac{1}{2}\\sin\\omega_mt\\sin\\omega_ct\n$$\n其中减号对应USB，加号对应LSB\n\n当利用滤波法调制SSB波形时，若$H(\\omega)$为**理想高通**特性，则得到上边带信号（USB）\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/滤波法SSB调制波形.png)\n\n::: warning 注意\n\nSSB的频谱是滤去其中一个边带后的结果\n\n:::\n\n$$\nS_{SSB}(\\omega)=S_{DSB}(\\omega)\\cdot{H(\\omega)}\n$$\n\n\n\n> 则此时SSB信号的带宽为\n\n$$\nB_{SSB}=f_H\n$$\n\n#### 2.5.2 相移法SSB信号\n\n在滤波法实现SSB的方法中，理想边带滤波器$H(\\omega)$很难实现，因此使用相移法是一个实际应用SSB调制的方法\n\n> 移相法SSB模型\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/移相法SSB调制器.png)\n\n其中方框$-\\frac{\\pi}{2}$为希尔伯特移相变换\n\n> 最后得到SSB的表达式\n$$\ns_{SSB}(t)=\\frac{1}{2}m(t)\\cos\\omega_ct\\mp\\frac{1}{2}\\^m(t)\\sin\\omega_ct\n$$\n即为\n$$\ns_{SSB}(t)=\\frac{1}{2}A_m\\cos\\omega_mt\\cos\\omega_ct\\mp\\frac{1}{2}\\sin\\omega_mt\\sin\\omega_ct\n$$\n\n::: warning 注意\n\n$m(t)=A_m\\cos\\omega_ct\\\\\\^m(t)=A_m\\sin\\omega_ct`$\n\n:::\n\n与前面滤波法SSB得到的结果一致\n\n#### 2.5.3 SSB信号的解调\n\n解调器结构同DSB一致\n> 相干解调器\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/DSB相干解调其模型.png)\n\n经过低通滤波器LPF后\n$$\ns_d(t)=\\frac{1}{4}m(t)\n$$\n\n### 2.6 VSB调制\n\nVSB调制是介于SSB与DSB调制之间的一种折衷方案，使用滤波法进行调制\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/VSB模型.png)\n\n> VSB调制模型\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/VSB调制器.png)\n\n其中残留边带滤波器$H(\\omega)$表示VSB滤波器的传输特性\n\n#### 2.6.1 VSB的解调\n\nVSB信号必须采用相干解调，为了分析方便，将载波幅度设为2\n\n> 相干解调模型\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/VSB相干解调.png)\n\n则最后经过LPF可得\n$$\nS_d(\\omega)=\\frac{1}{2}M(\\omega)[H(\\omega+\\omega_c)+H(\\omega-\\omega_c)]\n$$\n\n::: danger 为了保证无失真恢复调制信号，必须满足\n\n$$\nH(\\omega+\\omega_c)+H(\\omega-\\omega_c)=C,|\\omega|\\le \\omega_H\n$$\n其中C为常数\n:::\n\n当残留边带滤波器传输特性$H(\\omega)$关于$\\omega_c$**互补对称（奇对称），相干解调时才能无失真地恢复调制信号**\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/VSB相干解调原理.png)\n\n此时VSB的带宽\n$$\nB_{VSB}\\approx B_{SSB}\\Leftrightarrow B_{VSB}=1.25B_{SSB}\n$$\n\nDSB、SSB、VSB之间带宽的比较\n$$\nB_{SSB}<B_{VSB}<B_{DSB}\n$$\n\n### 2.7 角度调制系统\n\n正弦载波的三个参量（幅度、频率、相位）都可以用来携带调制信号\n\n- 幅度调制：调制信号控制载波的幅度\n- 频率调制FM（调频）：用调制信号去控制载波频率；已调信号的瞬时角频偏正比于调制信号\n- 相位调制PM（调相）：用调制信号去控制载波相位；已调信号的瞬时相位偏移正比于调制信号\n\n角度调制信号的一般表达式为\n$$\ns_m(t)=A\\cos[\\omega_ct+\\varphi(t)]\n$$\n- A为载波的振幅，为常数\n- $[\\omega_ct+\\varphi(t)]$为瞬时相位\n- $\\varphi(t)$为相对与载波相位$\\omega_ct$的瞬时相位偏移\n- $d[\\omega_ct+\\varphi(t)]/dt$是瞬时角频率\n- $d\\varphi(t)/dt$为相对于载频$\\omega_c$的瞬时角频偏\n\nFM和PM统称为**角度调制**\nFM和PM的已调信号的频谱不仅有频谱搬移，且频谱的结构也会发送变化\n\n> 因此角度调制又称为非线性调制\n\n#### 2.7.1 概念\n\n设载波信号为：\n$$\ns(t)=A\\cos(\\omega_ct+\\varphi_0)\n$$\n调制信号为$m(t)$\n\n- FM信号：$s_{FM}(t)=A\\cos[\\omega_ct+K_f\\int^t_0m(\\tau)d\\tau]$，此时$\\varphi_0=[K_f\\int^t_0m(\\tau)d\\tau]$\n- PM信号：$s_{PM}(t)=A\\cos[\\omega_ct+K_pm(t)]$，此时$\\varphi_0=[K_pm(t)]$\n\n其中$K_f$和$K_p$分别是调频指数和调相指数\n\n对比两者可得知：将基带信号先积分再调相，等同于调频；将基带信号先微分再调频，等同于调相\n\n::: warning 关于“将基带信号先微分再调频，等同于调相”的理解\n\n如果我们将基带信号 m(t) 先微分，再进行频率调制，那么：\n\n$$\n \\frac{d}{dt} m(t) = m'(t)\n$$\n\n此时，频率调制的已调信号变为：\n\n$$\ns_{FM}(t) = A \\cos \\left( \\omega_c t + K_f \\int_0^t m'(\\tau) d\\tau \\right)\n$$\n\n由于积分和微分是互逆运算，因此：\n\n$$\n\\int_0^t m'(\\tau) d\\tau = m(t)\n$$\n\n所以，频率调制的已调信号可以表示为：\n\n$$\ns_{FM}(t) = A \\cos \\left( \\omega_c t + K_f m(t) \\right)\n$$\n\n这与相位调制的已调信号形式相同，只是调制指数不同。因此，将基带信号先微分再进行频率调制，等同于相位调制。只不过此时$K_f$相当于调相灵敏度\n\n:::\n\n#### 2.7.2 单音调制时的FM与PM波形\n\n:::tip 单音\n\n单音指调制信号为单一频率的正弦波，即\n\n$$\n\nm(t)=A_m\\cos\\omega_mt=Am\\cos2\\pi f_mt\n\n$$\n\n:::\n\n- 调频信号：$s_{FM}(t)=A\\cos(\\omega_ct+m_f\\sin\\omega_mt)$\n- 调频信号：$s_{PM}(t)=A\\cos(\\omega_ct+m_p\\cos\\omega_mt)$\n\n其中\n\n- 调频指数：$m_f=\\frac{K_fA_m}{\\omega_c}$（$\\frac{1}{\\omega_c}$是从积分来的），它也是最大的相位偏移量\n- 调相指数：$m_p=K_pA_m$，它也是最大的相位偏移量\n\n其中$K_fA_m$是最大的角频率偏移量，表示为$\\triangle\\omega$，则$m_f$与$\\triangle f$的关系为\n$$\n\nm_f=\\frac{K_fA_m}{\\omega_m}=\\frac{\\triangle\\omega}{\\omega_m}=\\frac{\\triangle f}{f_m}\n\n$$\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/PMFM图像.png)\n\n由图可知，FM与PM的表现形式相同，都是已调信号频率的稀疏变化，区别在于PM是相位偏移随调制信号m(t)线性变化，FM是频率偏移随m(t)线性变化。若预先不知道调制信号m(t)的具体形式，则无法判断已调信号是PM信号还是FM信号\n\n实际运用上FM较多，主要讨论FM信号\n\n> FM信号的带宽（卡森公式/调频信号带宽公式）：\n$$\n\nB_{FM}=2(m_f+1)f_m=2(\\triangle f+f_m)\n\\\\f_m=\\frac{\\omega_m}{2\\pi}\n\n$$\n\nFM的频谱理论值无穷大，但可根据调频指数$m_f$分为宽带调频和窄带调频\n\n- $m_f\\gg1$时，为宽带调频，此时\n\n$$\n\nB_{FM}\\approx2m_ff_m=2m_f\\frac{\\omega_m}{2\\pi}=2\\frac{\\triangle\\omega}{2\\pi}=2\\triangle f=2\\frac{K_fA_m}{2\\pi}\n\n$$\n\n只与信号强度有关，与调制信号频率无关\n\n- $m_f\\ll 1$时，为窄带调频，此时\n\n$$\n\nB_{FM}\\approx2f_m=2\\frac{\\omega_m}{2\\pi}\n\n$$\n\n与AM信号带宽相同\n\n> FM与PM之间的关系\n> ![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/FNPM关系.png)\n\n#### 2.7.3 各种模拟系统输出信噪比的比较\n\n在信道条件相同下，若解调器输入端的信号功率相同，设$\\overline{m^2}(t)=\\frac{A^2}{2}$\n$$\n\n(\\frac{S_0}{N_0})_{AM}=\\frac{1}{3}\\frac{S_i}{N_0B_b} \\\\\n(\\frac{S_0}{N_0})_{DSB}=\\frac{S_i}{N_0B_b} \\\\\n(\\frac{S_0}{N_0})_{SSB}=\\frac{S_i}{N_0B_b} \\\\\n(\\frac{S_0}{N_0})_{FM}=\\frac{3}{2}m^2_f\\frac{S_i}{N_0B_b} \\\\\n\n\n$$\n\n#### 2.8 信道的频分复用\n\n:::tip 信道复用\n\n将物理信道按照不同的属性参量（如时间、频率等）划分成若干个子频带（或称子信道），供多路信号同时使用\n\n:::\n\n- 频分复用(FDM: Frequency Division Multiplexing)\n- 时分复用(TDM: Time Division Multiplexing)\n- 码分复用(CDM: Code Division Multiplexing)\n- 正交频分复用(OFDM: Orthogonal frequency Division Multiplexing)\n\n信道复用时为了提高信道的利用率\n\n\n::: tip 频分复用(FDM: Frequency Division Multiplexing)\n\n将多个基带信号分别搬到不同的载频处，以实现信道的多路复用技术\n\n:::\n\n> **特点：** FDM是模拟通信中的一种主要服用方式，信道复用率高，复用路数多，分接方便\n\n::: tip 时分复用 (TDM: Time Division Multiplexing)\n\n时分复用是一种将多个信号在时间上进行分割，并在同一信道上依次传输的技术。每个信号在不同的时间片段内占用信道，从而实现多路信号的传输\n\n:::\n\n\n#### 2.8.1 OFDM与FDM的频谱效率比较\n\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/FDMOFDM的比较.png)\n\n#### 2.9 各类模拟调制系统性能比较\n\n| 调制方式 | 传输带宽      | 调制制度增益               | 主要应用                 |\n| -------- | ------------- | -------------------------- | ------------------------ |\n| AM       | $2f_m$        | 小于1，近似为$\\frac{2}{3}$ | 中波和短波调幅广播       |\n| DSB      | $2f_m$        | 2                          | 彩色电视系统（色差信号） |\n| SSB      | $f_m$         | 1                          | 短波无线电广播载波通信   |\n| VSB      | 略大于$f_m$   | 约等于1                    | 电视广播（图像信号）     |\n| FM       | $2(m_f+1)f_m$ | $3m^2_f(m_f+1)$            | 小型电台、电视广播、卫星通话 |\n\n- 有效性：（优）→（劣）SSB、VSB、AM(DSB)、FM\n- 可靠性：（优）→（劣）WBFM、SSB(DSB、VSB)、AM\n\n#### 2.10 载波同步\n\n:::tip 载波同步\n\n载波同步是通信系统中一个关键的过程，它确保接收端能够正确地恢复出发送端的载波信号。载波同步的主要目的是在接收端生成一个与发送端载波信号相同频率和相位的本地载波信号，以便进行相干解调。\n\n在**相干解调器**中，需要用载波同步器来提取本地相干载波，用于已调信号的解调，相干载波应与调制载波同频同相。\n\n:::\n\n载波同步分为直接发和插入导频法两类方法\n\n- 直接法：直接从接收信号中提取载波信号\n- 插入导频法：在已调信号中加入额外的载频分量（导频分量）\n\n#### 2.10.1 载波同步器性能指标\n\n- 同步建立时间：从开始接收到信号（或从系统失步状态）至提取出稳定的载频所需要的时间\n  > 同步建立时间**越短越好**\n\n- 同步保持时间：从开始失去输入信号到市区载频同步的时间\n  > 同步保持时间**越长越好**。当同步保持时间唱，则在输入信号短暂丢失时，保持连续提供本地载频，不需要重新建立同步\n\n- 相位误差：由电路常数引起，或由噪声引起\n  > 相位误差降低了输出信号功率，对噪声功率没有影响，结果是会引起输出信噪比的下降\n\n## 3.数字信号的基带传输\n### 3.1 数字基带信号波形与频谱\n#### 3.1.1 基本的数字基带信号波形\n\n> 单极性信号波形：\n- +A电平 <--> 码元\"1\"\n- 0电平  <--> 码元\"0\"\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/单极性波形.png)\n> 双极性信号波形：\n- +A电平 <--> 码元\"1\"\n- -A电平 <--> 码元\"0\"\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/双极性波形.png)\n> 差分信号极性波形：\n- 相邻码元电平改变 <--> 码元\"1\"\n- 相邻码元电平不变  <--> 码元\"0\"\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/差分波形.png)\n> 多电平信号波形：\n- 一个M进制码元的信号波形，含有M种信号电平，下图为四电平波形\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/四电平波形.png)\n\n> 由上图观察可得到：归零和不归零波形的占空比不同\n\n\n$占空比=\\frac{脉冲宽度}{码元宽度}=\\frac{\\tau}{T_B} \\quad \\tau$：主瓣带宽（第一零点带宽）\n\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/20250222160002091.png、)\n\n- $\\tau=T_B$：不归零码\n- $\\tau=\\frac{T_B}{2}$：半占空归零码\n\n\n:::tip 归零码\n\n归零码（Return-to-Zero, RZ）是一种数字信号编码方式。在归零码中，每个码元周期内信号都会返回到零电平，即无论码元是“1”还是“0”，信号在每个码元周期的中间都会回到零电平。如上图中b、d\n\n:::\n\n#### 3.1.2 基带信号的频谱\n\n基带信号是**随机**脉冲序列，没有确定的频谱函数，只能用平均功率谱来描述它的频谱特性\n\n基带信号的频谱包含：基带信号的**主瓣宽度**、**直流分量**、**位定时**\n\n### 3.2 基带传输的常用码型\n\n> 为了适应信道的传输，传输码型必须具备以下**基本特性**：\n> - 无直流、很少的低频分量\n> - 含有码元定时信息\n> - 主瓣宽度窄\n> - 适用于各种信源的统计特性\n> - 具有一定的纠错能力\n> - 有利于减少误码扩散\n\n#### 3.2.1 二元码\n\n二元码即二电平码\n\n##### 3.2.1.1 双相(BiPhase)码\n\n又称为**曼彻斯特**(Manchester)码，是用具有不同相位的二进制编码取表示消息\n\n| 消息码   | 1   | 0   |\n| -------- | --- | --- |\n| 信号波形 | ![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/20250222160825997.png) |![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/20250222160847289.png)|\n\n> 特点：\n> - 码元中间存在电平的跳变，能够提供足够的定时分量\n> - 每个码元正负电平各占一半没有直流分量\n> - 编码过程相对简单，可以用单极性不归零码金额系统定时信号的模2加产生\n> - 主要用于局域网\n\n##### 3.2.1.2 传号反转码(CMI码)\n\n| 消息码           | 1                | 0   |\n| ---------------- | ---------------- | --- |\n| 信号传输表示方法 | 交替用\"11\"和\"00\" | \"01\" |\n\n> 特点：\n> - 无直流分量\n> - 有较多的电平跃变，含有丰富的定时信息\n> - 具有一定的检错能力，不可能出现\"10\"的组合，也不会出现连续的\"11\"或者\"00\"\n> - 被CCITT推荐为PCM四次群的接口码型\n\n##### 3.2.1.3 米勒码(Miller码)\n\n| 消息码           | 1                | 0    |\n| ---------------- | ---------------- | ---- |\n| 信号传输表示方法 | 交替用\"10\"和\"01\" | 交替用\"11\"和\"00\" |\n\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/20250222161823266.png)\n\n##### 3.2.1.4 nBmB码\n\nn位二进制-->m位二进制，通常m=n+1\n\n新的码组有 $2^m$ 种可能的组合，从中选择一部分有利的码组作为**许用码组**，其余为**禁用码组**，这样就有一定的检错能力\n\n主要用于光线数字传输系统中\n\n#### 3.2.2 三元码\n\n三元码的幅度取值有：$+1、0、-1$\n\n##### 3.2.2.1 传号交替反转码(AMI)码\n\n| 消息码           | 1                | 0                |\n| ---------------- | ---------------- | ---------------- |\n| 信号传输表示方法 | 交替用\"+1\"和\"-1\" | 0 |\n\n> 特点：\n> - 无直流分量，只有很小的低频成分\n> - 编译码简单\n> - 主要缺点是可能出现长连0串，可能导致定时信号提取困难\n\n##### 3.2.2.2 三阶高密度双极性码($HDB_3$码)\n\n$HDB_3$ 就是AMI码的改进码\n\n> 编码规则：\n> - 在AMI码的基础上，当连0串少于4个时，此时的AMI码就是 $HDB_3$ 码\n> - 当出现4个或4个以上连0串时，则将每4连0串的第4个0变换成与其前一非0符号**同极性**的符号，这个符号就是**破坏符号V**，+V -V交替出现\n> - 当相邻4连0段之间有奇数个非0符号时，后一个4连0用取代节\"000V\"代替;当有偶数个非0符号时，后一个4连0用取代节\"B00V\"代替；B符号的机型与前一非零符号**相反**，B符号是用来确保破坏符号的规则能够满足\n\n![](https://pic.akorin.icu/20250225160900679.png)\n\n> 特点：\n> - $HDB_3$ 编码较复杂，译码较简单\n> - 每一个破坏符号V总是与前一非0符号**同极性**\n> 从接受符号序列中很容易找到破坏点V，也易判断V及前面的3个符号必是连0符号，从而恢复4个连0码\n\n##### 3.2.2.3 4B/3T\n\n上述的两种码型都是1B/1T，即将1个二进制符号用三进制符号代替，4B/3T时1B/1T的改进型，可提高频带利用率，适用于较高速率的数据传输系统\n\n\n### 3.3 无码间干扰的基带传输\n\n#### 3.3.1 基带传输系统的基本结构\n![](https://pic.akorin.icu/20250225162142154.png)\n\n- $d(t)$：输入基带信号\n- $m(t)$：无干扰时的基带传输信号\n- $r'(t)$：乘性干扰下的输出信号\n- $r(t)$：乘性干扰和加性噪声影响下的输出信号\n- $d'(t)$：再生的输出信号\n\n\n:::tip 码间串扰\n\n由于干扰的影响，造成码元间的互相重叠，从而影响正确判决\n\n:::\n\n\n> 无噪声系统与有噪声系统\n>![](https://pic.akorin.icu/20250225162750657.png)\n\n> 无码间干扰的时域条件\n\n$$\nh[(k-n)T_B]=\n\\begin{cases}\n    A\\quad n=k\\\\\n    0\\quad n\\neq k\n\\end{cases}\n$$\n\n> 无码间串扰的频域条件\n\n$$\n\n\\sum\\limits_iH(f+\\frac{i}{T_B})=T_B \\quad or \\quad 常数 \\quad |f| \\le \\frac{1}{2T_B}\n\n$$\n\n:::warning\n\n频域条件又称为**奈奎斯特第一准则**\n\n:::\n\n一个带宽为 $f_N$ 的理想低通系统，它的最高无码间干扰速率为 $2f_N$，也称为 **奈奎斯特速率**，反过来说：\n\n若要实现速率为 $R_B$ 的无码间干扰传输，需要的理想低通系统最小带宽为 $\\frac{R_B}{2}$，称为**奈奎斯特带宽**，此时其频带利用率（极限频带利用率）为 $\\eta=2 \\quad Bd/Hz$\n\n\n#### 3.3.2 眼图\n\n对于一个实际的传输系统，码间干扰不可能完全避免\n\n计算误码率和性能非常困难，甚至无法实现\n\n> **眼图**：\n> 用示波器观察数字基带系统接收信号，所得到的图像，形式很像人的眼睛\n> 通过眼图可以观察处码间干扰和噪声的影响，估计系统性能的优劣程度\n> ![](https://pic.akorin.icu/20250225165351994.png)\n\n> **眼图模型**：\n> ![](https://pic.akorin.icu/20250225165438521.png)\n\n> **奈奎斯特第二定律**：\n\n> 也称为奈奎斯特第二条件，是在通信系统中用于减少或消除码间干扰（ISI）的一个重要准则。为了避免码间干扰，传输系统的频率响应 ( H(f) ) 应该满足以下条件：\n\n$$\n\\sum_{i=-\\infty}^{\\infty} H(f - i/T_B) = T_B\n$$\n\n其中，$T_B$ 是码元周期，$H(f)$ 是系统的频率响应。\n\n\n### 3.4 位同步\n\n> **位同步目的**：\n> 确定接受码元起始时刻，以保证正确检测和判决所接受的码元\n\n> **码元同步方法**：\n> - 外同步法：利用辅助信息同步的方法需要在传输信号中另外加入包含码元定时信息的导频信号\n> - 自同步法：不需要辅助同步信息，直接从接收信号序列中提取出码元定时信息\n\n### 3.5 均衡技术\n\n> 均衡器的概念：\n> 在数字基带系统输出端加入一种可调（或不可调）滤波器，减小码间干扰的影响\n\n> 均衡器的分类：\n> - 时域均衡器(TDE)\n> - 频域均衡器(FDE)\n\n\n## 4.模拟信号数字化 :star::star::star::star::star:\n\n主要针对PCM电话通信系统\n\n### 4.1 脉冲编码调制PCM\n#### 4.1.1 PCM系统模型\n\n**PCM(Pulse Code modulation)** 即脉冲编码调制，是一种将时间连续、取值连续的模拟信号变换成时间离散、抽样值离散的数字信号的过程\n\n![](https://pic.akorin.icu/20250225172218086.png)\n\n如上图PCM系统包括**编码器**和**译码器**两部分\n\n- 抽样：将模拟信号由时间上连续的信号编程时间上离散的信号，抽样必须遵循抽样定理\n- 量化：将抽样得到的幅度瞬时值离散化的过程，将连续的瞬时抽样值近似为离散的电平值\n- 编码：用二进制码组表示每一个量化电平。若编码后二进制码组的位数用N表示，则可以表示的量化电平数为 $2^N$ 个\n\n#### 4.1.2 PCM术语说明\n\n- 对脉冲**幅度**进行调制：PAM(Pulse-Amplitude Modulation)\n- 对脉冲**宽度**进行调制：PDM(Pulse-Duration Modulation)\n- 对脉冲**相位**进行调制：PPM(Pulse-Postion Modulation)\n\n上述都是周期性的矩形脉冲序列\n\n#### 4.1.3 PCM系统的奈奎斯特带宽\n\n设模拟信号抽样频率为 $f_s$ ，每个样值编码位数为N，则单路的PCM信号的码元速率为 $R_B=Nf_s$\n\nk路复用则PCM系统的码元速率为 $kNf_s$\n\n在无码间串扰下，[奈奎斯特带宽](https://akorin.icu/posts/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86#_3-3-1-%E5%9F%BA%E5%B8%A6%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84)指**理想低通系统**所需的最小带宽，为 $\\frac{kNf_s}{2}$\n\n当采用**升余弦系统**传输时，所需带宽为 $kNf_s$\n\n### 4.2 模拟信号的抽样\n#### 4.2.1 抽样定理\n\n> 抽样信号：周期性的冲激序列 $\\delta_T(t)$\n\n设模拟信号频率范围为 $f_L~f_H$ ，带宽为 $B=f_H-f_L$\n\n- 低通信号： $B>f_L$\n- 带通信号： $B\\le f_L$\n\n#### 4.2.2低通信号抽样定理\n\n对于频带限制在 $0~f_H$ 的低通信号 $m(t)$ ，若以频率 $f_s\\ge 2f_H$ **抽取瞬时样值**，则可无失真恢复原模拟信号\n\n![](https://pic.akorin.icu/20250228095014020.png)\n\n#### 4.2.3 模拟基带信号的恢复\n\n使用截止频率为 $f_H$ 的低通滤波器\n\n滤波器的频域系统函数为：\n$$\nH(f)=\n\\begin{cases} 1, & |f|\\le f_H  \\\\ 0, & |f|>f_H \\end{cases}\n$$\n\n其时域的表达式为\n\n$$\nh(t)=F^{-1}[H(\\omega)]=\\frac{\\omega_H}{\\pi}Sa(\\omega_Ht)\n$$\n\n输出信号\n\n$$\nm_0(t)=F^{-1}[M_s(f)\\cdot H(f)]=m_s(t)\\ast h(t)=\n$$\n\n$$\n\\frac{\\omega_H}{\\pi}\\sum\\limits_{n=-\\infty}^\\infty m(nT_s)\\delta(t-nT_s)\\ast Sa(\\omega_Ht)=\\frac{\\omega_H}{\\pi}\\sum\\limits_{n=-\\infty}^\\infty m(nT_s) Sa[\\omega_H(t-nT_s)]\n$$\n\n上述叠加过程称为 **内插**\n\n#### 4.2.4 带通信号的抽样定理\n\n频谱范围为 $f_L~f_H$ ，信号带宽 $B\\le f_L$则\n\n$$\nf_s=\\frac{2f_H}{n}=2\\frac{(n+k)B}{n}=2B(1+\\frac{k}{n}) \\quad 0\\le k<1\n$$\n\n其中 $n$ 是 $\\frac{f_H}{B}$ 取整部分； $k$ 是 $\\frac{f_H}{B}$ 的小数部分，当 $n\\gg1$ 时，$f_s=2B$\n\n![](https://pic.akorin.icu/20250228102640421.png)\n\n### 4.3 实际抽样\n\n- 自然抽样：抽样信号为周期性矩形脉冲序列![](https://pic.akorin.icu/20250228103859362.png)\n- 平顶抽样：![](https://pic.akorin.icu/20250228103942415.png)\n\n### 4.3 抽样信号的量化\n\n- 抽样后信号的幅值在其值域内依然是**连续信号**\n- 对连续的抽样值进行离散处理称为**量化**\n\n#### 4.3.1 均匀量化\n\n将模拟信号的取值范围分为若干量化区间，也成为**量化间隔**\n\n若各量化区间相等则称为**均匀量化**，否则称为非均匀量化\n\n- 设模拟信号的值域： -a~a\n- 量化区间数： M\n- 设二进制编码位数： N，应保证 $2^N\\ge M$ ，可取 $M=2^N$\n- 均匀量化： $\\triangle v=\\frac{2a}{M}$\n- 量化值： $q_i$ 一般取量化区间的中间值，且当 $m_{i-1}\\le m_k<m_i$ 时，$m_q=q_i$\n\n$$\nq_i=\\frac{m_i+m_{i-1}}{2}=-a+i\\triangle v-\\frac{\\triangle v}{2}\n$$\n\n- 量化噪声的平均功率： $N_q=\\frac{(\\triangle v)^2}{12}$\n- 信号的平均功率： $S_0=\\frac{M^2}{12}(\\triangle v)^2$\n- 量化信噪比： $\\frac{S_0}{N_q}=M^2=2^{2N}$\n\n> 主要结论：\n> - 量化信噪比与量化等级数或编码位数有关\n> 量化噪声功率只与量化间隔有关\n> 对于小输入信号，瞬时量化信噪比较小，对于大输入信号，瞬时量化信噪比较大\n> 均匀量化不适合处理电话语音信号，因为电话语音信号小信号占多数，信噪比低\n\n#### 4.3.2 非均匀量化 :star::star::star::star::star:\n\n非均匀量化采用可变的量化间隔，让小信号量化间隔小一些，大信号量化间隔大一些，在编码位数和量化等级不变的情况下，可以**提高小信号的信噪比**\n\n非均匀量化可以通过对输入信号进行非线性处理后再均匀量化实现。\n\n:::tip 非线性处理\n对小信号放大倍数大，对打信号放大倍数小。在发送端的非线性处理成为压缩\n\n在接收端消除信号失真称为扩张，扩张是压缩的逆过程\n:::\n\n考虑到双极性信号的输入，他所特性包含第一、三象限两部分，且相互奇对称\n\n> 理想压缩特性\n\n**“理想”**量化间隔正比于输入信号，将压缩器和输入和输出信号归一化，x和y的取值范围均在0~1之间。y轴的量化间隔 $\\triangle y=\\frac{1}{M}$ （y轴平均）\n\n量化区间数M通常比较大，因此每个量化区间内的曲线可以近似看作直线段\n\n$$\n\\frac{\\triangle y}{\\triangle x}=\\frac{dy}{dx}\\Rightarrow\\triangle x=\\frac{dx}{dy}\\triangle y= \\frac{1}{M}\\frac{dx}{dy}\n$$\n![](https://pic.akorin.icu/20250228144053221.png)\n解该线性微分方程可得： $\\ln x=ky-k$，\n\n边界条件： $x=1$ 时， $y=1$，则 $y=1+\\frac{1}{k}\\ln x$ 或称为**对数压缩特性**\n\n----\n> A律标准\n\n理想压缩特性是物理不可实现的，因为当 $x=0$ 时， $y=-\\infty$\n\n在理想压缩特性曲线上修正后可得A律标准：\n\n$$\ny=\\begin{cases} \\frac{1+\\ln Ax}{1+\\ln A}, &  \\frac{1}{A}<x\\le 1\\\\ \\frac{Ax}{1+\\ln A}, & 0\\le x\\le \\frac{1}{A} \\end{cases}\n$$\n\n常数A决定了压缩程度，当 $A=1$ 时， $y=x$ ，未压缩，相当于均匀量化。当 $A>1$ ，进行压缩\n\n![](https://pic.akorin.icu/20250228144122798.png)\n\n----\n> 13折线压缩特性\n\nA律标准的特性很难用模拟电路的方法去实现，利用数字电路较容易精确实现A律标准。具体做法是将A律标准分段线性化，当总的量化等级足够多的情况下，可以得到逼近A律标准的近似曲线\n\n将x轴的0~1对分为8段，y轴0~1等分为8段，将相应的点相连，构成8根折线\n\n“13折线”是A=87.6的A律特性的近似\n\n![](https://pic.akorin.icu/20250228145512173.png)\n![](https://pic.akorin.icu/20250228145758114.png)\n\n第一、二段的放大倍数相同。可见信号越小，放大倍数越大，反之信号越大，放大倍数越小，实现了信号的压缩。由于对称性，第三象限靠近原点的两端斜率为16，故在一共$8\\times2=16$根折线中，有4根同斜率。因此实际的折线数为$8\\times2-3=13$根，也就是13折线\n\nA律小信号的放大倍数（**斜率**）为 $\\frac{A}{1+\\ln A}$ ，13折线特性的放大倍数与之相近\n![](https://pic.akorin.icu/20250228151126918.png)\n\n### 4.4 量化信号的编码\n#### 4.4.1 自然二进制码和折叠二进制码\n\n![](https://pic.akorin.icu/20250228151955020.png)\n\n自然二进制码按照量化值的大小顺序排列，折叠二进制码分为两部分，分别表示符号以及绝对值，最高位是符号位，1为正数、0为负数；余下的3位表示绝对值\n\n#### 4.4.2 电话信号的编译码\n\n在压缩特性中，对输入和输出信号都进行了归一化处理，定义一个新的单位——**量化单位**，一个量化单位等于最小量化间隔\n\n对于正极性信号，13折线的第1段是 0~1/128 ，段内再细分为16份（固定16份），则最小量化间隔为1/2048\n\n则 1个量化单位=1/2048\n\n- 与均匀量化对应的编码：线性码，0~2048，11位码\n- 与非均匀量化对应的编码：非线性码 $c_1c_2c_3c_4c_5c_6c_7c_8$\n\n每个抽样值经量化后编程8位二进制码\n\n- $c_1$ ===> 符号码，当输入抽样值为正，$c_1=1$；抽样值为负， $c_1=0$\n- $c_2c_3c_4$ ===> 段码，段的编号1~8由原点开始计数，按照自然二进制码顺序从000~111，第三象限特性依然是从远点开始的顺序 ![](https://pic.akorin.icu/20250228152927062.png)\n- $c_5c_6c_7c_8$ ===> 段内码，编号1~16，按照自然二进制码从0000~1111，第三象限特性亦如此\n\n:::warning\n$c_1c_2c_3c_4$ 组合在一起是折叠二进制码， $c_5c_6c_7c_8$是自然二进制码\n:::\n\n### 4.5 PCM系统抗噪声性能\n\nPCM系统的噪声来源主要由两方面而来：\n- 误码噪声\n- 量化噪声\n\n二者相互独立\n\n#### 4.5.1 误码噪声功率\n\n将所有码位错码的误差功率求平均，称为**误码噪声功率**\n\n- 一个N位线性PCM码组自然二进制码的误码噪声功率为：\n$$\nN_e=\\frac{2^{2N}}{3}P_e(\\triangle v)^2\n$$\n\n- 一个N位线性PCM码组折叠二进制码的误码噪声功率为：\n$$\nN_e=\\frac{5}{4}(\\frac{2^{2N}}{3})P_e(\\triangle v)^2\n$$\n\n即折叠码的误码噪声平均功率是自然二进制码的1.25倍\n\n#### 4.5.2 PCM输出信噪比\n\n> 信号的平均功率：\n$$\nS_0=\\frac{M^2}{12}\\cdot(\\triangle v)^2=\\frac{2^{2N}}{12}\\cdot(\\triangle v)^2\n$$\n\n> 均匀量化的噪声功率：\n$$\nN_q=\\frac{(\\triangle v)^2}{12}\n$$\n\n> PCM系统的总输出信噪比：\n$$\n\\frac{S_0}{N}=\\frac{S_0}{N_q+N_e}\n$$\n> 对于自然二进制码：\n> - 当量化噪声为主要影响时：\n> $\\frac{S_0}{N}\\approx2^{2N}$\n> - 当误码噪声为主要影响时：\n> $\\frac{S_0}{N}\\approx\\frac{1}{4P_e}$\n\n> 对于折叠二进制码：\n> - 当量化噪声为主要影响时：\n> $\\frac{S_0}{N}\\approx2^{2N}$\n> - 当误码噪声为主要影响时：\n> $\\frac{S_0}{N}\\approx\\frac{1}{5P_e}$\n\n当$N=8$时，量化信噪比 $\\frac{S_0}{N_0}\\approx6.6\\times10^4$\n\n当 $P_e=10^{-6}\\sim{10}^{-5}$\n- 自然二进制码：$\\frac{S_0}{N_0}\\approx 2.5\\times 10^4 \\sim 2.5 \\times 10^5$\n- 折叠二进制码：$\\frac{S_0}{N_0}\\approx 2\\times 10^4 \\sim 2 \\times 10^5$\n\n当 $P_e < 10^{-6}$ 时，可以忽略误码噪声；\n\n当 $P_e > 10^{-5}$ 时，可以忽略量化噪声；\n\n\n### 4.6 差分脉冲编码调制DPCM\n\n不是直接对样值进行编码，而是对当前的样值与其预测值之间的差值进行编码，一般采用线性预测的方法来进行预测\n\n:::tip 线性预测\n线性预测时用前面若干个抽样值的**线性加权和**来预测当前的样值。\n设模拟基带信号表示为 $m(t)$，第k个抽样值表示为 $m_k$，其预测值表示为 $\\hat{m}=\\sum\\limits^p_{i-1}a_im_{k-i}$\n\n其中， $a_i$是预测系数，P是预测阶数，**预测值与前面P个抽样值有关**\n:::\n\n线性预测编码器原理框图：\n![](https://pic.akorin.icu/20250228213646183.png)\n\n实际中量化误差总是存在的，**因此预测值 $\\hat{m_k}$ 可以看成是带有量化误差的抽样信号 $m_k$**\n\n编码器是对预测误差 $e_k$ 进行编码，预测误差的动态范围通常较小，线性预测编码的实质利用了信号抽样值之间的相关性，减少了信号的冗余度，降低了比特率\n\n线性预测译码器结构框图：\n![](https://pic.akorin.icu/20250228213855964.png)\n\n预测误差的不同所带来的量化噪声分以下情况：\n- 预测误差 $e_k$ 范围限制在 $(-\\sigma,+\\sigma)$范围内。对预测误差进行量化，这种情况的噪声称为 **一般量化噪声**\n- 若响铃抽样值之间的变化超过$(-\\sigma,+\\sigma)$，或者或信号的斜率超过 $\\frac{\\sigma}{T}$，这种情况称为过载失真，这种情况的噪声称为 **过载量化噪声**\n\n> **自适应差分脉冲编码调制：ADPCM(Adaptive DPCM)**\n>\n> 语音信号是**非平稳信号**，其统计特性随时间而变化\n> 信号预测和量化器参数最好能根据输入信号来**自适应变化**\n> ADPCM一方面采用**自适应预测级数**；另一方面量化器的量化等级、量化电平也随信号**自适应调整**\n\n### 4.7 增量调制DM(Delta Modulation)\n\n**DM可以看成是特殊的DPCM**，在DPCM中当对预测误差进行**一位二进制编码**时，就是DM\n\n1bit编码输出对应的量化电平时$+\\sigma$或$-\\sigma$，分别表示预测误差的极性，是正或负\n\n当抽样频率足够高时，响铃抽样值的变化量很小，**用一位码有可能表示相邻抽样值的变化规律**\n\nDM编码器a\\c和译码器b\\d\n![](https://pic.akorin.icu/20250228221811434.png)\n\nDM是用增或减$\\sigma$电平的阶梯波，取近似原连续信号。通常用积分器代替延迟和相加电路，积分器输出在$T_s$期间信号的变化量\n\n量化误差的两种情况：\n- 一般量化\n- 过载量化\n![](https://pic.akorin.icu/20250228222050430.png)\n\n### 4.8 PCM信号的时分复用和复接\n\n> 复用：指多个用户共用同一物理信道，提高信息传输效率的技术\n> - 时分复用\n> - 频分复用\n> - 波分复用\n> - 码分复用\n\n:::tip 复接\n将低次群汇成高次群的过程\n:::\n:::tip 分接\n将高次群还原成低次群的过程\n:::\n\n对于TDM系统，同步信号是保证通信系统正常工作的必要条件：**码元同步（位同步）**、**帧同步（群同步）**\n\n#### 4.8.1 定量关系\n\n- 一帧的时长：抽样周期 $\\frac{1}{8000}=125 \\quad \\mu s$\n- 每帧分为**32个时隙**： $TS_0,TS_1, \\ldots ,TS_{31},$\n- 每个话路占一个**时隙** $\\frac{125}{32}\\approx 3.906 \\quad \\mu s$\n- 由于每路的抽样值还要编成为八位二进制码，所以**码元周期**为 $3.\\frac{906}{8}\\approx 0.488 \\mu s$\n- 基群的**码元速率**为 $8000 \\times 32 \\times 8 = 2048 Kbps$\n- PCM每16帧构成**复帧**， 复帧时长 $125 \\mu s \\times 16 = 2 \\quad ms$\n- PCM数字复接：4个低次群复接 ===> 1个高次群\n\n两类同步数字体系\n- 准同步复接PDH\n- 同步复接SDH\n\n### 4.9 帧同步\n#### 4.9.1 帧同步插入方式\n\n- 集中插入法\n- 分散插入法\n\n#### 4.9.2 帧同步码的识别\n\n**帧同步码识别器**由移位寄存器、相加器和判决器组成\n\n- 假同步：若信息序列中正好有连续位与帧同步码相同，则识别器也会输出正脉冲\n- 漏同步：当同步码中由错码时，可能不被识别\n\n## 5.基本的数字调制技术\n\n数字基带信号分为二进制和多进制两大类\n\n| 二进制    | 多进制 | 改进       |\n| --------- | ------ | ---------- |\n| 2ASK      | MASK   | QAM        |\n| 2FSK      | MFSK   | MSK,GMSK   |\n| 2PSK,2DSK | MPSK   | QPSK,DQPSK |\n\n### 5.1 二进制数字信号的调制\n#### 5.1.1 二进制振幅键控(2ASK)\n\nASK(Amplitude Shift Keying)，又称幅移键控\n- 传号“1” ====> 载波有振幅\n- 空号“0” ====> 载波振幅为0\n\n数字基带信号 $s(t)=\\sum\\limits^\\infty_{n=-\\infty}a_ng(t-nT_B)$\n\n载波 $c(t)=A\\cos2\\pi f_ct$\n\n> 则2ASK信号为：\n> $s_m(t)=s(t)c(t)$ 或\n$$\ns_m(t)=\n\n\\begin{cases} s_1(t)=A\\cos 2\\pi f_c t, & s(t)=1 \\\\ s_0(t)=0, & s(t)=0 \\end{cases}\n\\quad\n0\\le t\\le T_B\n$$\n\n![](https://pic.akorin.icu/20250301141401949.png)\n\n> 2ASK信号的功率谱密度：\n> $P_{2ASK}(f)=\\frac{A^2}{4}[P_s(f+f_c)+P_s(f-f_c)]$\n> ![](https://pic.akorin.icu/20250301141712773.png)\n\n> 2ASK信号的带宽：$2R_B$\n\n2ASK信号的功率谱密度是将单极性基带序列的功率谱密度平移至中心频率$f=f_e$处，属于线性调制。其中$R_B$是基带信号的码元传输速率，**2ASK信号的的带宽即为$2R_B$**。功率谱中含有离散谱和连续谱，离散谱可以作为导频信号，有助于接收端方便地提取载波信号，实现相干解调\n\n> 2ASK信号的调制\n> - 模拟相乘法：![](https://pic.akorin.icu/20250301145927516.png)\n> - 数字键控法：![](https://pic.akorin.icu/20250301145957444.png)\n\n#### 5.1.2 二进制频移键控(2FSK)\n\nFSK(Frequency Shift Keying)又称频移键控\n- 传号“1” ====> 载波频率 $f_1$\n- 空号“0” ====> 载波频率 $f_2$\n\n实现过程中又分为**相位不连续**及**相位连续**两种频移键控信号\n\n> **相位不连续的2FSK信号**\n>\n> 数字基带信号 $s(t)$ 控制开关K以键控方式分别接通两个载波，产生频移键控信号\n> ![](https://pic.akorin.icu/20250301151035577.png)\n> 相位不连续的2FSK信号二点时域表达式为：\n$$\ns_m(t)=\n\\begin{cases} s_1(t)=A\\cos 2\\pi f_1t, & s(t)=1 \\\\ s_0(t)=A\\cos 2\\pi f_2 t, & s(t)=0 \\end{cases}\n\\quad\n0\\le t\\le T_B\n$$\n\n> **相位连续的2FSK信号**\n>\n> 数字基带信号 $s(t)$ 控制压控振荡器VCO的振荡频率，产生频移键控信号。压控振荡器的中心振荡频率 $f_c=\\frac{1}{2}(f_1+f_2)$\n> ![](https://pic.akorin.icu/20250301151432843.png)\n> 连续香味2FSK信号的时域表达式为：\n$$\ns_m(t)=A\\cos[2\\pi f_ct+k_f]\\int^t_{-\\infty}s(\\tau)d\\tau\n$$\n其中 $k_f$ 是调频器的调频灵敏度\n![](https://pic.akorin.icu/20250301151909222.png)\n\n一路2FSK信号可以等效成两路2ASK信号的叠加，且这两路2ASK信号中各自携带的数字基带信号互为反码，因而2FSK信号的功率谱密度等效于两路2ASK信号功率谱密度之和\n![](https://pic.akorin.icu/20250301151917860.png)\n\n由上图可知，2FSK信号的功率谱密度与数字基带信号的功率谱密度形状完全不同，属于非线性调制。\n\n> 2FSK信号的带宽： $|f_2-f_1|+2R_B$\n\n:::warning\n当$|f_2-f_1|\\ge 2R_b$时，2FSK信号可以分离成两路独立的2ASK信号；当$|f_2-f_1|\\le   2R_b$时，不能直接滤波分离，这种特性将会影响2FSK信号解调方法的选择\n:::\n\n> **2FSK两个信号波形之间的互相关系数**\n>\n> 从2FSK信号的频谱结构可看出，它的带宽参数与 $|f_2-f_1|$ 有关。相位不连续和相位连续的2FSK信号本质就是 $|f_2-f_1|$ 与基带信号码元速率间数值比率不同引起的\n> 定义2FSK两个信号波形 $s_1(t),s_0(t)$之间互相关系数为：\n$$\n\\rho=\\frac{1}{E_b}\\int^{T_B}_0s_1(t)s_0(t)dt\n$$\n式中\n$$\nE_b=\\int^{T_B}_0s_1^2(t)dt=\\int^{T_B}_0s_0^2(t)dt=\\frac{1}{2}A^2T_B\n$$\n将 $s_1(t),s_2(t)$ 带入上式，并限定$2\\pi f_c T_B$是$\\pi$的整数倍整理得：\n\n$$\n\\rho = Sa [2\\pi (2 \\triangle f)T_B]\n$$\n\n说明互相关系数$\\rho$是$2\\triangle f$与$T_B$的函数，函数范围$[-1,+1]$，选取不同的载波频率和基带信号码元速率值，会产生不同的$\\rho$值，这将影响2FSK信号带宽参数的变化\n\n在实际应用中应尽可能减小信号带宽且利于解调，多选择 $\\rho=0$ 。这时 $s_1(t),s_2(t)$ 正交，有 $2\\pi(2 \\triangle f)T_B = n\\pi$ ，所以两个载频的频率间隔为：\n$$\n2\\triangle f=\\frac{n}{2T_B}\n$$\n取 $n=1$ ，信号带宽最小，时2FSK信号的形式之一，称为**最小移频键控MSK信号**\n\n\n#### 5.1.3 二进制相移键控(2PSK与2DPSK)\n\nPSK(Phase Shift Keying)又称移相键控\n\nDPSK(Differential Phase Shift Keying)又称差分相移键控或相对相移键控\n\n- 二进制：2PSK,2DPSK\n- 四进制：QPSK,QDPSK\n- M进制：MPSK,MDPSK\n\n> 移相键控信号的时域表达式：\n$$\n\\varphi=\n\\begin{cases} 0, & s(t)=1 \\\\ \\pi, & s(t)=0 \\end{cases}\n$$\n\n![](https://pic.akorin.icu/20250301162051334.png)\n\n> 2PSK信号的时域表达式：\n$$\ns_m(t)=s(t)c(t)=\n\\begin{cases} s_1(t)=A\\cos 2\\pi f_c t, & s(t)=1 \\\\ s_0(t)=-A\\cos 2\\pi f_c t, & s(t)=0 \\end{cases}\n\\quad\n0\\le t\\le T_B\n$$\n\n> 2DPSK信号可以用相邻码元的载频初相差 $\\triangle \\varphi$ 来表示传号和空号\n\n$$\n\\triangle \\varphi=\\varphi_n-\\varphi_{n-1}=\n\\begin{cases} \\pi, & s(t)=1 \\\\ 0, & s(t)=0 \\end{cases}\n$$\n\n> 实现方法：\n>\n> - 将二进制基带序列进行差分编码： $b_n=a_n\\oplus b_{n-1}$ ， ${a_n}$ 是绝对码，${b_n}$ 是相对码，\n> - 对 ${b_n}$ 进行2PSK\n\n> 键控法产生2PSK和2DPSK\n> ![](https://pic.akorin.icu/20250301163545985.png)\n\n2PSK和2DPSK信号的相位及波形关系：\n![](https://pic.akorin.icu/20250301163733470.png)\n\n> **PSK的功率谱密度**\n>\n> 2PSK信号实质上是双极性的2ASK信号，与2ASK不同的是，当“1”和“0”等概时，2PSK信号不含 $f_c$ 冲激成分。 2PSK属于线性调制，2DPSK和2PSK的功率谱密度相同\n\n![](https://pic.akorin.icu/20250301165916369.png)\n\n### 5.2 二进制数字解调技术与抗噪声性能\n\n二进制数字解调方法分为非相干解调、相干解调和匹配滤波器三大类，采用不同解调方案的系统其抗噪性能有所不同。总体来说**匹配滤波器**的抗噪声性能最好，相干解调次之，非相干解调较差但设备简单。接受模型的性能参数为误码率或误比特率：\n![](https://pic.akorin.icu/20250301171306685.png)\n\n> **常用转换**\n> 设接收机带通滤波器带宽 $B=2R_B$\n> - $\\sigma_n^2=n_0B=n_0 \\cdot 2R_B = \\frac{2n_0}{T_B}$\n> - 比特能量： $E_b=\\frac{1}{2}A^2T_B$\n> - 解调器输入端信噪比： $r=\\frac{A^2}{2\\sigma^2}$ ，大信噪比条件： $r\\gg 1$\n\n\n#### 5.2.1 2ASK信号的解调\n\n2ASK信号的解调有非相干解调、相干解调和匹配滤波器三种\n\n![](https://pic.akorin.icu/20250301172141564.png)\n\n> **非相干解调**\n\n利用包络检波器可实现2ASK的**非相干解调**，不需要载波提取电路\n![](https://pic.akorin.icu/20250301171347772.png)\n\n- 发送：\n$$\ns_m(t)=\\begin{cases} s_1(t)=A\\cos \\omega_c t, & 1 \\\\ s_0(t)=0, & 0 \\end{cases}\n\\quad\n0\\le t\\le T_B\n$$\n\n- 接收：\n$$\nr(t)=s_m(t)+n_i(t)=\\begin{cases} A\\cos \\omega_c t +n_i (t), & 1 \\\\ n_i(t), & 0 \\end{cases}\n$$\n\n- 在大信噪比条件下，最佳门限近似为：\n$$\nV^*_d\\approx \\frac{A}{2}\n$$\n- 在大信噪比条件下，误码率近似为：\n$$\nP_e\\approx \\frac{1}{2} \\exp(-\\frac{r}{4})\n$$\n\n> **相干解调**\n\n需要载波提取电路\n![](https://pic.akorin.icu/20250301172606055.png)\n\n- 最佳门限：\n$$\nV_d^*=\\frac{A}{2}\n$$\n- 误码率：\n$$\nP_e=\\frac{1}{2} erfc(\\sqrt{\\frac{A^2}{8\\sigma^2_n}})\n$$\n当 $r=\\frac{A^2}{2\\sigma^2} \\gg 1$ （更大概率考）\n$$\nP_e \\approx \\frac{1}{\\sqrt{\\pi r}}\\exp(-\\frac{r}{4})\n$$\n\n:::tip 互补误差函数erfc\n$erfc(x)=\\frac{2}{\\sqrt{\\pi}}\\int^\\infty_x e^{-y^2}dy$\n\n$erf$ 是高斯误差函数，与 $erfc$ 的关系是：\n\n$erf(x)+erfc(x)=1$\n\n一般是查表获得\n:::\n\n> **匹配滤波器**\n\n匹配滤波器是一种保证抽样判决时刻输出信噪比最大的线性滤波器，同时也是一种最佳接收机\n\n:::tip 最佳接收机\n指误码率最小的接收机，而误码率最小和信噪比最大是等价的，在抽样判决前加一个匹配滤波器可以获得最佳的抗噪声性能\n:::\n\n- 匹配滤波器的结构\n![](https://pic.akorin.icu/20250301210147124.png)\n\n- 匹配滤波器解调\n![](https://pic.akorin.icu/20250301210209491.png)\n\n由随机信号可知，Z是高斯随机变量，其均值和方差分别为：\n$E(Z)=0$\n\n$$\nD(Z)=\\frac{n_0}{2}E_b\n$$\n\n- 平均误码率：\n$$\nP_e=\\frac{1}{2}erfc(\\sqrt{\\frac{A^2T_B}{4n_0}})\n$$\n\n而2ASK的平均误码率：\n$$\nP_e=\\frac{1}{2}erfc(\\sqrt{\\frac{A^2T_B}{8n_0}})\n$$\n由上述两式对比可知，匹配滤波器解调的系统平均误码率小，接受性能最佳\n\n#### 5.2.2 2FSK信号的解调\n\n2FSK解调有非相干解调、相干解调和匹配滤波器\n\n> **非相干解调**\n\n常用的2FSK信号非相干解调有**包络检波法、过零检测法**等\n\n- 包络检波法：此方案的条件是2FSK信号中两载频之差 $|f_2-f_1|\\ge 2R_B$ ，这样就可以将一路2FSK信号分离成两路2ASK信号\n![](https://pic.akorin.icu/20250301210852070.png)\n\n- 判决规则：\n\n| $y_1,y_0$的关系 | 判决 |\n| ----------- | ---- |\n| $y_1\\ge y_0$    | 判1  |\n| $y_1< y_0$       | 判0  |\n\n- 系统的平均误码率：\n$$\nP_e=P_{e1}=\\frac{1}{2}\\exp{(-\\frac{r}{2})}\n$$\n\n----\n\n- 过零检测法：基本思想是基于2FSK信号的两载频郭零点次数的不同，通过检测过零点数恢复基带信号\n![](https://pic.akorin.icu/20250301211427894.png)\n\n- 系统平均误码率：与包络检波法相同\n$$\nP_e=P_{e1}=\\frac{1}{2}\\exp{(-\\frac{r}{2})}\n$$\n\n> **相干解调**\n此方案的应用条件是： 两载频之差 $|f_2-f_1|\\ge 2R_B$\n![](https://pic.akorin.icu/20250301211703038.png)\n\n- 抽样判决规则：\n\n| $l=y_1-y_0$ | 判决 |\n| -------- | --- |\n| $l\\ge 0$ | 判1 |\n| $l<0$    | 判0 |\n\n- 平均误码率：\n$$\nP_e=P_{e1}=\\frac{1}{2}erfc(\\frac{A}{2\\sigma_n})=\\frac{1}{2}erfc(\\sqrt{\\frac{r}{2}})\n$$\n当 $r\\gg_1$ 时，可近似为：\n$$\nP_e \\approx \\frac{1}{\\sqrt{2\\pi r}}\\exp(-\\frac{r}{2})\n$$\n\n> **匹配滤波器**\n\n![](https://pic.akorin.icu/20250301212846942.png)\n\n- 抽样判决规则：\n\n| $l=y_1-y_0$ | 判决 |\n| ----------- | ---- |\n| $l\\ge 0$    | 判1  |\n| $l<0$       | 判0  |\n\n$$\nP_e=\\frac{1}{2}erfc(\\sqrt{\\frac{E_b}{2n_0}})=\\frac{1}{2}erfc(\\sqrt{\\frac{A^2T_B}{4n_0}})\n$$\n\n#### 5.2.3 2PSK和2DPSK信号的解调\n\n由于2PSK和2DPSK信号来说，信息是寄予相位之中，不能用包络检波器完成解调，但2DPSK信号是用前后码元相对载波相位表示信息，利用这个特点可以完成非相干解调。故2PSK只有相干解调和匹配滤波器，2DPSK有非相干解调、相干解调和匹配滤波器\n\n> **非相干解调**\n>\n> 只有2DPSK可以用这种方法，2PSK不能\n\n![](https://pic.akorin.icu/20250301213437267.png)\n\n- 经过低通滤波器输出抽样信号为：\n$$\ny(nT_B)=\\frac{A^2}{2}\\cos(\\varphi_n-\\varphi_{n-1})\n$$\n根据2DPSK信号的定义：\n$$\n\\triangle \\varphi=\\varphi_n-\\varphi_{n-1}=\n\\begin{cases} \\pi, & 1 \\\\ 0, &  0\\end{cases}\n$$\n\n- 设定最佳判决门限为0，则判决规则为：\n| $y(nT_B)$   | 判决 |\n| ----------- | ---- |\n| $y(nT_B)<0$ | 判1  |\n| $y(nT_B)>0$ | 判0  |\n\n- 误码率：\n$$\nP_e=\\frac{1}{2}\\exp({-\\frac{A^2}{2\\sigma^2_n}})=\\frac{1}{2}\\exp(-r)\n$$\n其中 $\\sigma_n^2=2n_0 R_B$\n\n> **相干解调**\n>\n> 2PSK的相干解调\n\n![](https://pic.akorin.icu/20250301220921052.png)\n\n2PSK信号等效于双极性2ASK\n\n\n- 设定最佳判决门限为0，则判决规则为：\n| $y(nT_B)$   | 判决 |\n| ----------- | ---- |\n| $y(nT_B)>0$ | 判1  |\n| $y(nT_B)<0$ | 判0  |\n\n- 误码率：\n$$\nP_e=\\frac{1}{2} erfc(\\sqrt{\\frac{A^2}{2\\sigma^2_n}})=\\frac{1}{2}erfc(\\sqrt r)\n$$\n当 $r\\gg1$ 时，可近似为：\n$$\nP_e \\approx \\frac{1}{2\\sqrt{\\pi r}}\\exp(-r)\n$$\n\n> 2DPSK的相干解调\n\n![](https://pic.akorin.icu/20250301221248967.png)\n\n判决输出的是相对码序列，经过差分译码得到绝对码。当相对码出现误码时，差分译码就会出现错上加错的情况，使系统的误码率增加。通过PSK的误码率计算DPSK的误码率\n\n- DPSK相干解调系统的误码率：\n$$\nP'_e=2P_e(1-P_e)\n$$\n当 $P_e$ 较小时，可近似为：\n$$\nP'_e=2P_e\n$$\n\n\n> **匹配滤波器**\n\n利用匹配滤波器实现2PSK信号解调：\n![](https://pic.akorin.icu/20250301221801315.png)\n\n- 发送 $s_1(t)$ 时，$y(nT_B)=E_b+Z$\n- 发送 $s_0(t)$ 时，$y(nT_B)=-E_b+Z$\n\n- 设定最佳判决门限为0，则判决规则为：\n| $y(nT_B)$   | 判决 |\n| ----------- | ---- |\n| $y(nT_B)>0$ | 判1  |\n| $y(nT_B)<0$ | 判0  |\n\n- 系统统计平均误码率：\n$$\nP_e=\\frac{1}{2}erfc(\\sqrt{\\frac{E_b}{n_0}})\n$$\n\n----\n\n**三中解调方式的抗噪声性能**\n|       | 非相干解调                        | 相干解调                                    | 匹配滤波器解调                              |\n| ----- | --------------------------------- | ------------------------------------------- | ------------------------------------------- |\n| 2ASK  | $\\frac{1}{2}\\exp{(-\\frac{r}{4})}$ | $\\frac{1}{\\sqrt{\\pi r}}\\exp(-\\frac{r}{4})$  | $\\frac{1}{2} erfc(\\sqrt{\\frac{E_b}{4n_0}})$ |\n| 2FSK  | $\\frac{1}{2}\\exp{(-\\frac{r}{2})}$ | $\\frac{1}{\\sqrt{2\\pi r}}\\exp(-\\frac{r}{2})$ | $\\frac{1}{2} erfc(\\sqrt{\\frac{E_b}{2n_0}})$ |\n| 2PSK  |                                   | $\\frac{1}{2\\sqrt{\\pi r}}\\exp(-r)$           | $\\frac{1}{2} erfc(\\sqrt{\\frac{E_b}{n_0}})$  |\n| 2DPSK | $\\frac{1}{2}\\exp(-r)$             | $\\frac{1}{\\sqrt{\\pi r}}\\exp(-r)$            |                                             |\n\n\n### 5.3 四进制相移键控(QPSK)\n### 5.4 四进制差分相移键控(QDPSK)\n\n...\n\n## 6.现代数字调制技术\n### 6.1  正交振幅调制(QAM)\n\nQAM用两路独立的数字基带信号对两个相互正交的同频载波进行抑制载波的DSB调制，利用这种已调信号在同一带宽内频谱正交的性质来实现两路并行的数字传输\n\n ![](https://pic.akorin.icu/20250302194502983.png)\n 输入的二进制序列经过串/并变换为输出速率减半的两路并行序列，再分别经过2电平到L电平的变换，形成L电平（L进制）的基带信号\n\n 信号矢量断电的分布图称为星座图，通常可以用星座图描述QAM信号的信号空间分布状态\n![](https://pic.akorin.icu/20250302195647371.png)\n\n### 6.2 正交频分复用(OFDM)\n\n正交频分复用是一种并行机制，有较强的抗多径传播和频率选择性衰落的能力以及较高的频谱利用率。\n\nOFDM是一种高效调制技术，其基本原理是将发送的数据流分散到许多个子载波上，使各子载波的信号速率大为降低，从而提高抗多径和抗衰落的能力。OFDM方式种各子载波频谱有1/2重叠，但保持相互正交\n\n![](https://pic.akorin.icu/20250302200636174.png)\n与一般的频分复用(FDM)技术不同，OFDM系统种各子信道在时间上相互正交，在频率上互相重叠，使得ODFM系统比FDM系统节省了很多带宽\n\nOFDM技术的主要思想是将指配的信道分成许多正交子信道，在每个子信道上进行窄带调制和传输，信号带宽小于信道的相关带宽\n\n- OFDM的调制\n![](https://pic.akorin.icu/20250302200923965.png)\n\n- OFDM的解调\n![](https://pic.akorin.icu/20250302200949879.png)\n\n## 7.纠错编码技术\n### 7.1 纠错编码的概念\n\n数字信号传输过程中，由于信道传输特性不理想及加性噪声的影响，不可避免地会发生错误。可用如下三种方法减小误码率：\n- 提高信道容量\n- 降低编码效率\n- 增加码长\n\n#### 7.1.1 错码的分类\n\n按照错码分布规律的不同，可分为三类：\n\n- 随机性错码：错码的出现是随机的，它由高斯白噪声引起\n- 突发性错码：错码是成串集中出现的，产生突发错码的主要原因是脉冲干扰和信道中的衰落\n- 混合型错码：既有随即错吗又有突发错码\n\n#### 7.1.2 差错控制方法\n\n- 前向纠错：接收端能检测出错码，并可以确定错码的位置，并予纠正\n- 检错重发：接收端检测出错码通知发端重发\n- 反馈校验：接收端将收到的信号原封不动发回发端，由发端将其与原发信号相比较，若有错误则重发\n\n#### 7.1.3 差错控制编码基本原理\n\n- 利用冗余度：在信息码原序列后增加一些监督码元。监督码元越多，检、纠错能力越强\n- 噪声均化（随机化）：设法把集中出现的突发性差错分摊开来，变成随机性差错\n\n#### 7.1.4 码距与纠检错性能\n\n- 分组码：将信息码分组，为每组信息码附加若干监督码元形成的码集合\n- 特点：分组码中的监督码元仅监督本码组中的信息码元\n- 符号：(n,k)\n> - k: 码组中**信息码元**的数目\n> - n: 码组的总位数，又称为**码组长度**\n> - r: $r=n-k$ 码组中**监督码元**的数目\n> 编码效率： $\\frac{k}{n}$\n> 冗余度： $\\frac{n-k}{k}$\n\n![](https://pic.akorin.icu/20250302202607676.png)\n\n- 码组重量： 码组中'1'的数目\n- 码距d：两个码组对应位上**不同的码元个数**，称为**汉明距离**\n- 最小码距 $d_0$ ： 码集合中任意两两码组间距离的最小值\n\n> **码距与码集合检、纠错能力的关系**\n> - 检测 e 个错码，要求最小码距 $d_0\\ge e+1$\n> - 纠正 t 个错码，要求最小码距 $d_0\\ge 2t+1$\n> - 纠正 t 个错码、同时检测 e 个错码，要求最小码距 $d_0\\ge e+t+1 \\quad (e>t)$\n\n### 7.2 线性分组码\n\nr位监督码对应r个校对子，就有 $2^r$ 种组合，用其中一种组合表示无措，其余 $2^r-1$ 种组合表示错码的位置\n\n若只错一位，分组码 (n,k) 种的错码有n个可能的位置，要用r位表示这n个错码的位置，r取最小值 $2^r-1 \\ge n$\n\n:::tip 汉明码\n能纠正一位错码，且 $2^r-1=n$ 的线性分组码，称为汉明码\n\n其编码效率为：\n$$\n\\frac{k}{n}=\\frac{2^r-1-r}{2^r-1}=1-\\frac{r}{2^r-1}=1-\\frac{r}{n}\n$$\n当n很大时，编码效率接近1.可见汉明码是一种高效码\n:::\n\n> e.g.\n> 已知(7,4)码，r=3 则 $2^3-1=7=n$ 共有3个监督方程构成3个校对子\n>\n> 建立监督方程：\n> $a_6\\oplus a_5\\oplus a_3\\oplus a_2\\oplus = 0$\n> $a_5\\oplus a_4\\oplus a_3\\oplus a_1\\oplus = 0$\n> $a_6\\oplus a_5\\oplus a_4\\oplus a_0\\oplus = 0$\n>\n> 建立编码方程：\n> $a_2=a_6\\oplus a_5\\oplus a_3\\oplus$\n> $a_1=a_5\\oplus a_4\\oplus a_3\\oplus$\n> $a_0=a_6\\oplus a_5\\oplus a_4\\oplus$\n\n| $S_1S_2S_3$ |          |\n| ----------- | -------- |\n| 000         | 无错     |\n| 001         | $a_0$ 错 |\n| 010         | $a_0$ 错 |\n| 100         | $a_0$ 错 |\n| 110         | $a_0$ 错 |\n| 011         | $a_0$ 错 |\n| 111         | $a_0$ 错 |\n| 101         | $a_0$ 错 |\n\n> 根据监督方程写出矩阵形式：\n\n$$\n\\begin{bmatrix}\n  1101100 \\\\\n  0111010 \\\\\n  1110001\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n  a_6 \\\\\n  a_5 \\\\\n  a_4 \\\\\n  a_3 \\\\\n  a_2 \\\\\n  a_1 \\\\\n  a_0 \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  0 \\\\\n  0 \\\\\n  0 \\\\\n\\end{bmatrix}\n$$\n记为： $H\\cdot A^T=0$ ，当 $H=[P \\quad I_r]$ 称H为典型监督矩阵（含单位阵）\n\n> 根据编码方程写出生成矩阵：\n$$\n\\begin{bmatrix}\n  a_2\\\\\n  a_1 \\\\\n  a_0\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  1 & 1 & 1 & 0  \\\\\n  1 & 1 & 0 & 1  \\\\\n  1 & 0 & 1 & 1  \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n  a_6 \\\\\n  a_5 \\\\\n  a_4 \\\\\n  a_3\n\\end{bmatrix}\n$$\n转置后可得：\n$$\n\\begin{bmatrix}\n  a_2 & a_1 & a_0\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  a_6 & a_5 & a_4 & a_3\n\\end{bmatrix}\n\\begin{bmatrix}\n  1 & 1 & 1  \\\\\n  1 & 1 & 0  \\\\\n  1 & 0 & 1  \\\\\n  0 & 1 & 1  \\\\\n\\end{bmatrix}\n=\\begin{bmatrix}\n  a_6 & a_5 & a_4 & a_3\n\\end{bmatrix}Q\n$$\n其中 $Q=P^T$\n\n最后科的生成矩阵G：\n$$\nG=[I_k \\quad Q] =\n\\begin{bmatrix}\n  1 & 0 & 0 & 0 & \\vdots & 1 & 1 & 1  \\\\\n  0 & 1 & 0 & 0 & \\vdots & 1 & 1 & 0  \\\\\n  0 & 0 & 1 & 0 & \\vdots & 1 & 0 & 1  \\\\\n  0 & 0 & 0 & 1 & \\vdots & 0 & 1 & 1  \\\\\n\\end{bmatrix}\n$$\n由生成矩阵G可以产生整个码组，前一半（单位矩阵）是信息码元，后一半是监督码元的编码矩阵\n\n通信中发送的码组就是上式的A。设接受矩阵是B，则错码行矩阵为E\n$E=B-A$\n\n- 译码计算：\n$$\nBH^T\n$$\n\n> e.g.\n>\n> 设发码组： $A=1100010$\n> 设收码组： $A=1000010$\n>\n$$\nBH^T=\\begin{bmatrix}\n  1000010\n\\end{bmatrix}\n\\begin{bmatrix}\n  101  \\\\\n  111  \\\\\n  011  \\\\\n  110  \\\\\n  100  \\\\\n  010  \\\\\n  001  \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  111\n\\end{bmatrix}\n$$\n$\\therefore$ $a_5$ 错误\n\n> **线性分组码的性质**\n>\n> - 封闭性：线性码中两个码组之和仍未这种码中的一个码组\n> - 两个码组间的距离必是零一码组的重量\n> - 除全0码组之外，编码的最小码重是码集合的最小码距\n> -线性分组码中必有全0码（信息码全0，监督码全0）\n\n### 7.3 循环码\n\n\n\n### 7.4 实用循环码\n\n\n\n### 7.5 卷积码\n\n\n","cover":"https://pic.akorin.icu/uj64pr7a.png","date":"2025-01-27 00:00:00"},{"title":"高级排序","tags":["笔记","编程","C++"],"categories":["笔记"],"author":"akorin","excerpt":"\n简要记录一系列高级排序的中心思想。\n\n","link":"/posts/%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F","content":"\n简要记录一系列高级排序的中心思想。\n\n<!-- more -->\n\n## 快速排序\n\n选取一个基准数，小于基准数的元素都调整到基准数的左边，把大于基准数的元素都调整到基准数的右边，然后对基准数左边和右边的序列继续进行这样的操作，直到正逢序列变有序。\n比较像二分思想。\n\n处理数组的递归问题，需要引入头和尾。\n\n- 时间复杂度 O(n)*O(logn) = O(nlogn)，最坏时间复杂度O(n^2)（在有序数组中使用快排）\n- 空间复杂度O(logn)：主要取决于递归时的深度，最坏空间复杂度O(n)（在有序数组中使用快排）\n- 不稳定算法\n\n```C++\n// 一次快排算法\nint Paration(int arr[], int l, int r) {\n    int val = arr[l];\n    while (l < r) {\n        // l < r防止直接退出导致没有遍历比较其它位置\n        while (l < r && arr[r]> val) {\n            --r;\n        }\n        if (l < r) {\n            arr[l] = arr[r];\n            ++l;\n        }\n        while (l < r && arr[l] < val) {\n            ++l;\n        }\n        if (l < r) {\n            arr[r] = arr[l];\n            --r;\n        }\n    }\n    arr[l] = val;\n    return l;\n}\nvoid QuickSort(int arr[], int begin, int end) {\n    if (begin >= end)\n        return;\n    // 在[begin,end]区间做一次快排分割处理，\n    // 并获取排列好的正确位置\n    int pos = Paration(arr, begin, end);\n    QuickSort(arr, begin, pos - 1);\n    QuickSort(arr, pos + 1, end);\n}\n```\n\n### 快速排序优化\n\n对于已经有序的数列来说，再采用快排其时间复杂度及空间复杂度都很大。\n\n1. 随着快排的执行，数据越来越有序，再一定范围内可以用插入排序代替快速排序。\n```C++\nvoid QuickSort(int arr[], int begin, int end) {\n    if (begin >= end)\n        return;\n    // 优化一：当[begin,end]序列的元素个数小到指定数量，采用插入排序\n    if (begin - end <= 50) {    // [!code ++]\n        InsertSort(arr, begin, end);    // [!code ++]\n        return; // [!code ++]\n    }   // [!code ++]\n    // 在[begin,end]区间做一次快排分割处理，\n    // 并获取排列好的正确位置\n    int pos = Paration(arr, begin, end);\n    QuickSort(arr, begin, pos - 1);\n    QuickSort(arr, pos + 1, end);\n}\n```\n\n2. 选择基准数时，采用 **“三数取中法”** ：\n    - `mid = (L + R) / 2`\n    - `L`\n    - `R`\n\n    这三个位置的序列中的数值在中间的数，作为基准数。\n3. 随机数法，随机在数列中取基准数，但是不如三数取中法靠谱。\n\n## 归并排序\n\n归-递归，并-合并。递到只有一个元素时就到头了，需要额外的内存空间把两个小段有序的序列合并成一个大段有序的序列。\n归并排序也采用“分治思想”。\n\n- 时间复杂度 O(n)*O(logn) = O(nlogn)，每层合并数据n个，层高是logn。\n- 空间复杂度O(logn)+O(n) = O(n)：每一层开辟的空间占大头，取O(n)\n- 稳定算法（在排序过程中，两数相等时先放左边的数，否则就是不稳定算法）\n\n```C++\n    // 归并过程函数\nvoid Merge(int arr[], int l, int m, int r) {\n    int* p = new int[r - l + 1];\n    int idx = 0;\n    int i = l;   // 左孩子第一个元素位置\n    int j = m + 1;   // 右孩子第一个元素位置\n    while (i <= m && j <= r) {\n        if (arr[i] <= arr[j]) {\n            p[idx++] = arr[i++];\n        } else {\n            p[idx++] = arr[j++];\n        }\n    }\n    while (i <= m) {\n        p[idx++] = arr[i++];\n    }\n    while (j <= r) {\n        p[idx++] = arr[j++];\n    }\n    // 再把合并好的大段有序结果拷贝进原始arr的[l,r]区间内\n    for (i = l, j = 0; i <= r; ++i, ++j) {\n        arr[i] = p[j];\n    }\n    delete[] p;\n    p = nullptr;\n}\nvoid MergeSort(int arr[], int begin, int end) {\n    if (begin >= end) {\n        return;\n    }\n    // 先递后归\n    int mid = (begin + end) / 2;\n    MergeSort(arr, begin, mid);\n    MergeSort(arr, mid + 1, end);\n    // 归回来就开始排序\n    Merge(arr, begin, mid, end);\n    // 排完序结束回到上一层继续处理\n}\n```\n\n## 堆排序\n\n### 二叉堆\n\n二叉堆就是一颗 **完全二叉树** ， 分为两种典型的堆： **大根堆** 和 **小根堆** 。\n\n:::info 完全二叉树的充分条件\n\n完全二叉树的最后一层的叶子节点都是靠左排列的，且除了最后一层的节点都是满的，最后一层可以不是满的。\n\n:::\n\n逻辑上是一颗完全二叉树，存储方式上用数组进行存储的。\n\n:::tip 数组与二叉树的关系\n\n`i` 为数组的下标，逻辑上对应的二叉树位置为：\n- 左孩子： `2 * i + 1`\n- 右孩子： `2 * i + 2`\n![](https://pic.akorin.icu/20250819150044468.webp)\n:::\n\n满足 `0 <= i <= (n - 1) / 2` ，`i` 代表数组的下标， `n` 代表最后一个元素的下标。\n- 如果 `arr[i] <= arr[2 * i + 1] && arr[i] <= arr[2 * i + 2]` ，就是小根堆  \n- 如果 `arr[i] > = arr[2 * i + 1] && arr[i] >= arr[2 * i + 2]` ，就是大根堆\n\n换人话来说就是：根节点（**堆顶**）和两个孩子节点值的大小关系，根节点的值比两个孩子的值大就是 **大根堆**， 比两个孩子的值小就是 **小根堆**。\n\n获取父节点的公式：\n- `(i - 1) / 2`  \n\n这里取 `i- 1 `是确保无论最后一个元素是左节点还是右节点都可以找到其父节点。\n\n:::info 叶子节点\n\n叶子节点：**既没有左孩子也没有右孩子**，在树的图形上就是“树枝的尽头”，没有子节点的节点。  \n\n:::\n\n由于堆的性质，叶子节点没有子节点，也就不需要进行比较。需要找到第一个非叶子节点来进行比较和操作。\n\n:::tip 什么是第一个非叶子节点\n\n1. 建堆时要**保证子树先变成堆**，再逐层往上合并。因此，堆都是 **从堆底往顶上看** ，那么第一个非叶子节点就是从堆底开始找。  \n2. 第一个非叶子节点也就变成了 **第一个要处理的有孩子的父节点**。  \n3. 要找到第一个非叶子节点，可以从最后的元素计算其父节点的位置：  \n    - `(n - 1) / 2` 或\n    - `size / 2` 其中 `size` 为队列元素个数\n\n:::\n\n\n### 入堆\n\n入堆即将某个数加入到堆中。入堆步骤（以大根堆为例）：\n1. 将要入堆的数据放入数组末尾，并计算对应树中的位置。\n2. 计算它的父节点位置，并与父节点进行比较，若大于父节点则与父节点进行位置交换。\n3. 重复上述1、2步骤直至无父节点（到达堆顶），或满足大根堆的要求（父节点大于孩子节点）。\n\n上述过程叫做 **上浮** 。在实际应用中，为了效率，上浮过程中不是交换位置，而是只操作父节点往下赋值，直到入堆节点上浮到对应位置，在该位置再赋值要入堆的元素。\n![](https://pic.akorin.icu/20250819175059577.webp)\n\n### 出堆\n\n出堆 **只能出堆顶元素** 。出堆步骤（以大根堆为例）：\n1. 直接将最后一个元素放到堆顶，然后开始 **下沉** 操作。\n2. 此时与其孩子节点做比较，并将较大的孩子与其交换。\n3. 重复上述步骤2，直到没有孩子（超出第一个非叶子节点 `i > (n - 1) / 2` ）或者其孩子节点均小于它。\n\n上述过程是 **下沉** ，将堆顶的元素往下放。与上浮相同，为了效率，下沉过程中只操作子节点往上赋值，直到堆顶元素下沉到对应位置再赋最后一个节点元素的值。\n![](https://pic.akorin.icu/20250819192544736.webp)\n\n### 入堆出堆的复杂度\n\n- 时间复杂度 O(logn)：即为树的高度。\n- 空间复杂度 O(1)；这两个操作都不用占用额外的空间。\n\n### 基于大根堆和小根堆的优先级队列\n\n优先级队列根据元素的 **优先级** 来决定谁先出来，而不单纯看谁先进入。而普通队列（FIFO）是先进先出。\n- 小根堆-> 每次取出最小值（优先级最高的元素）。\n- 大根堆-> 每次取出最大值（优先级最高的元素）。\n\n用代码实现堆的排序时，可以先实现优先级队列（即实现堆的出堆、入堆、是否空等操作）。\n\n```C++\n// 默认构造大根堆\nclass PriorityQueue {\npublic:\n    using Cmp = function<bool(int, int)>;\n    PriorityQueue(int size = 10, Cmp f = greater<int>()) :\n        que_(new int[size]), size_(0), cap_(size), cmp_(f) {}\n\n    ~PriorityQueue() {\n        delete[] que_;\n        que_ = nullptr;\n    }\n    void push(int data) {\n        if (size_ == cap_) {\n            int* p = new int[2 * cap_];\n            memcpy(p, que_, sizeof(int) * size_);\n            delete[] que_;\n            que_ = p;\n            cap_ *= 2;\n        }\n        siftUp(data);\n        ++size_;\n    }\n    int pop() {\n        if (empty())\n            throw \"No data. Fuck u!\";\n        int data = que_[0];\n        siftDown();\n        --size_;\n        return data;\n    }\n    int top() {\n        return que_[0];\n    }\n    bool empty() {\n        return !size_;\n    }\n    bool full() {\n        return size_ == cap_;\n    }\nprivate:\n    int* que_;\n    int size_;   // 有效数据个数\n    int cap_;    // 堆内存大小\n    Cmp cmp_;    // 比较函数\n    void siftUp(int data) {\n        // 大根堆比较，直接插入进堆尾\n        que_[size_] = data;\n        // 堆尾和父节点比较\n        int father = (size_ - 1) / 2;\n        // 记录入堆节点位置\n        int pos = size_;\n        // 跳出条件：父节点大于子节点或到达堆顶\n        while (cmp_(data, que_[father]) && father != pos) {\n            que_[pos] = que_[father];\n            pos = father;\n            father = (pos - 1) / 2;\n        }\n        // 到达对应位置跳出\n        que_[pos] = data;\n    }\n    void siftDown() {\n        int val = que_[size_ - 1];\n        int pos = 0;\n        while (pos < size_ / 2) {\n            int child = (2 * pos) + 1;\n            if (child + 1 < size_ && cmp_(que_[child + 1], que_[child])) {\n                child = child + 1;\n            }\n            if (cmp_(que_[child], val)) {\n                que_[pos] = que_[child];\n                pos = child;\n            } else {\n                break;\n            }\n        }\n        que_[pos] = val;\n    }\n};\n\n```\n\n### 堆排序\n\n完成了优先级序列就可以写堆排序了。\n1. 从第一个非叶子节点到0号位元素进行下沉调整， **保证每一个子树都成堆** （满足大根堆小根堆性质）。\n2. 此时已构建起正确的堆结构，只是一个 **优先级序列** 。逻辑上是 **完全二叉树** ，但是在 **物理结构** （数组）上还是乱序的，此时不断把堆顶固定到末尾即可。\n3. 将堆顶元素与末尾元素交换并下沉调整，但把最后的元素（原来的堆顶）当作不存在。\n4. 从第二趟开始，每次少一个元素。\n\n```C++\n// 堆的下沉调整\nvoid siftDown(int arr[], int i, int size) {\n    int val = arr[i];\n    while (i < size / 2) {\n        int child = i * 2 + 1;\n        // 右孩子存在且右孩子更大\n        if (child + 1 < size && arr[child] < arr[child + 1]) {\n            child = child + 1;\n        }\n        // 孩子节点更大就下沉\n        if (arr[child] > val) {\n            // 把大的放上去\n            arr[i] = arr[child];\n            i = child;\n        } else {\n            break;\n        }\n    }\n    arr[i] = val;\n}\nvoid HeapSort(int arr[], int size) {\n    // 1. 从第一个非叶子节点到0号位元素进行下沉调整\n    for (auto i = size / 2 - 1; i >= 0; --i) {\n        siftDown(arr, i, size);\n    }\n    // 2. 将堆顶元素与末尾交换并下沉调整\n    int n = size - 1;\n    for (auto i = n; i > 0; --i) {\n        int tmp = arr[i];\n        arr[i] = arr[0];\n        arr[0] = tmp;\n        siftDown(arr, 0, i);\n    }\n}\n```\n- 时间复杂度 O(logn)*O(n) = O(nlogn)：n个元素与末尾元素交换并进行下沉调整。\n- 空间复杂度 O(1)；不用占用额外的空间。\n- 非稳定算法。\n\n## 四种基础排序性能对比：\n分别使用快速排序、归并排序、希尔排序和堆排序，并计算所用时间。\n| 数据规模 | 快速排序 | 归并排序 | 堆排序   | 希尔排序 |\n| -------- | -------- | -------- | -------- | -------- |\n| 1000万   | 1.0819s  | 1.52038s | 2.8807s  | 3.23398s |\n| 5000万   | 5.98468s | 8.27358s | 19.2599s | 20.08s   |\n| 1亿      | 12.224s  | 17.1961s | 45.4734s | 46.0831s |\n\n从上述可以发现快速排序是真的快，堆排效率较差有几个原因：\n1. 快排或归排，遍历元素都是按照 **顺序遍历** 的，对CPU缓存是友好的（CPU缓存指令命中率高）；但是堆排序访问元素时，是按照 **父子关系访问** ，而不是顺序访问，在排序过程中，无论是上浮还是下沉，都对CPU缓存不友好。\n2. 堆排序的过程中，进行元素下沉调整所做的无效比较过多。放到堆顶的元素本来就很小，下沉后的位置和它原来的位置相差不大，无用功比较多。\n\n## 桶排序\n\n> 在这里只是做一个小了解。\n\n1. 找出最长的数字，确定处理的桶排序趟数（最长数字有几位）。\n2. 从个位开始，将对应位数上的数字放到相同序号的桶中，完成后再按照桶的序号以此取出桶里面的数据。\n3. 处理完所有的位数后，最终得到有序的数列。\n\n![](https://pic.akorin.icu/20250820222643792.webp)\n","cover":"https://pic.akorin.icu/20250819152244337.webp","date":"2025-08-18 02:11:08"},{"title":"搜索","tags":[],"categories":[],"author":"akorin","excerpt":"","link":"/search","content":"","cover":"","date":""},{"title":"","tags":[],"categories":[],"author":"akorin","excerpt":"","link":"/tags","content":"","cover":"","date":""}]
